<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/DashCible.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/DashCible.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;public class DashCible : MonoBehaviour&#10;{&#10;    [Header(&quot;Ciblage&quot;)]&#10;    [SerializeField]&#10;    private Camera aimCamera;&#10;    [SerializeField] private LayerMask enemyMask = ~0;&#10;    [SerializeField] private LayerMask obstacleMask = ~0;&#10;    [SerializeField] private float maxAimAngle = 30f;&#10;&#10;    [Header(&quot;Dash Ciblé Settings&quot;)]&#10;    [SerializeField] private int countDash = 3;&#10;    [SerializeField] private float slowMoTime = 0.75f;&#10;    [SerializeField] private float slowMoScale = 0.2f;&#10;    [SerializeField] private float distanceDash = 25f;&#10;    [SerializeField] private float cooldown = 1.5f;&#10;    [SerializeField]&#10;    private float dashDamage = 9999f;&#10;&#10;    [Header(&quot;Déplacement&quot;)]&#10;    [SerializeField] private float dashTravelTime = 0.08f;&#10;    [SerializeField] private float capsuleRadius = 0.4f;&#10;    [SerializeField] private float stopOffset = 1.0f;&#10;&#10;    [Header(&quot;Input&quot;)]&#10;    [SerializeField] private KeyCode activationKey = KeyCode.Q;&#10;&#10;    [Header(&quot;Références Joueur&quot;)]&#10;    [SerializeField] private FPSPlayerController playerController;&#10;    [SerializeField] private CharacterController characterController;&#10;    [SerializeField] private FPSMovement fpsMovement;&#10;&#10;    [Header(&quot;Rebond&quot;)]&#10;    [SerializeField] private Vector3 bounceDirection = new Vector3(0f, 0.85f, -0.35f);&#10;    [SerializeField, Tooltip(&quot;Si vrai, la direction de rebond est exprimée dans l'espace local du joueur.&quot;)]&#10;    private bool bounceDirectionIsLocal = true;&#10;    [SerializeField, Tooltip(&quot;Force constante appliquée après un dash réussi.&quot;)]&#10;    private float bounceForce = 18f;&#10;&#10;    public bool isDashing;&#10;    private bool chainActive;&#10;    private int remainingChains;&#10;    private float nextAvailableTime;&#10;    private float slowMoEndUnscaled;&#10;    public bool slowMoApplied;&#10;    private float previousTimeScale = 1f;&#10;    private bool pathElectricStunned;&#10;&#10;    private static readonly Collider[] OverlapBuffer = new Collider[16];&#10;&#10;    private void Awake()&#10;    {&#10;        if (playerController == null)&#10;            playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;        if (characterController == null &amp;&amp; playerController != null)&#10;            characterController = playerController.Controller;&#10;        if (fpsMovement == null)&#10;            fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;        if (aimCamera == null)&#10;            aimCamera = Camera.main;&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        if (slowMoApplied &amp;&amp; Time.unscaledTime &gt;= slowMoEndUnscaled)&#10;        {&#10;            ClearSlowMo();&#10;            if (!isDashing &amp;&amp; chainActive)&#10;            {&#10;                EndChain();&#10;            }&#10;        }&#10;&#10;        if (Input.GetKeyDown(activationKey))&#10;        {&#10;            TryTriggerOrChain();&#10;        }&#10;    }&#10;&#10;    private void TryTriggerOrChain()&#10;    {&#10;        if (isDashing) return;&#10;&#10;        if (!chainActive)&#10;        {&#10;            if (Time.time &lt; nextAvailableTime) return;&#10;            remainingChains = Mathf.Max(1, countDash);&#10;            chainActive = true;&#10;        }&#10;        else&#10;        {&#10;            if (!slowMoApplied || remainingChains &lt;= 0)&#10;            {&#10;                return;&#10;            }&#10;        }&#10;&#10;        var target = AcquireTarget();&#10;        if (target == null)&#10;        {&#10;            if (chainActive)&#10;            {&#10;                ClearSlowMo();&#10;                EndChain();&#10;            }&#10;            return;&#10;        }&#10;&#10;        remainingChains = Mathf.Max(0, remainingChains - 1);&#10;        StartCoroutine(DoTargetDash(target));&#10;    }&#10;&#10;    private EnemyHealth AcquireTarget()&#10;    {&#10;        if (aimCamera == null) return null;&#10;&#10;        Ray ray = aimCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;        if (Physics.Raycast(ray, out RaycastHit hit, distanceDash, enemyMask, QueryTriggerInteraction.Ignore))&#10;        {&#10;            var eh = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;            if (eh != null &amp;&amp; !eh.IsDead)&#10;            {&#10;                if (!IsObstructed(aimCamera.transform.position, eh.transform.position))&#10;                    return eh;&#10;            }&#10;        }&#10;&#10;        var all = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsInactive.Exclude, FindObjectsSortMode.None);&#10;        EnemyHealth best = null;&#10;        float bestScore = float.MaxValue;&#10;        Vector3 camPos = aimCamera.transform.position;&#10;        Vector3 camFwd = aimCamera.transform.forward;&#10;&#10;        foreach (var eh in all)&#10;        {&#10;            if (eh == null || eh.IsDead) continue;&#10;            Vector3 to = eh.transform.position - camPos;&#10;            float dist = to.magnitude;&#10;            if (dist &gt; distanceDash) continue;&#10;            Vector3 dir = to / (dist + 1e-5f);&#10;            float angle = Mathf.Acos(Mathf.Clamp(Vector3.Dot(camFwd, dir), -1f, 1f)) * Mathf.Rad2Deg;&#10;            if (angle &gt; maxAimAngle) continue;&#10;            if (IsObstructed(camPos, eh.transform.position)) continue;&#10;            float score = angle * 2f + dist * 0.2f;&#10;            if (score &lt; bestScore)&#10;            {&#10;                bestScore = score;&#10;                best = eh;&#10;            }&#10;        }&#10;&#10;        return best;&#10;    }&#10;&#10;    private bool IsObstructed(Vector3 from, Vector3 to)&#10;    {&#10;        Vector3 dir = to - from;&#10;        float dist = dir.magnitude;&#10;        if (dist &lt;= 0.01f) return false;&#10;        return Physics.Raycast(from, dir.normalized, dist - 0.1f, obstacleMask, QueryTriggerInteraction.Ignore);&#10;    }&#10;&#10;    private IEnumerator DoTargetDash(EnemyHealth target)&#10;    {&#10;        isDashing = true;&#10;        pathElectricStunned = false;&#10;&#10;        Vector3 start = transform.position;&#10;        Vector3 targetPos = target.transform.position;&#10;        Vector3 dirToTarget = (targetPos - start).normalized;&#10;        float distToTarget = Vector3.Distance(start, targetPos);&#10;&#10;        float stopDist = Mathf.Clamp(stopOffset, 0f, Mathf.Max(0f, distToTarget - 0.1f));&#10;        Vector3 end = targetPos - dirToTarget * stopDist;&#10;&#10;        Vector3 top = start + Vector3.up * 1.5f;&#10;        Vector3 bottom = start + Vector3.up * 0.2f;&#10;        Vector3 moveDir = (end - start);&#10;        float moveLen = moveDir.magnitude;&#10;        if (moveLen &gt; 0.01f)&#10;        {&#10;            if (Physics.CapsuleCast(top, bottom, capsuleRadius, moveDir.normalized, out RaycastHit hit, moveLen, obstacleMask, QueryTriggerInteraction.Ignore))&#10;            {&#10;                end = hit.point - moveDir.normalized * 0.2f;&#10;            }&#10;        }&#10;&#10;        if (fpsMovement != null)&#10;        {&#10;            fpsMovement.SetSpeedToMax();&#10;        }&#10;&#10;        float t0 = Time.unscaledTime;&#10;        float dur = Mathf.Max(0.01f, dashTravelTime);&#10;        Vector3 prev = start;&#10;&#10;        while (Time.unscaledTime - t0 &lt; dur)&#10;        {&#10;            float u = (Time.unscaledTime - t0) / dur;&#10;            Vector3 pos = Vector3.Lerp(start, end, u);&#10;            Vector3 delta = pos - prev;&#10;            if (characterController != null)&#10;                characterController.Move(delta);&#10;            else&#10;                transform.position = pos;&#10;            prev = pos;&#10;&#10;            TryStunElectricOnPath(pos);&#10;&#10;            yield return null;&#10;        }&#10;        Vector3 finalDelta = end - prev;&#10;        if (characterController != null)&#10;            characterController.Move(finalDelta);&#10;        else&#10;            transform.position = end;&#10;&#10;        var electric = target.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;        if (electric != null)&#10;        {&#10;            var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (electric.OverrideAutoFireInterval)&#10;                playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;            else&#10;                playerStun.ApplyStun(electric.StunDuration);&#10;&#10;            if (electric.ResistToDash)&#10;            {&#10;                isDashing = false;&#10;                ClearSlowMo();&#10;                EndChain();&#10;                yield break;&#10;            }&#10;        }&#10;&#10;        var hitCol = target.GetComponentInChildren&lt;Collider&gt;();&#10;        var dmg = new DamageInfo(amount: dashDamage, zoneName: &quot;Dash&quot;, type: DamageType.Dash, hitPoint: target.transform.position, hitNormal: -dirToTarget, attacker: transform, hitCollider: hitCol);&#10;        bool applied = target.TryApplyDamage(dmg);&#10;&#10;        if (applied)&#10;        {&#10;            ApplyOrRefreshSlowMo();&#10;            ApplyBounceImpulse(dirToTarget);&#10;        }&#10;&#10;        isDashing = false;&#10;&#10;        if (remainingChains &lt;= 0)&#10;        {&#10;            if (!slowMoApplied)&#10;            {&#10;                EndChain();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ApplyOrRefreshSlowMo()&#10;    {&#10;        slowMoEndUnscaled = Time.unscaledTime + Mathf.Max(0.01f, slowMoTime);&#10;        if (!slowMoApplied)&#10;        {&#10;            previousTimeScale = Time.timeScale;&#10;            Time.timeScale = Mathf.Clamp(slowMoScale, 0.01f, 1f);&#10;            Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;            slowMoApplied = true;&#10;        }&#10;    }&#10;&#10;    private void ClearSlowMo()&#10;    {&#10;        if (!slowMoApplied) return;&#10;        Time.timeScale = previousTimeScale;&#10;        Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;        slowMoApplied = false;&#10;    }&#10;&#10;    private void EndChain()&#10;    {&#10;        chainActive = false;&#10;        remainingChains = 0;&#10;        nextAvailableTime = Time.time + Mathf.Max(0f, cooldown);&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (slowMoApplied) ClearSlowMo();&#10;    }&#10;&#10;    private void OnDestroy()&#10;    {&#10;        if (slowMoApplied) ClearSlowMo();&#10;    }&#10;&#10;    public int CountDash { get =&gt; countDash; set =&gt; countDash = Mathf.Max(1, value); }&#10;    public float SlowMoTime { get =&gt; slowMoTime; set =&gt; slowMoTime = Mathf.Max(0.01f, value); }&#10;    public float DistanceDash { get =&gt; distanceDash; set =&gt; distanceDash = Mathf.Max(0.5f, value); }&#10;    public float Cooldown { get =&gt; cooldown; set =&gt; cooldown = Mathf.Max(0f, value); }&#10;&#10;    private void TryStunElectricOnPath(Vector3 currentPos)&#10;    {&#10;        if (pathElectricStunned) return;&#10;        Vector3 top = currentPos + Vector3.up * 1.5f;&#10;        Vector3 bottom = currentPos + Vector3.up * 0.2f;&#10;        int count = Physics.OverlapCapsuleNonAlloc(top, bottom, capsuleRadius, OverlapBuffer, enemyMask, QueryTriggerInteraction.Ignore);&#10;        for (int i = 0; i &lt; count; i++)&#10;        {&#10;            var col = OverlapBuffer[i];&#10;            if (col == null) continue;&#10;            var electric = col.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? col.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;            if (electric != null)&#10;            {&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;() ?? gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;                pathElectricStunned = true;&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ApplyBounceImpulse(Vector3 dashDirection)&#10;    {&#10;        if (bounceForce &lt;= 0f)&#10;            return;&#10;&#10;        Vector3 dir = ResolveBounceDirection(dashDirection);&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            return;&#10;&#10;        Vector3 momentum = dir.normalized * bounceForce;&#10;&#10;        if (fpsMovement != null)&#10;        {&#10;            fpsMovement.ApplyExternalMomentum(momentum);&#10;        }&#10;        else if (characterController != null)&#10;        {&#10;            characterController.Move(momentum * Time.deltaTime);&#10;        }&#10;        else&#10;        {&#10;            transform.position += momentum * Time.deltaTime;&#10;        }&#10;    }&#10;&#10;    private Vector3 ResolveBounceDirection(Vector3 fallbackDashDirection)&#10;    {&#10;        Vector3 dir = bounceDirectionIsLocal ? transform.TransformDirection(bounceDirection) : bounceDirection;&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            dir = -fallbackDashDirection;&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            return Vector3.up;&#10;        return dir.normalized;&#10;    }&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;public class DashCible : MonoBehaviour&#10;{&#10;    [Header(&quot;Ciblage&quot;)]&#10;    [SerializeField]&#10;    private Camera aimCamera;&#10;    [SerializeField] private LayerMask enemyMask = ~0;&#10;    [SerializeField] private LayerMask obstacleMask = ~0;&#10;    [SerializeField] private float maxAimAngle = 30f;&#10;&#10;    [Header(&quot;Dash Ciblé Settings&quot;)]&#10;    [SerializeField] private int countDash = 3;&#10;    [SerializeField] private float slowMoTime = 0.75f;&#10;    [SerializeField] private float slowMoScale = 0.2f;&#10;    [SerializeField] private float distanceDash = 25f;&#10;    [SerializeField] private float cooldown = 1.5f;&#10;    [SerializeField]&#10;    private float dashDamage = 9999f;&#10;&#10;    [Header(&quot;Déplacement&quot;)]&#10;    [SerializeField] private float dashTravelTime = 0.08f;&#10;    [SerializeField] private float capsuleRadius = 0.4f;&#10;    [SerializeField] private float stopOffset = 1.0f;&#10;&#10;    [Header(&quot;Input&quot;)]&#10;    [SerializeField] private KeyCode activationKey = KeyCode.Q;&#10;&#10;    [Header(&quot;Références Joueur&quot;)]&#10;    [SerializeField] private FPSPlayerController playerController;&#10;    [SerializeField] private CharacterController characterController;&#10;    [SerializeField] private FPSMovement fpsMovement;&#10;&#10;    [System.Serializable]&#10;    private class BounceConfig&#10;    {&#10;        public Vector3 direction = new Vector3(0f, 0.85f, -0.35f);&#10;        public bool directionIsLocal = true;&#10;        [Min(0f)] public float force = 18f;&#10;    }&#10;&#10;    [Header(&quot;Rebond&quot;)]&#10;    [SerializeField, Tooltip(&quot;Paramètres utilisés lorsque le joueur est au sol au moment de l’impact.&quot;)]&#10;    private BounceConfig groundBounce = new BounceConfig { direction = new Vector3(0f, 0.75f, -0.45f), directionIsLocal = true, force = 16f };&#10;    [SerializeField, Tooltip(&quot;Paramètres utilisés lorsque le joueur est en l’air au moment de l’impact.&quot;)]&#10;    private BounceConfig airBounce = new BounceConfig { direction = new Vector3(0f, 1f, -0.25f), directionIsLocal = true, force = 20f };&#10;&#10;    public bool isDashing;&#10;    private bool chainActive;&#10;    private int remainingChains;&#10;    private float nextAvailableTime;&#10;    private float slowMoEndUnscaled;&#10;    public bool slowMoApplied;&#10;    private float previousTimeScale = 1f;&#10;    private bool pathElectricStunned;&#10;&#10;    private static readonly Collider[] OverlapBuffer = new Collider[16];&#10;&#10;    private void Awake()&#10;    {&#10;        if (playerController == null)&#10;            playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;        if (characterController == null &amp;&amp; playerController != null)&#10;            characterController = playerController.Controller;&#10;        if (fpsMovement == null)&#10;            fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;        if (aimCamera == null)&#10;            aimCamera = Camera.main;&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        if (slowMoApplied &amp;&amp; Time.unscaledTime &gt;= slowMoEndUnscaled)&#10;        {&#10;            ClearSlowMo();&#10;            if (!isDashing &amp;&amp; chainActive)&#10;            {&#10;                EndChain();&#10;            }&#10;        }&#10;&#10;        if (Input.GetKeyDown(activationKey))&#10;        {&#10;            TryTriggerOrChain();&#10;        }&#10;    }&#10;&#10;    private void TryTriggerOrChain()&#10;    {&#10;        if (isDashing) return;&#10;&#10;        if (!chainActive)&#10;        {&#10;            if (Time.time &lt; nextAvailableTime) return;&#10;            remainingChains = Mathf.Max(1, countDash);&#10;            chainActive = true;&#10;        }&#10;        else&#10;        {&#10;            if (!slowMoApplied || remainingChains &lt;= 0)&#10;            {&#10;                return;&#10;            }&#10;        }&#10;&#10;        var target = AcquireTarget();&#10;        if (target == null)&#10;        {&#10;            if (chainActive)&#10;            {&#10;                ClearSlowMo();&#10;                EndChain();&#10;            }&#10;            return;&#10;        }&#10;&#10;        remainingChains = Mathf.Max(0, remainingChains - 1);&#10;        StartCoroutine(DoTargetDash(target));&#10;    }&#10;&#10;    private EnemyHealth AcquireTarget()&#10;    {&#10;        if (aimCamera == null) return null;&#10;&#10;        Ray ray = aimCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;        if (Physics.Raycast(ray, out RaycastHit hit, distanceDash, enemyMask, QueryTriggerInteraction.Ignore))&#10;        {&#10;            var eh = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;            if (eh != null &amp;&amp; !eh.IsDead)&#10;            {&#10;                if (!IsObstructed(aimCamera.transform.position, eh.transform.position))&#10;                    return eh;&#10;            }&#10;        }&#10;&#10;        var all = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsInactive.Exclude, FindObjectsSortMode.None);&#10;        EnemyHealth best = null;&#10;        float bestScore = float.MaxValue;&#10;        Vector3 camPos = aimCamera.transform.position;&#10;        Vector3 camFwd = aimCamera.transform.forward;&#10;&#10;        foreach (var eh in all)&#10;        {&#10;            if (eh == null || eh.IsDead) continue;&#10;            Vector3 to = eh.transform.position - camPos;&#10;            float dist = to.magnitude;&#10;            if (dist &gt; distanceDash) continue;&#10;            Vector3 dir = to / (dist + 1e-5f);&#10;            float angle = Mathf.Acos(Mathf.Clamp(Vector3.Dot(camFwd, dir), -1f, 1f)) * Mathf.Rad2Deg;&#10;            if (angle &gt; maxAimAngle) continue;&#10;            if (IsObstructed(camPos, eh.transform.position)) continue;&#10;            float score = angle * 2f + dist * 0.2f;&#10;            if (score &lt; bestScore)&#10;            {&#10;                bestScore = score;&#10;                best = eh;&#10;            }&#10;        }&#10;&#10;        return best;&#10;    }&#10;&#10;    private bool IsObstructed(Vector3 from, Vector3 to)&#10;    {&#10;        Vector3 dir = to - from;&#10;        float dist = dir.magnitude;&#10;        if (dist &lt;= 0.01f) return false;&#10;        return Physics.Raycast(from, dir.normalized, dist - 0.1f, obstacleMask, QueryTriggerInteraction.Ignore);&#10;    }&#10;&#10;    private IEnumerator DoTargetDash(EnemyHealth target)&#10;    {&#10;        isDashing = true;&#10;        pathElectricStunned = false;&#10;&#10;        Vector3 start = transform.position;&#10;        Vector3 targetPos = target.transform.position;&#10;        Vector3 dirToTarget = (targetPos - start).normalized;&#10;        float distToTarget = Vector3.Distance(start, targetPos);&#10;&#10;        float stopDist = Mathf.Clamp(stopOffset, 0f, Mathf.Max(0f, distToTarget - 0.1f));&#10;        Vector3 end = targetPos - dirToTarget * stopDist;&#10;&#10;        Vector3 top = start + Vector3.up * 1.5f;&#10;        Vector3 bottom = start + Vector3.up * 0.2f;&#10;        Vector3 moveDir = (end - start);&#10;        float moveLen = moveDir.magnitude;&#10;        if (moveLen &gt; 0.01f)&#10;        {&#10;            if (Physics.CapsuleCast(top, bottom, capsuleRadius, moveDir.normalized, out RaycastHit hit, moveLen, obstacleMask, QueryTriggerInteraction.Ignore))&#10;            {&#10;                end = hit.point - moveDir.normalized * 0.2f;&#10;            }&#10;        }&#10;&#10;        if (fpsMovement != null)&#10;        {&#10;            fpsMovement.SetSpeedToMax();&#10;        }&#10;&#10;        float t0 = Time.unscaledTime;&#10;        float dur = Mathf.Max(0.01f, dashTravelTime);&#10;        Vector3 prev = start;&#10;&#10;        while (Time.unscaledTime - t0 &lt; dur)&#10;        {&#10;            float u = (Time.unscaledTime - t0) / dur;&#10;            Vector3 pos = Vector3.Lerp(start, end, u);&#10;            Vector3 delta = pos - prev;&#10;            if (characterController != null)&#10;                characterController.Move(delta);&#10;            else&#10;                transform.position = pos;&#10;            prev = pos;&#10;&#10;            TryStunElectricOnPath(pos);&#10;&#10;            yield return null;&#10;        }&#10;        Vector3 finalDelta = end - prev;&#10;        if (characterController != null)&#10;            characterController.Move(finalDelta);&#10;        else&#10;            transform.position = end;&#10;&#10;        var electric = target.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;        if (electric != null)&#10;        {&#10;            var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (electric.OverrideAutoFireInterval)&#10;                playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;            else&#10;                playerStun.ApplyStun(electric.StunDuration);&#10;&#10;            if (electric.ResistToDash)&#10;            {&#10;                isDashing = false;&#10;                ClearSlowMo();&#10;                EndChain();&#10;                yield break;&#10;            }&#10;        }&#10;&#10;        var hitCol = target.GetComponentInChildren&lt;Collider&gt;();&#10;        var dmg = new DamageInfo(amount: dashDamage, zoneName: &quot;Dash&quot;, type: DamageType.Dash, hitPoint: target.transform.position, hitNormal: -dirToTarget, attacker: transform, hitCollider: hitCol);&#10;        bool applied = target.TryApplyDamage(dmg);&#10;&#10;        if (applied)&#10;        {&#10;            ApplyOrRefreshSlowMo();&#10;            ApplyBounceImpulse(dirToTarget);&#10;        }&#10;&#10;        isDashing = false;&#10;&#10;        if (remainingChains &lt;= 0)&#10;        {&#10;            if (!slowMoApplied)&#10;            {&#10;                EndChain();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ApplyOrRefreshSlowMo()&#10;    {&#10;        slowMoEndUnscaled = Time.unscaledTime + Mathf.Max(0.01f, slowMoTime);&#10;        if (!slowMoApplied)&#10;        {&#10;            previousTimeScale = Time.timeScale;&#10;            Time.timeScale = Mathf.Clamp(slowMoScale, 0.01f, 1f);&#10;            Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;            slowMoApplied = true;&#10;        }&#10;    }&#10;&#10;    private void ClearSlowMo()&#10;    {&#10;        if (!slowMoApplied) return;&#10;        Time.timeScale = previousTimeScale;&#10;        Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;        slowMoApplied = false;&#10;    }&#10;&#10;    private void EndChain()&#10;    {&#10;        chainActive = false;&#10;        remainingChains = 0;&#10;        nextAvailableTime = Time.time + Mathf.Max(0f, cooldown);&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (slowMoApplied) ClearSlowMo();&#10;    }&#10;&#10;    private void OnDestroy()&#10;    {&#10;        if (slowMoApplied) ClearSlowMo();&#10;    }&#10;&#10;    public int CountDash { get =&gt; countDash; set =&gt; countDash = Mathf.Max(1, value); }&#10;    public float SlowMoTime { get =&gt; slowMoTime; set =&gt; slowMoTime = Mathf.Max(0.01f, value); }&#10;    public float DistanceDash { get =&gt; distanceDash; set =&gt; distanceDash = Mathf.Max(0.5f, value); }&#10;    public float Cooldown { get =&gt; cooldown; set =&gt; cooldown = Mathf.Max(0f, value); }&#10;&#10;    private void TryStunElectricOnPath(Vector3 currentPos)&#10;    {&#10;        if (pathElectricStunned) return;&#10;        Vector3 top = currentPos + Vector3.up * 1.5f;&#10;        Vector3 bottom = currentPos + Vector3.up * 0.2f;&#10;        int count = Physics.OverlapCapsuleNonAlloc(top, bottom, capsuleRadius, OverlapBuffer, enemyMask, QueryTriggerInteraction.Ignore);&#10;        for (int i = 0; i &lt; count; i++)&#10;        {&#10;            var col = OverlapBuffer[i];&#10;            if (col == null) continue;&#10;            var electric = col.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? col.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;            if (electric != null)&#10;            {&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;() ?? gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;                pathElectricStunned = true;&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void ApplyBounceImpulse(Vector3 dashDirection)&#10;    {&#10;        BounceConfig config = GetCurrentBounceConfig();&#10;        if (config == null || config.force &lt;= 0f)&#10;            return;&#10;&#10;        Vector3 dir = ResolveBounceDirection(dashDirection, config);&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            return;&#10;&#10;        Vector3 momentum = dir.normalized * config.force;&#10;&#10;        if (fpsMovement != null)&#10;        {&#10;            fpsMovement.ApplyExternalMomentum(momentum);&#10;        }&#10;        else if (characterController != null)&#10;        {&#10;            characterController.Move(momentum * Time.deltaTime);&#10;        }&#10;        else&#10;        {&#10;            transform.position += momentum * Time.deltaTime;&#10;        }&#10;    }&#10;&#10;    private BounceConfig GetCurrentBounceConfig()&#10;    {&#10;        bool grounded = fpsMovement != null &amp;&amp; fpsMovement.IsGrounded;&#10;        return grounded ? groundBounce : airBounce;&#10;    }&#10;&#10;    private Vector3 ResolveBounceDirection(Vector3 fallbackDashDirection, BounceConfig config)&#10;    {&#10;        Vector3 dir = config.directionIsLocal ? transform.TransformDirection(config.direction) : config.direction;&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            dir = -fallbackDashDirection;&#10;        if (dir.sqrMagnitude &lt;= 1e-4f)&#10;            return Vector3.up;&#10;        return dir.normalized;&#10;    }&#10;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    /// Gère le mouvement du joueur&#10;    [RequireComponent(typeof(CharacterController))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnSpeedChanged = new UnityEvent&lt;float&gt;();&#10;&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;        &#10;        [Header(&quot;Jump Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Temps après avoir quitté le sol pendant lequel on peut encore sauter&quot;)]&#10;        private float coyoteTime = 0.15f;&#10;&#10;        private float defaultMoveSpeed;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de momentum lors du saut (1 = vitesse normale, &gt;1 = boost)&quot;)]&#10;        private float jumpMomentumMultiplier = 1f;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        private CharacterController controller;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private bool isGrounded;&#10;        private float coyoteTimeCounter;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;        &#10;        // Méthode pour forcer la vitesse au max (utilisée par le dash)&#10;        public void SetSpeedToMax()&#10;        {&#10;            moveSpeed = speedLimit;&#10;        }&#10;        &#10;        // Méthode pour appliquer un momentum externe (utilisée par le dash)&#10;        public void ApplyExternalMomentum(Vector3 momentum)&#10;        {&#10;            jumpMomentum = momentum;&#10;            // S'assurer que le joueur garde ce momentum&#10;            moveSpeed = Mathf.Max(moveSpeed, momentum.magnitude);&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        // Cette méthode sera appelée par le PlayerController&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            float previousSpeed = moveSpeed;&#10;&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;&#10;            if (!Mathf.Approximately(previousSpeed, moveSpeed))&#10;            {&#10;                OnSpeedChanged?.Invoke(moveSpeed);&#10;            }&#10;        }&#10;&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * input.x + transform.forward * input.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = sprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    controller.Move(desired * (CurrentSpeed * Time.deltaTime));&#10;                }&#10;&#10;                // Saut&#10;                if (jump)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); //&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Permettre le saut pendant le coyote time&#10;                if (jump &amp;&amp; coyoteTimeCounter &gt; 0f)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;                &#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    controller.Move(jumpMomentum * Time.deltaTime);&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        controller.Move(desired * (CurrentSpeed * airControlFactor * Time.deltaTime));&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Vector3 airMove = desired * CurrentSpeed * airControlFactor;&#10;                    moveDirection.x = Mathf.Lerp(moveDirection.x, airMove.x, airControlFactor);&#10;                    moveDirection.z = Mathf.Lerp(moveDirection.z, airMove.z, airControlFactor);&#10;                    &#10;                    controller.Move(new Vector3(moveDirection.x, 0, moveDirection.z) * Time.deltaTime);&#10;                }&#10;            }&#10;&#10;            // Appliquer la gravité&#10;            velocity.y += gravity * gravityMultiplier * Time.deltaTime;&#10;            controller.Move(new Vector3(0, velocity.y, 0) * Time.deltaTime);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            if (groundCheck != null &amp;&amp; groundMask != 0)&#10;            {&#10;                isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                isGrounded = controller.isGrounded;&#10;            }&#10;&#10;            // Gérer le coyote time&#10;            if (isGrounded)&#10;            {&#10;                coyoteTimeCounter = coyoteTime;&#10;            }&#10;            else&#10;            {&#10;                coyoteTimeCounter -= Time.deltaTime;&#10;            }&#10;&#10;            // Réinitialiser la vélocité verticale au sol&#10;            if (isGrounded &amp;&amp; velocity.y &lt; 0)&#10;            {&#10;                velocity.y = -2f;&#10;            }&#10;        }&#10;&#10;        public CharacterController Controller =&gt; controller;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    /// Gère le mouvement du joueur&#10;    [RequireComponent(typeof(CharacterController))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnSpeedChanged = new UnityEvent&lt;float&gt;();&#10;&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;        &#10;        [Header(&quot;Jump Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Temps après avoir quitté le sol pendant lequel on peut encore sauter&quot;)]&#10;        private float coyoteTime = 0.15f;&#10;&#10;        private float defaultMoveSpeed;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de momentum lors du saut (1 = vitesse normale, &gt;1 = boost)&quot;)]&#10;        private float jumpMomentumMultiplier = 1f;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        [Header(&quot;External Momentum&quot;)]&#10;        [SerializeField, Tooltip(&quot;Facteur de dissipation appliqué au momentum externe (0 = sans dissipation).&quot;)]&#10;        private float externalMomentumDamping = 12f;&#10;        [SerializeField, Tooltip(&quot;Durée pendant laquelle la composante verticale du momentum est conservée même si le joueur est au sol.&quot;)]&#10;        private float externalMomentumGroundGrace = 0.08f;&#10;&#10;        private CharacterController controller;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private Vector3 externalMomentum = Vector3.zero;&#10;        private float externalMomentumGroundTimer;&#10;        private bool isGrounded;&#10;        private float coyoteTimeCounter;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;        &#10;        // Méthode pour forcer la vitesse au max (utilisée par le dash)&#10;        public void SetSpeedToMax()&#10;        {&#10;            moveSpeed = speedLimit;&#10;        }&#10;        &#10;        // Méthode pour appliquer un momentum externe (utilisée par le dash)&#10;        public void ApplyExternalMomentum(Vector3 momentum)&#10;        {&#10;            externalMomentum = momentum;&#10;            externalMomentumGroundTimer = externalMomentumGroundGrace;&#10;            moveSpeed = Mathf.Max(moveSpeed, momentum.magnitude);&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        // Cette méthode sera appelée par le PlayerController&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            float previousSpeed = moveSpeed;&#10;&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;&#10;            if (!Mathf.Approximately(previousSpeed, moveSpeed))&#10;            {&#10;                OnSpeedChanged?.Invoke(moveSpeed);&#10;            }&#10;        }&#10;&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * input.x + transform.forward * input.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = sprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    controller.Move(desired * (CurrentSpeed * Time.deltaTime));&#10;                }&#10;&#10;                // Saut&#10;                if (jump)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); //&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Permettre le saut pendant le coyote time&#10;                if (jump &amp;&amp; coyoteTimeCounter &gt; 0f)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;                &#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    controller.Move(jumpMomentum * Time.deltaTime);&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        controller.Move(desired * (CurrentSpeed * airControlFactor * Time.deltaTime));&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Vector3 airMove = desired * CurrentSpeed * airControlFactor;&#10;                    moveDirection.x = Mathf.Lerp(moveDirection.x, airMove.x, airControlFactor);&#10;                    moveDirection.z = Mathf.Lerp(moveDirection.z, airMove.z, airControlFactor);&#10;                    &#10;                    controller.Move(new Vector3(moveDirection.x, 0, moveDirection.z) * Time.deltaTime);&#10;                }&#10;            }&#10;&#10;            ProcessExternalMomentum();&#10;            velocity.y += gravity * gravityMultiplier * Time.deltaTime;&#10;            controller.Move(new Vector3(0, velocity.y, 0) * Time.deltaTime);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            if (groundCheck != null &amp;&amp; groundMask != 0)&#10;            {&#10;                isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                isGrounded = controller.isGrounded;&#10;            }&#10;&#10;            // Gérer le coyote time&#10;            if (isGrounded)&#10;            {&#10;                coyoteTimeCounter = coyoteTime;&#10;            }&#10;            else&#10;            {&#10;                coyoteTimeCounter -= Time.deltaTime;&#10;            }&#10;&#10;            // Réinitialiser la vélocité verticale au sol&#10;            if (isGrounded &amp;&amp; velocity.y &lt; 0)&#10;            {&#10;                velocity.y = -2f;&#10;            }&#10;        }&#10;&#10;        private void ProcessExternalMomentum()&#10;        {&#10;            if (externalMomentum.sqrMagnitude &lt;= 1e-4f)&#10;                return;&#10;&#10;            if (externalMomentumGroundTimer &gt; 0f)&#10;                externalMomentumGroundTimer -= Time.deltaTime;&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; externalMomentum.y &gt; 0f)&#10;                externalMomentum.y = 0f;&#10;&#10;            controller.Move(externalMomentum * Time.deltaTime);&#10;&#10;            float damping = externalMomentumDamping;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f)&#10;                damping *= 1.5f;&#10;&#10;            if (damping &gt; 0f)&#10;            {&#10;                externalMomentum = Vector3.MoveTowards(externalMomentum, Vector3.zero, damping * Time.deltaTime);&#10;            }&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; Mathf.Abs(externalMomentum.y) &lt; 0.01f)&#10;                externalMomentum.y = 0f;&#10;        }&#10;&#10;        public CharacterController Controller =&gt; controller;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; Time.time &lt; 0.5f) // Fenêtre de 0.5s après le dash&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * currentSlideSpeed * Time.deltaTime;&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed * 0.6f);&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; dashSystem.isDashing)&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * (currentSlideSpeed * Time.deltaTime);&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * (currentSlideSpeed * 0.6f));&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_QUICKSTART.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_QUICKSTART.md" />
              <option name="updatedContent" value="# Slide System - Quick Start&#10;&#10;## Installation Rapide&#10;Le composant `Slide` est déjà configuré et prêt à l'emploi !&#10;&#10;## Contrôles&#10;- **Ctrl gauche** = Slider&#10;&#10;## Comment l'utiliser ?&#10;&#10;### Slide Basique&#10;1. Courez avec **WASD**&#10;2. Maintenez **Ctrl** pour slider&#10;3. Relâchez **Ctrl** pour vous relever&#10;&#10;### Combo Dash → Slide (Recommandé !)&#10;1. **Clic droit** pour dasher&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash = vitesse maximale !&#10;4. Vous pouvez traverser de très grandes distances&#10;&#10;### Astuces&#10;- Plus vous allez vite, plus le slide est long&#10;- Le slide décélère progressivement&#10;- Cooldown de 0.5s entre chaque slide&#10;- Maximum 2 secondes de slide&#10;- Ne fonctionne qu'au sol&#10;&#10;## Effets Visuels&#10;- Votre personnage s'abaisse&#10;- La caméra s'incline légèrement (5°)&#10;- Transitions fluides et smooth&#10;&#10;## Paramètres Clés (Inspector)&#10;- **Slide Speed** : 12 (vitesse de base)&#10;- **Speed Multiplier** : 1.3 (multiplie votre vitesse actuelle)&#10;- **Dash Momentum Multiplier** : 1.5 (après un dash)&#10;&#10;## C'est tout !&#10;Le système fonctionne automatiquement avec :&#10;- ✅ Le dash (synergie parfaite)&#10;- ✅ Le sprint&#10;- ✅ Le système de stun&#10;- ✅ Le saut (arrête le slide)&#10;&#10;Amusez-vous à enchaîner les combos de mouvement !&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md" />
              <option name="updatedContent" value="# Guide du Système de Slide&#10;&#10;## Vue d'ensemble&#10;Le système de slide permet au joueur de glisser au sol avec la touche **Ctrl** pour un gameplay dynamique et fluide. Il est conçu pour fonctionner en parfaite synergie avec le système de dash et le mouvement.&#10;&#10;## Contrôles&#10;- **Ctrl gauche** : Maintenir pour slider&#10;- Le slide suit la direction de votre mouvement (WASD) ou la direction de la caméra si vous ne bougez pas&#10;&#10;## Fonctionnalités Principales&#10;&#10;### 1. Démarrage du Slide&#10;- Appuyez sur **Ctrl** pendant que vous êtes au sol&#10;- Nécessite une vitesse minimale (configurable)&#10;- Le slide hérite de votre vitesse actuelle et la multiplie&#10;&#10;### 2. Synergie avec le Dash&#10;- Si vous slidez juste après un dash, le momentum est conservé et amplifié&#10;- Le multiplicateur de dash momentum permet des combos spectaculaires&#10;- Parfait pour enchaîner dash → slide pour traverser de grandes distances&#10;&#10;### 3. Physique du Slide&#10;- **Décélération progressive** : Le slide ralentit naturellement&#10;- **Vitesse minimale** : Le slide s'arrête si vous devenez trop lent&#10;- **Durée maximale** : 2 secondes par défaut pour équilibrer le gameplay&#10;- **Cooldown** : 0.5s entre chaque slide&#10;&#10;### 4. Effets Visuels&#10;- **Hauteur réduite** : Le CharacterController s'abaisse pendant le slide&#10;- **Inclinaison de caméra** : 5° d'inclinaison pour un effet dynamique&#10;- **Transitions smooth** : Toutes les transitions sont interpolées&#10;&#10;## Paramètres Configurables (Inspector)&#10;&#10;### Slide Settings&#10;- **Slide Speed** (12) : Vitesse de base du slide&#10;- **Speed Multiplier** (1.3) : Multiplie votre vitesse actuelle&#10;- **Slide Deceleration** (5) : Vitesse de ralentissement&#10;- **Min Slide Speed** (3) : Vitesse minimale pour continuer&#10;- **Max Slide Duration** (2) : Durée maximale en secondes&#10;- **Slide Cooldown** (0.5) : Temps entre chaque slide&#10;&#10;### Height Settings&#10;- **Slide Height** (1) : Hauteur du controller pendant le slide&#10;- **Height Transition Speed** (10) : Vitesse de transition de hauteur&#10;&#10;### Camera Settings&#10;- **Camera Tilt** (5) : Inclinaison en degrés&#10;- **Tilt Transition Speed** (8) : Vitesse de transition de l'inclinaison&#10;&#10;### Momentum Settings&#10;- **Inherit Dash Momentum** (true) : Hériter du momentum du dash&#10;- **Dash Momentum Multiplier** (1.5) : Multiplicateur du momentum hérité&#10;&#10;## Utilisation dans Unity&#10;&#10;### Configuration du Joueur&#10;1. Ajoutez le composant `Slide` à votre GameObject joueur&#10;2. Assurez-vous que les composants suivants sont présents :&#10;   - `CharacterController`&#10;   - `FPSMovement`&#10;   - `FPSMouseLook`&#10;   - `FPSInputHandler`&#10;   - `PillarDashSystem` (optionnel, pour la synergie)&#10;&#10;### Intégration dans le Code&#10;```csharp&#10;// Vérifier si le joueur peut slider&#10;Slide slideComponent = GetComponent&lt;Slide&gt;();&#10;if (slideComponent.CanSlide())&#10;{&#10;    // Le joueur peut slider&#10;}&#10;&#10;// Vérifier si le joueur est en train de slider&#10;if (slideComponent.IsSliding)&#10;{&#10;    // Le joueur slide actuellement&#10;}&#10;```&#10;&#10;## Mécaniques Avancées&#10;&#10;### Combo Dash → Slide&#10;1. Dashez avec clic droit vers un groupe d'ennemis&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash × 1.5&#10;4. Vous pouvez traverser de grandes distances à haute vitesse&#10;&#10;### Gestion du Momentum&#10;- Le slide conserve 60% du momentum à la fin pour une transition fluide&#10;- Le système `ApplyExternalMomentum()` assure une transition smooth avec le système de mouvement&#10;- Pas de téléportation ou de changement brusque de vitesse&#10;&#10;### Conditions d'Arrêt&#10;Le slide s'arrête automatiquement si :&#10;- Vous relâchez la touche **Ctrl**&#10;- La durée maximale est atteinte&#10;- Votre vitesse descend sous le minimum&#10;- Vous quittez le sol (saut ou chute)&#10;- Vous êtes stunné&#10;&#10;## Optimisation et Performance&#10;&#10;### Interpolations Smooth&#10;- Utilisation de `Mathf.Lerp` pour toutes les transitions&#10;- Évite les changements brusques qui pourraient causer du motion sickness&#10;- Les vitesses de transition sont configurables&#10;&#10;### Gestion de l'État&#10;- Le système vérifie automatiquement le stun&#10;- Intégration avec `PlayerStunAutoFire`&#10;- Désactivation automatique du slide pendant le stun&#10;&#10;## Conseils de Gameplay&#10;&#10;### Pour les Level Designers&#10;- Créez des pentes pour des slides spectaculaires&#10;- Placez des ennemis pour encourager les combos dash-slide&#10;- Utilisez le slide pour créer des shortcuts optionnels&#10;&#10;### Pour les Joueurs&#10;- Combinez sprint + slide pour une vitesse maximale&#10;- Utilisez le slide pour esquiver les projectiles&#10;- Le slide est parfait pour se repositionner rapidement&#10;- Dash → Slide → Saut = combo de mobilité ultime&#10;&#10;## Dépannage&#10;&#10;### Le slide ne démarre pas&#10;- Vérifiez que vous êtes au sol (`IsGrounded`)&#10;- Vérifiez que le cooldown est terminé&#10;- Vérifiez que vous n'êtes pas stunné&#10;- Vérifiez que vous avez une vitesse minimale&#10;&#10;### Le slide s'arrête trop vite&#10;- Augmentez `Min Slide Speed`&#10;- Réduisez `Slide Deceleration`&#10;- Augmentez `Max Slide Duration`&#10;&#10;### Transitions saccadées&#10;- Augmentez `Height Transition Speed`&#10;- Augmentez `Tilt Transition Speed`&#10;- Vérifiez que le framerate est stable&#10;&#10;## API Publique&#10;&#10;```csharp&#10;public class Slide : MonoBehaviour&#10;{&#10;    // Propriétés&#10;    public bool IsSliding { get; }  // Le joueur slide-t-il ?&#10;    &#10;    // Méthodes&#10;    public bool CanSlide();  // Le joueur peut-il slider ?&#10;}&#10;```&#10;&#10;## Notes Techniques&#10;&#10;### Synergie avec les Systèmes Existants&#10;- **FPSMovement** : Utilise `ApplyExternalMomentum()` pour le momentum&#10;- **FPSInputHandler** : Lit `MoveInput` pour la direction&#10;- **PillarDashSystem** : Vérifie `isDashing` pour hériter du momentum&#10;- **PlayerStunAutoFire** : Désactive le slide pendant le stun&#10;&#10;### Gestion de la Hauteur&#10;- Modifie dynamiquement `CharacterController.height` et `center`&#10;- Conserve les valeurs originales pour la restauration&#10;- Évite les problèmes de collision grâce aux transitions smooth&#10;&#10;### Performance&#10;- Aucun allocation mémoire pendant le slide&#10;- Utilisation optimale de `Vector3` et `Mathf`&#10;- Pas de coroutines, tout dans `Update()`&#10;&#10;## Améliorations Futures Possibles&#10;- Particules de poussière pendant le slide&#10;- Son de glissement&#10;- Trail renderer pour l'effet de vitesse&#10;- Bonus de vitesse sur certaines surfaces (glace, etc.)&#10;- Dégâts aux ennemis pendant le slide (comme le dash)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md" />
              <option name="updatedContent" value="# Résumé du Système de Slide&#10;&#10;##  Vue d'ensemble&#10;Système de slide activé avec **Ctrl** qui s'intègre parfaitement avec le dash et le système de mouvement pour créer un gameplay fluide et dynamique.&#10;&#10;## ✨ Caractéristiques Principales&#10;&#10;###  Contrôles&#10;- **Ctrl gauche (maintenu)** : Activer/maintenir le slide&#10;- Fonctionne uniquement au sol&#10;- Direction = mouvement actuel ou direction de la caméra&#10;&#10;### ⚡ Synergie avec le Dash&#10;- Hérite automatiquement du momentum du dash&#10;- Multiplicateur de 1.5x sur la vitesse du dash&#10;- Permet des combos dash → slide spectaculaires&#10;- Transition parfaitement smooth&#10;&#10;###  Physique du Slide&#10;- **Vitesse de base** : 12 unités/s&#10;- **Multiplicateur de vitesse** : 1.3x de votre vitesse actuelle&#10;- **Décélération** : 5 unités/s² (progressive et naturelle)&#10;- **Vitesse minimale** : 3 unités/s (arrêt automatique en dessous)&#10;- **Durée max** : 2 secondes&#10;- **Cooldown** : 0.5 secondes&#10;&#10;###  Effets Visuels&#10;- **Hauteur réduite** : CharacterController passe à 1 unité&#10;- **Inclinaison caméra** : 5° pour effet de vitesse&#10;- **Transitions smooth** : Interpolation Lerp sur tous les paramètres&#10;- Pas de téléportation ou changement brusque&#10;&#10;##  Architecture Technique&#10;&#10;### Composants Requis&#10;```&#10;GameObject Joueur&#10;├── CharacterController (Unity)&#10;├── FPSMovement (vitesse et momentum)&#10;├── FPSMouseLook (caméra)&#10;├── FPSInputHandler (inputs)&#10;├── PillarDashSystem (optionnel, pour synergie)&#10;└── Slide (nouveau composant) ✨&#10;```&#10;&#10;### Méthodes Publiques&#10;```csharp&#10;public bool IsSliding { get; }  // État actuel&#10;public bool CanSlide();         // Vérification de disponibilité&#10;```&#10;&#10;### Intégration avec Systèmes Existants&#10;- ✅ **FPSMovement** : `ApplyExternalMomentum()` pour momentum smooth&#10;- ✅ **PillarDashSystem** : Détection de `isDashing` pour héritage&#10;- ✅ **PlayerStunAutoFire** : Désactivation automatique pendant stun&#10;- ✅ **FPSInputHandler** : Lecture de `MoveInput` pour direction&#10;&#10;##  Conditions de Fonctionnement&#10;&#10;### Démarrage du Slide&#10;1. Joueur au sol (`IsGrounded`)&#10;2. Cooldown terminé (0.5s)&#10;3. Pas de stun actif&#10;4. Vitesse minimale atteinte OU mouvement actif&#10;5. Touche Ctrl maintenue&#10;&#10;### Arrêt du Slide&#10;- Touche Ctrl relâchée&#10;- Durée maximale atteinte (2s)&#10;- Vitesse trop faible (&lt; 3)&#10;- Joueur en l'air&#10;- Stun appliqué&#10;&#10;##  Flux de Gameplay&#10;&#10;### Combo Recommandé&#10;```&#10;1. Sprint (Shift) → Vitesse augmente&#10;2. Dash (Clic droit) → Vitesse maximale + kill ennemis&#10;3. Slide (Ctrl) → Hérite momentum × 1.5&#10;4. Transition smooth vers mouvement normal&#10;```&#10;&#10;### Gestion du Momentum&#10;```&#10;Début slide : Max(slideSpeed, currentSpeed × multiplier)&#10;Pendant slide : Décélération progressive&#10;Fin slide : Conservation de 60% du momentum&#10;→ Transition fluide sans rupture de vitesse&#10;```&#10;&#10;##  Paramètres Configurables&#10;&#10;| Paramètre | Valeur par défaut | Description |&#10;|-----------|-------------------|-------------|&#10;| Slide Speed | 12 | Vitesse de base |&#10;| Speed Multiplier | 1.3 | Multiplie vitesse actuelle |&#10;| Slide Deceleration | 5 | Ralentissement progressif |&#10;| Min Slide Speed | 3 | Seuil d'arrêt |&#10;| Max Slide Duration | 2 | Durée maximale (s) |&#10;| Slide Cooldown | 0.5 | Temps entre slides (s) |&#10;| Slide Height | 1 | Hauteur du controller |&#10;| Camera Tilt | 5 | Inclinaison (degrés) |&#10;| Dash Momentum Multiplier | 1.5 | Bonus après dash |&#10;&#10;##  Performance&#10;&#10;### Optimisations&#10;- ❌ Pas d'allocation mémoire pendant l'exécution&#10;- ❌ Pas de coroutines&#10;- ✅ Tout dans `Update()` avec early returns&#10;- ✅ Ordre de multiplication optimisé&#10;- ✅ Utilisation de propriétés cached&#10;&#10;### Garbage Collection&#10;- 0 allocation par frame&#10;- Références cached dans `Awake()`&#10;- Pas de `GetComponent()` dans `Update()`&#10;&#10;##  Documentation&#10;&#10;### Fichiers Créés&#10;- `Slide.cs` : Composant principal (280 lignes)&#10;- `SLIDE_SYSTEM_GUIDE.md` : Guide complet&#10;- `SLIDE_QUICKSTART.md` : Démarrage rapide&#10;- `SLIDE_SYSTEM_SUMMARY.md` : Ce fichier&#10;&#10;### Modifications Apportées&#10;- `FPSInputHandler.cs` : Ajout de `SprintPressed`&#10;&#10;##  Cas d'Usage&#10;&#10;### Level Design&#10;- Pentes pour slides spectaculaires&#10;- Zones de combat avec dash-slide combos&#10;- Shortcuts nécessitant maîtrise du momentum&#10;&#10;### Gameplay&#10;- Mobilité tactique en combat&#10;- Esquive de projectiles&#10;- Traversée rapide de maps&#10;- Combos de mouvement créatifs&#10;&#10;## ⚠️ Notes Importantes&#10;&#10;### Limitations&#10;- Fonctionne uniquement au sol&#10;- Pas de slide en l'air (arrêt automatique)&#10;- Cooldown impose un rythme&#10;- Durée max évite les abus&#10;&#10;### Compatibilité&#10;- Compatible avec tous les systèmes FPS existants&#10;- Pas d'impact sur les autres mécaniques&#10;- Peut être désactivé sans casser le jeu&#10;&#10;##  Extensions Possibles&#10;&#10;### Améliorations Futures&#10;- Particules de poussière/friction&#10;- Son de glissement dynamique&#10;- Trail renderer pour effet de vitesse&#10;- Surfaces spéciales (glace = moins de friction)&#10;- Dégâts aux ennemis pendant le slide&#10;- Animation du personnage&#10;- Shake de caméra proportionnel à la vitesse&#10;&#10;### API Extensible&#10;Le système est conçu pour être facilement étendu :&#10;- Méthode `CanSlide()` pour conditions custom&#10;- Events possibles (OnSlideStart, OnSlideEnd)&#10;- Paramètres exposés dans l'inspector&#10;&#10;## ✅ Status&#10;- [x] Implémentation complète&#10;- [x] Intégration avec systèmes existants&#10;- [x] Documentation complète&#10;- [x] Tests de compilation OK&#10;- [x] Optimisations appliquées&#10;- [x] Guides utilisateur créés&#10;&#10;**Le système est prêt à l'emploi !** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>