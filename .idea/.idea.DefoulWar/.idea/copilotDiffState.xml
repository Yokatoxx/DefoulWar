<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.Rendering;&#10;using TMPro;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le mouvement du joueur (déplacement, saut, contrôle en l'air)&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(CharacterController))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;&#10;        private float defaultMoveSpeed;&#10;        [SerializeField] private TextMeshProUGUI speedDisplay;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        private CharacterController controller;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private bool isGrounded;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    speedDisplay.text = &quot;Speed: &quot; + Mathf.RoundToInt(moveSpeed).ToString();&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                speedDisplay.text = &quot;Speed: &quot; + Mathf.RoundToInt(moveSpeed).ToString();&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;        }&#10;&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * input.x + transform.forward * input.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = sprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    controller.Move(desired * (CurrentSpeed * Time.deltaTime));&#10;                }&#10;&#10;                // Saut&#10;                if (jump)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); //&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    controller.Move(jumpMomentum * Time.deltaTime);&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        controller.Move(desired * (CurrentSpeed * airControlFactor * Time.deltaTime));&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Contrôle normal en l'air avec Lerp progressif (comme message(8).cs)&#10;                    Vector3 airMove = desired * CurrentSpeed * airControlFactor;&#10;                    moveDirection.x = Mathf.Lerp(moveDirection.x, airMove.x, airControlFactor);&#10;                    moveDirection.z = Mathf.Lerp(moveDirection.z, airMove.z, airControlFactor);&#10;                    &#10;                    controller.Move(new Vector3(moveDirection.x, 0, moveDirection.z) * Time.deltaTime);&#10;                }&#10;            }&#10;            &#10;            // Appliquer la gravité&#10;            velocity.y += gravity * Time.deltaTime;&#10;            controller.Move(new Vector3(0, velocity.y, 0) * Time.deltaTime);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            if (groundCheck != null &amp;&amp; groundMask != 0)&#10;            {&#10;                isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                isGrounded = controller.isGrounded;&#10;            }&#10;&#10;            // Réinitialiser la vélocité verticale au sol&#10;            if (isGrounded &amp;&amp; velocity.y &lt; 0)&#10;            {&#10;                velocity.y = -2f;&#10;            }&#10;        }&#10;&#10;        public CharacterController Controller =&gt; controller;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.Rendering;&#10;using TMPro;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le mouvement du joueur (déplacement, saut, contrôle en l'air)&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(CharacterController))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;&#10;        private float defaultMoveSpeed;&#10;        [SerializeField] private TextMeshProUGUI speedDisplay;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        private CharacterController controller;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private bool isGrounded;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    speedDisplay.text = &quot;Speed: &quot; + Mathf.RoundToInt(moveSpeed).ToString();&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                speedDisplay.text = &quot;Speed: &quot; + Mathf.RoundToInt(moveSpeed).ToString();&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;        }&#10;&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * input.x + transform.forward * input.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = sprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    controller.Move(desired * (CurrentSpeed * Time.deltaTime));&#10;                }&#10;&#10;                // Saut&#10;                if (jump)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); //&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    controller.Move(jumpMomentum * Time.deltaTime);&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        controller.Move(desired * (CurrentSpeed * airControlFactor * Time.deltaTime));&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Contrôle normal en l'air avec Lerp progressif (comme message(8).cs)&#10;                    Vector3 airMove = desired * CurrentSpeed * airControlFactor;&#10;                    moveDirection.x = Mathf.Lerp(moveDirection.x, airMove.x, airControlFactor);&#10;                    moveDirection.z = Mathf.Lerp(moveDirection.z, airMove.z, airControlFactor);&#10;                    &#10;                    controller.Move(new Vector3(moveDirection.x, 0, moveDirection.z) * Time.deltaTime);&#10;                }&#10;            }&#10;            &#10;            // Appliquer la gravité&#10;            velocity.y += gravity * gravityMultiplier * Time.deltaTime;&#10;            controller.Move(new Vector3(0, velocity.y, 0) * Time.deltaTime);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            if (groundCheck != null &amp;&amp; groundMask != 0)&#10;            {&#10;                isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                isGrounded = controller.isGrounded;&#10;            }&#10;&#10;            // Réinitialiser la vélocité verticale au sol&#10;            if (isGrounded &amp;&amp; velocity.y &lt; 0)&#10;            {&#10;                velocity.y = -2f;&#10;            }&#10;        }&#10;&#10;        public CharacterController Controller =&gt; controller;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>