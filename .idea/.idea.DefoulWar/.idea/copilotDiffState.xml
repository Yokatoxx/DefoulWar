<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Ennemies/Effect/MagicEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Ennemies/Effect/MagicEnemy.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Proto3GD.FPS;&#10;&#10;namespace Ennemies.Effect&#10;{&#10;    // Ennemi magique qui renvoie les tirs du joueur et soigne le joueur lorsqu'il est tué par un dash.&#10;&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class MagicEnemy : MonoBehaviour&#10;    {&#10;        &#10;        [Tooltip(&quot;Mode de réflexion: true = Hitscan instantané, false = Projectile physique&quot;)]&#10;        [SerializeField] private bool useHitscanReflect = false;&#10;        &#10;        [Tooltip(&quot;Vitesse du projectile magique renvoyé (ignoré si hitscan)&quot;)]&#10;        [SerializeField] private float reflectedBulletSpeed = 30f;&#10;        &#10;        [Tooltip(&quot;Dégâts du projectile renvoyé au joueur&quot;)]&#10;        [SerializeField] private float reflectedDamage = 15f;&#10;        &#10;        [Tooltip(&quot;Temps minimum entre deux réflexions (en secondes)&quot;)]&#10;        [SerializeField] private float reflectCooldown = 0.15f;&#10;        &#10;        [Tooltip(&quot;Prefab du projectile magique renvoyé (si null, utilise Bullet.CreateBulletPrefab())&quot;)]&#10;        [SerializeField] private GameObject magicBulletPrefab;&#10;        &#10;        [Tooltip(&quot;Effet visuel lors de la réflexion (optionnel)&quot;)]&#10;        [SerializeField] private GameObject reflectEffectPrefab;&#10;        &#10;        [Tooltip(&quot;Durée de l'effet visuel de réflexion&quot;)]&#10;        [SerializeField] private float reflectEffectDuration = 0.5f;&#10;        &#10;        [Header(&quot;Soin lors du dash&quot;)]&#10;        [Tooltip(&quot;Points de vie rendus au joueur lorsqu'il tue cet ennemi avec un dash&quot;)]&#10;        [SerializeField] private float healAmount = 30f;&#10;        &#10;        [Tooltip(&quot;Effet visuel de soin (optionnel)&quot;)]&#10;        [SerializeField] private GameObject healEffectPrefab;&#10;        &#10;        [Tooltip(&quot;Durée de l'effet visuel de soin&quot;)]&#10;        [SerializeField] private float healEffectDuration = 1f;&#10;        &#10;        [Header(&quot;Effet visuel de protection&quot;)]&#10;        [Tooltip(&quot;Particules ou aura de protection magique (optionnel)&quot;)]&#10;        [SerializeField] private GameObject magicShieldEffect;&#10;        &#10;        private EnemyHealth health;&#10;        private float lastReflectTime = -999f;&#10;        private GameObject cachedBulletPrefab;&#10;        &#10;        private void Awake()&#10;        {&#10;            health = GetComponent&lt;EnemyHealth&gt;();&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.AddListener(OnDeath);&#10;                health.OnDamageTaken.AddListener(OnDamageTaken);&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // Activer l'effet de bouclier magique (si présent)&#10;            if (magicShieldEffect != null)&#10;            {&#10;                magicShieldEffect.SetActive(true);&#10;            }&#10;            &#10;            else&#10;            {&#10;                cachedBulletPrefab = magicBulletPrefab;&#10;            }&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.RemoveListener(OnDeath);&#10;                health.OnDamageTaken.RemoveListener(OnDamageTaken);&#10;            }&#10;        }&#10;        &#10;        private void OnDeath()&#10;        {&#10;            // Vérifier si l'ennemi a été tué par un dash&#10;            var dashSystem = FindFirstObjectByType&lt;PillarDashSystem&gt;();&#10;            if (dashSystem != null &amp;&amp; PillarDashSystem.WasKilledByDash(transform.root.gameObject))&#10;            {&#10;                // Soigner le joueur&#10;                HealPlayer();&#10;            }&#10;            &#10;            // Désactiver l'effet de bouclier magique&#10;            if (magicShieldEffect != null)&#10;            {&#10;                magicShieldEffect.SetActive(false);&#10;            }&#10;        }&#10;        &#10;&#10;        // Intercepte les tirs&#10;&#10;        private void OnDamageTaken(float damage, string zoneName)&#10;        {&#10;            // Annuler les dégâts cet ennemi ne prend pas de dégâts des balles&#10;            if (health != null &amp;&amp; zoneName != &quot;Dash&quot;)&#10;            {&#10;                var healthField = typeof(EnemyHealth).GetField(&quot;currentHealth&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                if (healthField != null)&#10;                {&#10;                    float currentHealth = (float)healthField.GetValue(health);&#10;                    healthField.SetValue(health, currentHealth + damage);&#10;                }&#10;            }&#10;            &#10;            // Vérifier le cooldown&#10;            if (Time.time - lastReflectTime &lt; reflectCooldown)&#10;            {&#10;                return;&#10;            }&#10;            &#10;            &#10;            // Trouver le joueur pour renvoyer le projectile&#10;            var player = FindFirstObjectByType&lt;PlayerHealth&gt;();&#10;            if (player == null) return;&#10;            &#10;            lastReflectTime = Time.time;&#10;            &#10;            &#10;            // Choisir le mode de réflexion&#10;            if (useHitscanReflect)&#10;            {&#10;                // Hitscan&#10;                ReflectHitscan(player);&#10;            }&#10;            else&#10;            {&#10;                // Projectile&#10;                CreateMagicBullet(player.transform.position);&#10;            }&#10;        }&#10;        &#10;        // Renvoie un tir hitscan instantané vers le joueur&#10;        private void ReflectHitscan(PlayerHealth player)&#10;        {&#10;            player.TakeDamage(reflectedDamage);&#10;            &#10;            // Effet visuel de ligne/rayon entre l'ennemi et le joueur&#10;            Debug.DrawLine(transform.position + Vector3.up * 1.5f, player.transform.position, &#10;                new Color(0.8f, 0.2f, 1f), 0.1f);&#10;            &#10;            Debug.Log(&quot;[MagicEnemy] Tir hitscan instantané renvoyé vers le joueur !&quot;);&#10;        }&#10;        &#10;        // Crée un projectile magique&#10;&#10;        private void CreateMagicBullet(Vector3 targetPosition)&#10;        {&#10;            if (cachedBulletPrefab == null)&#10;            {&#10;                Debug.LogWarning(&quot;[MagicEnemy] Aucun prefab de balle magique disponible !&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Position de spawn&#10;            Vector3 spawnPosition = transform.position + Vector3.up * 1.5f;&#10;            &#10;            // Direction vers le joueur&#10;            Vector3 directionToPlayer = (targetPosition - spawnPosition).normalized;&#10;            &#10;            // Créer le projectile&#10;            GameObject magicBullet = Instantiate(&#10;                cachedBulletPrefab,&#10;                spawnPosition,&#10;                Quaternion.LookRotation(directionToPlayer)&#10;            );&#10;            &#10;            // Configurer le projectile&#10;            var bulletScript = magicBullet.GetComponent&lt;Bullet&gt;();&#10;            if (bulletScript != null)&#10;            {&#10;                bulletScript.Initialize(reflectedDamage, reflectedBulletSpeed);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de script Bullet, utiliser directement le Rigidbody&#10;                var rb = magicBullet.GetComponent&lt;Rigidbody&gt;();&#10;                if (rb != null)&#10;                {&#10;                    rb.linearVelocity = directionToPlayer * reflectedBulletSpeed;&#10;                }&#10;            }&#10;            &#10;        }&#10;        &#10;        // Soigne le joueur&#10;        private void HealPlayer()&#10;        {&#10;            var player = FindFirstObjectByType&lt;PlayerHealth&gt;();&#10;            if (player != null)&#10;            {&#10;                player.Heal(healAmount);&#10;                Debug.Log($&quot;[MagicEnemy] Le joueur a récupéré {healAmount} PV !&quot;);&#10;                &#10;                // Créer l'effet visuel de soin sur le joueur&#10;                if (healEffectPrefab != null)&#10;                {&#10;                    CreateHealEffect(player.transform.position);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Crée un effet visuel de réflexion&#10;        private void CreateReflectEffect(Vector3 position)&#10;        {&#10;            GameObject effect = Instantiate(reflectEffectPrefab, position, Quaternion.identity);&#10;            Destroy(effect, reflectEffectDuration);&#10;        }&#10;        &#10;        // Crée un effet visuel de soin&#10;        private void CreateHealEffect(Vector3 position)&#10;        {&#10;            GameObject effect = Instantiate(healEffectPrefab, position, Quaternion.identity);&#10;            Destroy(effect, healEffectDuration);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Proto3GD.FPS;&#10;&#10;namespace Ennemies.Effect&#10;{&#10;    // Ennemi magique qui renvoie les tirs du joueur et soigne le joueur lorsqu'il est tué par un dash.&#10;&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class MagicEnemy : MonoBehaviour&#10;    {&#10;        &#10;        [Tooltip(&quot;Mode de réflexion: true = Hitscan instantané, false = Projectile physique&quot;)]&#10;        [SerializeField] private bool useHitscanReflect;&#10;        &#10;        [Tooltip(&quot;Vitesse du projectile magique renvoyé (ignoré si hitscan)&quot;)]&#10;        [SerializeField] private float reflectedBulletSpeed = 30f;&#10;        &#10;        [Tooltip(&quot;Dégâts du projectile renvoyé au joueur&quot;)]&#10;        [SerializeField] private float reflectedDamage = 15f;&#10;        &#10;        [Tooltip(&quot;Temps minimum entre deux réflexions (en secondes)&quot;)]&#10;        [SerializeField] private float reflectCooldown = 0.15f;&#10;        &#10;        [Tooltip(&quot;Prefab du projectile magique renvoyé (si null, utilise Bullet.CreateBulletPrefab())&quot;)]&#10;        [SerializeField] private GameObject magicBulletPrefab;&#10;        &#10;        [Tooltip(&quot;Effet visuel lors de la réflexion (optionnel)&quot;)]&#10;        [SerializeField] private GameObject reflectEffectPrefab;&#10;        &#10;        [Tooltip(&quot;Durée de l'effet visuel de réflexion&quot;)]&#10;        [SerializeField] private float reflectEffectDuration = 0.5f;&#10;        &#10;        [Header(&quot;Soin lors du dash&quot;)]&#10;        [Tooltip(&quot;Points de vie rendus au joueur lorsqu'il tue cet ennemi avec un dash&quot;)]&#10;        [SerializeField] private float healAmount = 30f;&#10;        &#10;        [Tooltip(&quot;Effet visuel de soin (optionnel)&quot;)]&#10;        [SerializeField] private GameObject healEffectPrefab;&#10;        &#10;        [Tooltip(&quot;Durée de l'effet visuel de soin&quot;)]&#10;        [SerializeField] private float healEffectDuration = 1f;&#10;        &#10;        [Header(&quot;Effet visuel de protection&quot;)]&#10;        [Tooltip(&quot;Particules ou aura de protection magique (optionnel)&quot;)]&#10;        [SerializeField] private GameObject magicShieldEffect;&#10;        &#10;        private EnemyHealth health;&#10;        private float lastReflectTime = -999f;&#10;        private GameObject cachedBulletPrefab;&#10;        &#10;        private void Awake()&#10;        {&#10;            health = GetComponent&lt;EnemyHealth&gt;();&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.AddListener(OnDeath);&#10;                health.OnDamageTaken.AddListener(OnDamageTaken);&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // Activer l'effet de bouclier magique (si présent)&#10;            if (magicShieldEffect != null)&#10;            {&#10;                magicShieldEffect.SetActive(true);&#10;            }&#10;            &#10;            else&#10;            {&#10;                cachedBulletPrefab = magicBulletPrefab;&#10;            }&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.RemoveListener(OnDeath);&#10;                health.OnDamageTaken.RemoveListener(OnDamageTaken);&#10;            }&#10;        }&#10;        &#10;        private void OnDeath()&#10;        {&#10;            // Vérifier si l'ennemi a été tué par un dash&#10;            if (health != null &amp;&amp; health.KilledByDash)&#10;            {&#10;                // Soigner le joueur&#10;                HealPlayer();&#10;            }&#10;            &#10;            // Désactiver l'effet de bouclier magique&#10;            if (magicShieldEffect != null)&#10;            {&#10;                magicShieldEffect.SetActive(false);&#10;            }&#10;        }&#10;        &#10;&#10;        // Intercepte les tirs&#10;&#10;        private void OnDamageTaken(float damage, string zoneName)&#10;        {&#10;            // Annuler les dégâts cet ennemi ne prend pas de dégâts des balles&#10;            if (health != null &amp;&amp; zoneName != &quot;Dash&quot;)&#10;            {&#10;                var healthField = typeof(EnemyHealth).GetField(&quot;currentHealth&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                if (healthField != null)&#10;                {&#10;                    float currentHealth = (float)healthField.GetValue(health);&#10;                    healthField.SetValue(health, currentHealth + damage);&#10;                }&#10;            }&#10;            &#10;            // Vérifier le cooldown&#10;            if (Time.time - lastReflectTime &lt; reflectCooldown)&#10;            {&#10;                return;&#10;            }&#10;            &#10;            &#10;            // Trouver le joueur pour renvoyer le projectile&#10;            var player = FindFirstObjectByType&lt;PlayerHealth&gt;();&#10;            if (player == null) return;&#10;            &#10;            lastReflectTime = Time.time;&#10;            &#10;            // Effet visuel de réflexion&#10;            if (reflectEffectPrefab != null)&#10;            {&#10;                CreateReflectEffect(transform.position + Vector3.up * 1.5f);&#10;            }&#10;            &#10;            // Choisir le mode de réflexion&#10;            if (useHitscanReflect)&#10;            {&#10;                // Hitscan&#10;                ReflectHitscan(player);&#10;            }&#10;            else&#10;            {&#10;                // Projectile&#10;                CreateMagicBullet(player.transform.position);&#10;            }&#10;        }&#10;        &#10;        // Renvoie un tir hitscan instantané vers le joueur&#10;        private void ReflectHitscan(PlayerHealth player)&#10;        {&#10;            player.TakeDamage(reflectedDamage);&#10;            &#10;            // Effet visuel de ligne/rayon entre l'ennemi et le joueur&#10;            Debug.DrawLine(transform.position + Vector3.up * 1.5f, player.transform.position, &#10;                new Color(0.8f, 0.2f, 1f), 0.1f);&#10;            &#10;            Debug.Log(&quot;[MagicEnemy] Tir hitscan instantané renvoyé vers le joueur !&quot;);&#10;        }&#10;        &#10;        // Crée un projectile magique&#10;&#10;        private void CreateMagicBullet(Vector3 targetPosition)&#10;        {&#10;            if (cachedBulletPrefab == null)&#10;            {&#10;                Debug.LogWarning(&quot;[MagicEnemy] Aucun prefab de balle magique disponible !&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Position de spawn&#10;            Vector3 spawnPosition = transform.position + Vector3.up * 1.5f;&#10;            &#10;            // Direction vers le joueur&#10;            Vector3 directionToPlayer = (targetPosition - spawnPosition).normalized;&#10;            &#10;            // Créer le projectile&#10;            GameObject magicBullet = Instantiate(&#10;                cachedBulletPrefab,&#10;                spawnPosition,&#10;                Quaternion.LookRotation(directionToPlayer)&#10;            );&#10;            &#10;            // Configurer le projectile&#10;            var bulletScript = magicBullet.GetComponent&lt;Bullet&gt;();&#10;            if (bulletScript != null)&#10;            {&#10;                bulletScript.Initialize(reflectedDamage, reflectedBulletSpeed);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de script Bullet, utiliser directement le Rigidbody&#10;                var rb = magicBullet.GetComponent&lt;Rigidbody&gt;();&#10;                if (rb != null)&#10;                {&#10;                    rb.linearVelocity = directionToPlayer * reflectedBulletSpeed;&#10;                }&#10;            }&#10;            &#10;        }&#10;        &#10;        // Soigne le joueur&#10;        private void HealPlayer()&#10;        {&#10;            var player = FindFirstObjectByType&lt;PlayerHealth&gt;();&#10;            if (player != null)&#10;            {&#10;                player.Heal(healAmount);&#10;                Debug.Log($&quot;[MagicEnemy] Le joueur a récupéré {healAmount} PV !&quot;);&#10;                &#10;                // Créer l'effet visuel de soin sur le joueur&#10;                if (healEffectPrefab != null)&#10;                {&#10;                    CreateHealEffect(player.transform.position);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Crée un effet visuel de réflexion&#10;        private void CreateReflectEffect(Vector3 position)&#10;        {&#10;            GameObject effect = Instantiate(reflectEffectPrefab, position, Quaternion.identity);&#10;            Destroy(effect, reflectEffectDuration);&#10;        }&#10;        &#10;        // Crée un effet visuel de soin&#10;        private void CreateHealEffect(Vector3 position)&#10;        {&#10;            GameObject effect = Instantiate(healEffectPrefab, position, Quaternion.identity);&#10;            Destroy(effect, healEffectDuration);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/DashEnergyEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/DashEnergyEnemy.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.AI;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Ennemi spécial qui fuit le joueur et recharge l'énergie de dash quand il est tué.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(NavMeshAgent))]&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class DashEnergyEnemy : MonoBehaviour&#10;    {&#10;        [Header(&quot;Flee Settings&quot;)]&#10;        [Tooltip(&quot;Distance à partir de laquelle l'ennemi commence à fuir&quot;)]&#10;        [SerializeField] private float fleeDetectionRange = 20f;&#10;        &#10;        [Tooltip(&quot;Vitesse de fuite de l'ennemi&quot;)]&#10;        [SerializeField] private float fleeSpeed = 6f;&#10;        &#10;        [Tooltip(&quot;Distance minimale à maintenir avec le joueur&quot;)]&#10;        [SerializeField] private float minDistanceFromPlayer = 15f;&#10;        &#10;        [Tooltip(&quot;Vitesse de rotation vers la direction de fuite&quot;)]&#10;        [SerializeField] private float rotationSpeed = 8f;&#10;        &#10;        [Header(&quot;Movement Behavior&quot;)]&#10;        [Tooltip(&quot;Distance maximale de fuite par déplacement&quot;)]&#10;        [SerializeField] private float maxFleeDistance = 10f;&#10;        &#10;        [Tooltip(&quot;Temps d'attente avant de recalculer la direction de fuite&quot;)]&#10;        [SerializeField] private float fleeRecalculateInterval = 0.5f;&#10;        &#10;        [Tooltip(&quot;Vitesse de patrouille quand le joueur est loin&quot;)]&#10;        [SerializeField] private float idleSpeed = 2f;&#10;        &#10;        [Header(&quot;Patrol Settings&quot;)]&#10;        [Tooltip(&quot;Activer la patrouille aléatoire quand le joueur est loin&quot;)]&#10;        [SerializeField] private bool enableRandomPatrol = true;&#10;        &#10;        [Tooltip(&quot;Rayon de la zone de patrouille aléatoire&quot;)]&#10;        [SerializeField] private float patrolRadius = 10f;&#10;        &#10;        [Tooltip(&quot;Temps d'attente entre chaque point de patrouille&quot;)]&#10;        [SerializeField] private float patrolWaitTime = 2f;&#10;        &#10;        [Header(&quot;Dash Energy&quot;)]&#10;        [Tooltip(&quot;Quantité d'énergie de dash donnée quand tué (entre 0 et 1, 1 = charge complète)&quot;)]&#10;        [SerializeField] private float dashEnergyAmount = 1f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private LayerMask obstacleLayer;&#10;        &#10;        private NavMeshAgent agent;&#10;        private EnemyHealth enemyHealth;&#10;        private Transform player;&#10;        private float lastFleeCalculation;&#10;        private float patrolWaitTimer;&#10;        private bool isWaitingAtPatrolPoint;&#10;        &#10;        public enum FleeState&#10;        {&#10;            Idle,&#10;            Fleeing,&#10;            Patrol&#10;        }&#10;        &#10;        private FleeState currentState = FleeState.Idle;&#10;        &#10;        private void Awake()&#10;        {&#10;            agent = GetComponent&lt;NavMeshAgent&gt;();&#10;            enemyHealth = GetComponent&lt;EnemyHealth&gt;();&#10;            &#10;            // Trouver le joueur&#10;            GameObject playerObj = GameObject.FindGameObjectWithTag(&quot;Player&quot;);&#10;            if (playerObj != null)&#10;            {&#10;                player = playerObj.transform;&#10;            }&#10;            &#10;            agent.speed = idleSpeed;&#10;&#10;            // S'abonner à l'événement de mort&#10;            if (enemyHealth != null)&#10;            {&#10;                enemyHealth.OnDeath.AddListener(OnDeath);&#10;                Debug.Log($&quot;[DashEnergyEnemy] Abonné à l'événement OnDeath de {gameObject.name}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning($&quot;[DashEnergyEnemy] EnemyHealth introuvable sur {gameObject.name}!&quot;);&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (enemyHealth != null &amp;&amp; enemyHealth.IsDead) return;&#10;            if (player == null) return;&#10;            &#10;            float distanceToPlayer = Vector3.Distance(transform.position, player.position);&#10;            &#10;            // Machine à états pour le comportement de fuite&#10;            switch (currentState)&#10;            {&#10;                case FleeState.Idle:&#10;                    if (distanceToPlayer &lt;= fleeDetectionRange)&#10;                    {&#10;                        currentState = FleeState.Fleeing;&#10;                        agent.speed = fleeSpeed;&#10;                        isWaitingAtPatrolPoint = false;&#10;                    }&#10;                    else if (enableRandomPatrol &amp;&amp; !isWaitingAtPatrolPoint)&#10;                    {&#10;                        currentState = FleeState.Patrol;&#10;                    }&#10;                    break;&#10;                    &#10;                case FleeState.Fleeing:&#10;                    HandleFleeing(distanceToPlayer);&#10;                    &#10;                    if (distanceToPlayer &gt; fleeDetectionRange * 1.5f)&#10;                    {&#10;                        currentState = FleeState.Idle;&#10;                        agent.speed = idleSpeed;&#10;                    }&#10;                    break;&#10;                    &#10;                case FleeState.Patrol:&#10;                    HandlePatrol(distanceToPlayer);&#10;                    &#10;                    if (distanceToPlayer &lt;= fleeDetectionRange)&#10;                    {&#10;                        currentState = FleeState.Fleeing;&#10;                        agent.speed = fleeSpeed;&#10;                        isWaitingAtPatrolPoint = false;&#10;                    }&#10;                    break;&#10;            }&#10;        }&#10;        &#10;        private void HandleFleeing(float distanceToPlayer)&#10;        {&#10;            // Recalculer la direction de fuite à intervalles réguliers&#10;            if (Time.time - lastFleeCalculation &gt;= fleeRecalculateInterval)&#10;            {&#10;                CalculateFleeDestination();&#10;                lastFleeCalculation = Time.time;&#10;            }&#10;            &#10;            // Rotation vers la direction de fuite&#10;            if (agent.hasPath &amp;&amp; agent.velocity.sqrMagnitude &gt; 0.1f)&#10;            {&#10;                Vector3 fleeDirection = agent.velocity.normalized;&#10;                Quaternion lookRotation = Quaternion.LookRotation(new Vector3(fleeDirection.x, 0, fleeDirection.z));&#10;                transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);&#10;            }&#10;        }&#10;        &#10;        private void CalculateFleeDestination()&#10;        {&#10;            if (player == null) return;&#10;            &#10;            // Direction opposée au joueur&#10;            Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;&#10;            &#10;            // Calculer une position de fuite&#10;            Vector3 fleePosition = transform.position + directionAwayFromPlayer * maxFleeDistance;&#10;            &#10;            // Vérifier si la position est valide sur le NavMesh&#10;            NavMeshHit hit;&#10;            if (NavMesh.SamplePosition(fleePosition, out hit, maxFleeDistance, NavMesh.AllAreas))&#10;            {&#10;                agent.SetDestination(hit.position);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de position valide, essayer une position aléatoire loin du joueur&#10;                for (int i = 0; i &lt; 8; i++)&#10;                {&#10;                    Vector3 randomDirection = Random.insideUnitSphere * maxFleeDistance;&#10;                    randomDirection.y = 0;&#10;                    Vector3 randomFleePos = transform.position + directionAwayFromPlayer * maxFleeDistance * 0.5f + randomDirection;&#10;                    &#10;                    if (NavMesh.SamplePosition(randomFleePos, out hit, maxFleeDistance, NavMesh.AllAreas))&#10;                    {&#10;                        float distToPlayer = Vector3.Distance(hit.position, player.position);&#10;                        if (distToPlayer &gt; Vector3.Distance(transform.position, player.position))&#10;                        {&#10;                            agent.SetDestination(hit.position);&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void HandlePatrol(float distanceToPlayer)&#10;        {&#10;            if (isWaitingAtPatrolPoint)&#10;            {&#10;                patrolWaitTimer += Time.deltaTime;&#10;                if (patrolWaitTimer &gt;= patrolWaitTime)&#10;                {&#10;                    isWaitingAtPatrolPoint = false;&#10;                    patrolWaitTimer = 0f;&#10;                }&#10;                return;&#10;            }&#10;            &#10;            // Si on a atteint la destination ou qu'on n'a pas de destination&#10;            if (!agent.hasPath || agent.remainingDistance &lt;= agent.stoppingDistance)&#10;            {&#10;                SetRandomPatrolDestination();&#10;                isWaitingAtPatrolPoint = true;&#10;            }&#10;        }&#10;        &#10;        private void SetRandomPatrolDestination()&#10;        {&#10;            Vector3 randomDirection = Random.insideUnitSphere * patrolRadius;&#10;            randomDirection += transform.position;&#10;            randomDirection.y = transform.position.y;&#10;            &#10;            NavMeshHit hit;&#10;            if (NavMesh.SamplePosition(randomDirection, out hit, patrolRadius, NavMesh.AllAreas))&#10;            {&#10;                agent.SetDestination(hit.position);&#10;                agent.speed = idleSpeed;&#10;            }&#10;        }&#10;        &#10;        private void OnDeath()&#10;        {&#10;            Debug.Log($&quot;[DashEnergyEnemy] OnDeath appelé! Énergie donnée: {dashEnergyAmount}&quot;);&#10;&#10;            // Notifier le système de dash que cet ennemi a été tué&#10;            PillarDashSystem dashSystem = FindFirstObjectByType&lt;PillarDashSystem&gt;();&#10;            if (dashSystem != null)&#10;            {&#10;                Debug.Log($&quot;[DashEnergyEnemy] PillarDashSystem trouvé, appel de OnDashEnemyKilled&quot;);&#10;                dashSystem.OnDashEnemyKilled(dashEnergyAmount);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;[DashEnergyEnemy] PillarDashSystem introuvable dans la scène!&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Visualiser la portée de détection&#10;            Gizmos.color = Color.yellow;&#10;            Gizmos.DrawWireSphere(transform.position, fleeDetectionRange);&#10;            &#10;            // Visualiser la distance minimale&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, minDistanceFromPlayer);&#10;            &#10;            // Visualiser le rayon de patrouille&#10;            if (enableRandomPatrol)&#10;            {&#10;                Gizmos.color = Color.cyan;&#10;                Gizmos.DrawWireSphere(transform.position, patrolRadius);&#10;            }&#10;            &#10;            // Visualiser la direction de fuite&#10;            if (Application.isPlaying &amp;&amp; player != null)&#10;            {&#10;                Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;&#10;                Gizmos.color = Color.green;&#10;                Gizmos.DrawRay(transform.position, directionAwayFromPlayer * 5f);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.AI;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Ennemi spécial qui fuit le joueur et recharge l'énergie de dash quand il est tué.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(NavMeshAgent))]&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class DashEnergyEnemy : MonoBehaviour&#10;    {&#10;        [Header(&quot;Flee Settings&quot;)]&#10;        [Tooltip(&quot;Distance à partir de laquelle l'ennemi commence à fuir&quot;)]&#10;        [SerializeField] private float fleeDetectionRange = 20f;&#10;        &#10;        [Tooltip(&quot;Vitesse de fuite de l'ennemi&quot;)]&#10;        [SerializeField] private float fleeSpeed = 6f;&#10;        &#10;        [Tooltip(&quot;Distance minimale à maintenir avec le joueur&quot;)]&#10;        [SerializeField] private float minDistanceFromPlayer = 15f;&#10;        &#10;        [Tooltip(&quot;Vitesse de rotation vers la direction de fuite&quot;)]&#10;        [SerializeField] private float rotationSpeed = 8f;&#10;        &#10;        [Header(&quot;Movement Behavior&quot;)]&#10;        [Tooltip(&quot;Distance maximale de fuite par déplacement&quot;)]&#10;        [SerializeField] private float maxFleeDistance = 10f;&#10;        &#10;        [Tooltip(&quot;Temps d'attente avant de recalculer la direction de fuite&quot;)]&#10;        [SerializeField] private float fleeRecalculateInterval = 0.5f;&#10;        &#10;        [Tooltip(&quot;Vitesse de patrouille quand le joueur est loin&quot;)]&#10;        [SerializeField] private float idleSpeed = 2f;&#10;        &#10;        [Header(&quot;Patrol Settings&quot;)]&#10;        [Tooltip(&quot;Activer la patrouille aléatoire quand le joueur est loin&quot;)]&#10;        [SerializeField] private bool enableRandomPatrol = true;&#10;        &#10;        [Tooltip(&quot;Rayon de la zone de patrouille aléatoire&quot;)]&#10;        [SerializeField] private float patrolRadius = 10f;&#10;        &#10;        [Tooltip(&quot;Temps d'attente entre chaque point de patrouille&quot;)]&#10;        [SerializeField] private float patrolWaitTime = 2f;&#10;        &#10;        [Header(&quot;Dash Energy&quot;)]&#10;        [Tooltip(&quot;Quantité d'énergie de dash donnée quand tué (entre 0 et 1, 1 = charge complète)&quot;)]&#10;        [SerializeField] private float dashEnergyAmount = 1f;&#10;        &#10;        public float DashEnergyAmount =&gt; dashEnergyAmount;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private LayerMask obstacleLayer;&#10;        &#10;        private NavMeshAgent agent;&#10;        private EnemyHealth enemyHealth;&#10;        private Transform player;&#10;        private float lastFleeCalculation;&#10;        private float patrolWaitTimer;&#10;        private bool isWaitingAtPatrolPoint;&#10;        &#10;        public enum FleeState&#10;        {&#10;            Idle,&#10;            Fleeing,&#10;            Patrol&#10;        }&#10;        &#10;        private FleeState currentState = FleeState.Idle;&#10;        &#10;        private void Awake()&#10;        {&#10;            agent = GetComponent&lt;NavMeshAgent&gt;();&#10;            enemyHealth = GetComponent&lt;EnemyHealth&gt;();&#10;            &#10;            // Trouver le joueur&#10;            GameObject playerObj = GameObject.FindGameObjectWithTag(&quot;Player&quot;);&#10;            if (playerObj != null)&#10;            {&#10;                player = playerObj.transform;&#10;            }&#10;            &#10;            agent.speed = idleSpeed;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (enemyHealth != null &amp;&amp; enemyHealth.IsDead) return;&#10;            if (player == null) return;&#10;            &#10;            float distanceToPlayer = Vector3.Distance(transform.position, player.position);&#10;            &#10;            // Machine à états pour le comportement de fuite&#10;            switch (currentState)&#10;            {&#10;                case FleeState.Idle:&#10;                    if (distanceToPlayer &lt;= fleeDetectionRange)&#10;                    {&#10;                        currentState = FleeState.Fleeing;&#10;                        agent.speed = fleeSpeed;&#10;                        isWaitingAtPatrolPoint = false;&#10;                    }&#10;                    else if (enableRandomPatrol &amp;&amp; !isWaitingAtPatrolPoint)&#10;                    {&#10;                        currentState = FleeState.Patrol;&#10;                    }&#10;                    break;&#10;                    &#10;                case FleeState.Fleeing:&#10;                    HandleFleeing(distanceToPlayer);&#10;                    &#10;                    if (distanceToPlayer &gt; fleeDetectionRange * 1.5f)&#10;                    {&#10;                        currentState = FleeState.Idle;&#10;                        agent.speed = idleSpeed;&#10;                    }&#10;                    break;&#10;                    &#10;                case FleeState.Patrol:&#10;                    HandlePatrol(distanceToPlayer);&#10;                    &#10;                    if (distanceToPlayer &lt;= fleeDetectionRange)&#10;                    {&#10;                        currentState = FleeState.Fleeing;&#10;                        agent.speed = fleeSpeed;&#10;                        isWaitingAtPatrolPoint = false;&#10;                    }&#10;                    break;&#10;            }&#10;        }&#10;        &#10;        private void HandleFleeing(float distanceToPlayer)&#10;        {&#10;            // Recalculer la direction de fuite à intervalles réguliers&#10;            if (Time.time - lastFleeCalculation &gt;= fleeRecalculateInterval)&#10;            {&#10;                CalculateFleeDestination();&#10;                lastFleeCalculation = Time.time;&#10;            }&#10;            &#10;            // Rotation vers la direction de fuite&#10;            if (agent.hasPath &amp;&amp; agent.velocity.sqrMagnitude &gt; 0.1f)&#10;            {&#10;                Vector3 fleeDirection = agent.velocity.normalized;&#10;                Quaternion lookRotation = Quaternion.LookRotation(new Vector3(fleeDirection.x, 0, fleeDirection.z));&#10;                transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * rotationSpeed);&#10;            }&#10;        }&#10;        &#10;        private void CalculateFleeDestination()&#10;        {&#10;            if (player == null) return;&#10;            &#10;            // Direction opposée au joueur&#10;            Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;&#10;            &#10;            // Calculer une position de fuite&#10;            Vector3 fleePosition = transform.position + directionAwayFromPlayer * maxFleeDistance;&#10;            &#10;            // Vérifier si la position est valide sur le NavMesh&#10;            NavMeshHit hit;&#10;            if (NavMesh.SamplePosition(fleePosition, out hit, maxFleeDistance, NavMesh.AllAreas))&#10;            {&#10;                agent.SetDestination(hit.position);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de position valide, essayer une position aléatoire loin du joueur&#10;                for (int i = 0; i &lt; 8; i++)&#10;                {&#10;                    Vector3 randomDirection = Random.insideUnitSphere * maxFleeDistance;&#10;                    randomDirection.y = 0;&#10;                    Vector3 randomFleePos = transform.position + directionAwayFromPlayer * maxFleeDistance * 0.5f + randomDirection;&#10;                    &#10;                    if (NavMesh.SamplePosition(randomFleePos, out hit, maxFleeDistance, NavMesh.AllAreas))&#10;                    {&#10;                        float distToPlayer = Vector3.Distance(hit.position, player.position);&#10;                        if (distToPlayer &gt; Vector3.Distance(transform.position, player.position))&#10;                        {&#10;                            agent.SetDestination(hit.position);&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void HandlePatrol(float distanceToPlayer)&#10;        {&#10;            if (isWaitingAtPatrolPoint)&#10;            {&#10;                patrolWaitTimer += Time.deltaTime;&#10;                if (patrolWaitTimer &gt;= patrolWaitTime)&#10;                {&#10;                    isWaitingAtPatrolPoint = false;&#10;                    patrolWaitTimer = 0f;&#10;                }&#10;                return;&#10;            }&#10;            &#10;            // Si on a atteint la destination ou qu'on n'a pas de destination&#10;            if (!agent.hasPath || agent.remainingDistance &lt;= agent.stoppingDistance)&#10;            {&#10;                SetRandomPatrolDestination();&#10;                isWaitingAtPatrolPoint = true;&#10;            }&#10;        }&#10;        &#10;        private void SetRandomPatrolDestination()&#10;        {&#10;            Vector3 randomDirection = Random.insideUnitSphere * patrolRadius;&#10;            randomDirection += transform.position;&#10;            randomDirection.y = transform.position.y;&#10;            &#10;            NavMeshHit hit;&#10;            if (NavMesh.SamplePosition(randomDirection, out hit, patrolRadius, NavMesh.AllAreas))&#10;            {&#10;                agent.SetDestination(hit.position);&#10;                agent.speed = idleSpeed;&#10;            }&#10;        }&#10;        &#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Visualiser la portée de détection&#10;            Gizmos.color = Color.yellow;&#10;            Gizmos.DrawWireSphere(transform.position, fleeDetectionRange);&#10;            &#10;            // Visualiser la distance minimale&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, minDistanceFromPlayer);&#10;            &#10;            // Visualiser le rayon de patrouille&#10;            if (enableRandomPatrol)&#10;            {&#10;                Gizmos.color = Color.cyan;&#10;                Gizmos.DrawWireSphere(transform.position, patrolRadius);&#10;            }&#10;            &#10;            // Visualiser la direction de fuite&#10;            if (Application.isPlaying &amp;&amp; player != null)&#10;            {&#10;                Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;&#10;                Gizmos.color = Color.green;&#10;                Gizmos.DrawRay(transform.position, directionAwayFromPlayer * 5f);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/EnemyHealth.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/EnemyHealth.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Gère la santé de l'ennemi avec zones de dégâts et tracking des hits.&#10;&#10;    public class EnemyHealth : MonoBehaviour&#10;    {&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Hit Tracking&quot;)]&#10;        [SerializeField] private Dictionary&lt;string, int&gt; zoneHitCount = new Dictionary&lt;string, int&gt;();&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent OnDeath;&#10;        public UnityEvent&lt;float, string&gt; OnDamageTaken;&#10;        &#10;        private bool isDead;&#10;        private WaveManager waveManager;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;        }&#10;        &#10;        private void EnsureWaveManager()&#10;        {&#10;            if (waveManager == null)&#10;            {&#10;                waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;            }&#10;        }&#10;        &#10;        // Inflige des dégâts à l'ennemi et enregistre la zone touchée.&#10;        public void TakeDamage(float damage, string zoneName)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            currentHealth -= damage;&#10;            &#10;            // Enregistrer le hit dans la zone&#10;            if (!zoneHitCount.ContainsKey(zoneName))&#10;            {&#10;                zoneHitCount[zoneName] = 0;&#10;            }&#10;            zoneHitCount[zoneName]++;&#10;            &#10;            // Déclencher l'événement de dégâts pris&#10;            OnDamageTaken?.Invoke(damage, zoneName);&#10;            &#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.RecordHit(zoneName);&#10;            }&#10;            &#10;            // Déclencher l'effet électrique si c'est un ennemi électrique mais seulement si les dégâts ne viennent pas déjà d'une décharge électrique&#10;&#10;            if (zoneName != &quot;Electric&quot;)&#10;            {&#10;                var electricEnemy = GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electricEnemy != null)&#10;                {&#10;                    electricEnemy.TriggerElectricDischarge();&#10;                }&#10;            }&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            if (isDead) return;&#10;            &#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            &#10;            // Notifier le wave manager qu'un ennemi est mort&#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.OnEnemyDeath(this);&#10;            }&#10;            &#10;            Destroy(gameObject);&#10;        }&#10;        &#10;&#10;        // Applique des armures&#10;&#10;        public void ApplyArmorToZones(List&lt;string&gt; zoneNames)&#10;        {&#10;            var levels = new Dictionary&lt;string, int&gt;();&#10;            foreach (var z in zoneNames)&#10;            {&#10;                levels[z] = 1;&#10;            }&#10;            ApplyArmorLevels(levels);&#10;        }&#10;        &#10;&#10;        // Applique des niveaux d'armure par zone&#10;&#10;        public void ApplyArmorLevels(Dictionary&lt;string, int&gt; zoneLevels)&#10;        {&#10;            HitZone[] hitZones = GetComponentsInChildren&lt;HitZone&gt;();&#10;            foreach (HitZone zone in hitZones)&#10;            {&#10;                string key = NormalizeZoneKey(zone.ZoneName);&#10;                if (zoneLevels != null &amp;&amp; zoneLevels.TryGetValue(key, out int level))&#10;                {&#10;                    zone.SetArmorLevel(level);&#10;                }&#10;                else&#10;                {&#10;                    zone.RemoveArmor();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private static string NormalizeZoneKey(string zone)&#10;        {&#10;            return string.IsNullOrWhiteSpace(zone) ? string.Empty : zone.Trim().ToLowerInvariant();&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public Dictionary&lt;string, int&gt; ZoneHitCount =&gt; zoneHitCount;&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            TakeDamage(damage, &quot;Body&quot;);&#10;        }&#10;        &#10;&#10;        // Tue immédiatement cet ennemi sans enregistrer de hit&#10;&#10;        public void KillImmediate()&#10;        {&#10;            if (isDead) return;&#10;            currentHealth = 0f;&#10;            Die();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Gère la santé de l'ennemi avec zones de dégâts et tracking des hits.&#10;&#10;    public class EnemyHealth : MonoBehaviour&#10;    {&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Hit Tracking&quot;)]&#10;        private Dictionary&lt;string, int&gt; zoneHitCount = new Dictionary&lt;string, int&gt;();&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent OnDeath;&#10;        public UnityEvent&lt;float, string&gt; OnDamageTaken;&#10;        &#10;        [Header(&quot;Dash Tracking&quot;)]&#10;        [SerializeField] private bool killedByDash = false;&#10;        &#10;        private bool isDead;&#10;        private WaveManager waveManager;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;        }&#10;        &#10;        private void EnsureWaveManager()&#10;        {&#10;            if (waveManager == null)&#10;            {&#10;                waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;            }&#10;        }&#10;        &#10;        private void EnsureDashSystem()&#10;        {&#10;            if (dashSystem == null)&#10;            {&#10;                dashSystem = FindFirstObjectByType&lt;PillarDashSystem&gt;();&#10;            }&#10;        }&#10;        &#10;        // Inflige des dégâts à l'ennemi et enregistre la zone touchée.&#10;        public void TakeDamage(float damage, string zoneName)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            // Détecter si les dégâts viennent d'un dash&#10;            bool isDashDamage = zoneName == &quot;Dash&quot;;&#10;            &#10;            currentHealth -= damage;&#10;            &#10;            // Enregistrer le hit dans la zone&#10;            if (!zoneHitCount.ContainsKey(zoneName))&#10;            {&#10;                zoneHitCount[zoneName] = 0;&#10;            }&#10;            zoneHitCount[zoneName]++;&#10;            &#10;            // Déclencher l'événement de dégâts pris&#10;            OnDamageTaken?.Invoke(damage, zoneName);&#10;            &#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.RecordHit(zoneName);&#10;            }&#10;            &#10;            // Si c'est un dash et l'ennemi va mourir, gérer l'effet électrique et les collisions&#10;            if (isDashDamage &amp;&amp; currentHealth &lt;= 0)&#10;            {&#10;                killedByDash = true;&#10;                &#10;                // Vérifier si c'est un ennemi électrique avant de mourir&#10;                var electricEnemy = GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electricEnemy != null)&#10;                {&#10;                    // Appliquer le stun au joueur via le dash system&#10;                    EnsureDashSystem();&#10;                    if (dashSystem != null)&#10;                    {&#10;                        var player = dashSystem.gameObject;&#10;                        var playerStun = player.GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null)&#10;                        {&#10;                            playerStun = player.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        }&#10;                        &#10;                        if (electricEnemy.OverrideAutoFireInterval)&#10;                        {&#10;                            playerStun.ApplyStun(electricEnemy.StunDuration, electricEnemy.StunAutoFireInterval);&#10;                        }&#10;                        else&#10;                        {&#10;                            playerStun.ApplyStun(electricEnemy.StunDuration);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Désactiver les collisions immédiatement pour permettre le dash à travers&#10;                DisableCollisions();&#10;            }&#10;            &#10;            // Déclencher l'effet électrique si c'est un ennemi électrique mais seulement si les dégâts ne viennent pas déjà d'une décharge électrique&#10;            if (zoneName != &quot;Electric&quot; &amp;&amp; zoneName != &quot;Dash&quot;)&#10;            {&#10;                var electricEnemy = GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electricEnemy != null)&#10;                {&#10;                    electricEnemy.TriggerElectricDischarge();&#10;                }&#10;            }&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            if (isDead) return;&#10;            &#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            &#10;            // Notifier le wave manager qu'un ennemi est mort&#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.OnEnemyDeath(this);&#10;            }&#10;            &#10;            // Si c'est un DashEnergyEnemy, recharger le dash du joueur&#10;            var dashEnergyEnemy = GetComponent&lt;DashEnergyEnemy&gt;();&#10;            if (dashEnergyEnemy != null)&#10;            {&#10;                EnsureDashSystem();&#10;                if (dashSystem != null)&#10;                {&#10;                    float energyAmount = dashEnergyEnemy.DashEnergyAmount;&#10;                    dashSystem.OnDashEnemyKilled(energyAmount);&#10;                    Debug.Log($&quot;[EnemyHealth] DashEnergyEnemy tué, recharge du dash: {energyAmount}&quot;);&#10;                }&#10;            }&#10;            &#10;            Destroy(gameObject);&#10;        }&#10;        &#10;&#10;        // Applique des armures&#10;&#10;        public void ApplyArmorToZones(List&lt;string&gt; zoneNames)&#10;        {&#10;            var levels = new Dictionary&lt;string, int&gt;();&#10;            foreach (var z in zoneNames)&#10;            {&#10;                levels[z] = 1;&#10;            }&#10;            ApplyArmorLevels(levels);&#10;        }&#10;        &#10;&#10;        // Applique des niveaux d'armure par zone&#10;&#10;        public void ApplyArmorLevels(Dictionary&lt;string, int&gt; zoneLevels)&#10;        {&#10;            HitZone[] hitZones = GetComponentsInChildren&lt;HitZone&gt;();&#10;            foreach (HitZone zone in hitZones)&#10;            {&#10;                string key = NormalizeZoneKey(zone.ZoneName);&#10;                if (zoneLevels != null &amp;&amp; zoneLevels.TryGetValue(key, out int level))&#10;                {&#10;                    zone.SetArmorLevel(level);&#10;                }&#10;                else&#10;                {&#10;                    zone.RemoveArmor();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private static string NormalizeZoneKey(string zone)&#10;        {&#10;            return string.IsNullOrWhiteSpace(zone) ? string.Empty : zone.Trim().ToLowerInvariant();&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public Dictionary&lt;string, int&gt; ZoneHitCount =&gt; zoneHitCount;&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            TakeDamage(damage, &quot;Body&quot;);&#10;        }&#10;        &#10;&#10;        // Tue immédiatement cet ennemi sans enregistrer de hit&#10;&#10;        public void KillImmediate()&#10;        {&#10;            if (isDead) return;&#10;            currentHealth = 0f;&#10;            Die();&#10;        }&#10;        &#10;        // Désactive toutes les collisions de cet ennemi pour permettre le dash de passer à travers&#10;        private void DisableCollisions()&#10;        {&#10;            Collider[] colliders = GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;            &#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody rb = GetComponent&lt;Rigidbody&gt;();&#10;            if (rb != null)&#10;            {&#10;                rb.isKinematic = true;&#10;                rb.detectCollisions = false;&#10;            }&#10;            &#10;            Rigidbody[] childRbs = GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        public bool KilledByDash =&gt; killedByDash;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/PillarDashSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/PillarDashSystem.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Système de dash directionnel&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage&#10;    public class PillarDashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;Collision Settings&quot;)]&#10;        [Tooltip(&quot;Angle maximum (en degrés) entre la direction du dash et la surface pour continuer le dash. Au-delà, le dash s'arrête.&quot;)]&#10;        [SerializeField] private float maxCollisionAngle = 45f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour les obstacles qui peuvent arrêter le dash&quot;)]&#10;        [SerializeField] private LayerMask obstacleMask = ~0;&#10;        &#10;        [Tooltip(&quot;Distance de détection des obstacles devant le joueur&quot;)]&#10;        [SerializeField] private float obstacleCheckDistance = 0.5f;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [Tooltip(&quot;Conserver l'énergie cinétique à la sortie du dash&quot;)]&#10;        [SerializeField] private bool conserveMomentum = true;&#10;        &#10;        [Tooltip(&quot;Pourcentage du momentum du dash à conserver (0 à 1)&quot;)]&#10;        [SerializeField] private float momentumRetention = 0.8f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        [SerializeField] private Transform cameraTransform;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false; &#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private CharacterController characterController;&#10;        &#10;        private static System.Collections.Generic.HashSet&lt;GameObject&gt; enemiesKilledByDash = new System.Collections.Generic.HashSet&lt;GameObject&gt;();&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (fpsMovement == null)&#10;            {&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            characterController = playerController.Controller;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || characterController == null) return;&#10;&#10;            // Vérifier les obstacles devant le joueur&#10;            if (CheckObstacleCollision())&#10;            {&#10;                EndDash();&#10;                return;&#10;            }&#10;            &#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Si c'est un ennemi électrique -&gt; stun le joueur (auto-fire)&#10;                    var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                    if (electric != null)&#10;                    {&#10;                        var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (electric.OverrideAutoFireInterval)&#10;                            playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                        else&#10;                            playerStun.ApplyStun(electric.StunDuration);&#10;&#10;                        // Arrêter le dash immédiatement à cause du stun électrique&#10;                        EndDash();&#10;                        return;&#10;                    }&#10;&#10;                    // Marquer comme kill par dash si le coup sera létal&#10;                    bool willDie = enemyHealth.CurrentHealth &lt;= dashDamage;&#10;                    if (willDie)&#10;                    {&#10;                        enemiesKilledByDash.Add(enemyRoot);&#10;                        StartCoroutine(CleanupEnemyTracking(enemyRoot));&#10;&#10;                        // Désactiver immédiatement les collisions pour permettre le dash à travers&#10;                        DisableEnemyCollisions(enemyRoot);&#10;                    }&#10;&#10;                    // Appliquer dégâts&#10;                    enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            characterController.Move(dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;            &#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Mettre la vitesse de mouvement au maximum&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;            }&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;        // Vérifie si le dash doit être arrêté par une collision avec un obstacle à mauvais angle&#10;        private bool CheckObstacleCollision()&#10;        {&#10;            // Raycast dans la direction du dash pour détecter les obstacles&#10;            RaycastHit hit;&#10;            float checkDistance = obstacleCheckDistance;&#10;            &#10;            // SphereCast pour détecter les obstacles devant le joueur avec un rayon similaire au dashHitRadius&#10;            if (Physics.SphereCast(&#10;                transform.position,&#10;                dashHitRadius * 0.8f, // Légèrement plus petit pour éviter les faux positifs&#10;                directionalDashDir,&#10;                out hit,&#10;                checkDistance,&#10;                obstacleMask,&#10;                QueryTriggerInteraction.Ignore))&#10;            {&#10;                // Ignorer si c'est un ennemi (ils sont gérés séparément)&#10;                var enemyHealth = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth != null)&#10;                {&#10;                    return false; // Ne pas arrêter le dash pour les ennemis&#10;                }&#10;                &#10;                // Calculer l'angle entre la direction du dash et la normale de la surface&#10;                float angle = Vector3.Angle(directionalDashDir, -hit.normal);&#10;                &#10;                // Debug visuel&#10;                Debug.DrawRay(hit.point, hit.normal * 2f, Color.red, 0.1f);&#10;                Debug.DrawRay(hit.point, directionalDashDir * 2f, Color.yellow, 0.1f);&#10;                &#10;                // Si l'angle est trop abrupt (surface trop perpendiculaire à la direction du dash)&#10;                if (angle &gt; maxCollisionAngle)&#10;                {&#10;                    Debug.Log($&quot;[PillarDashSystem] Dash arrêté par collision ! Angle: {angle:F1}° (max: {maxCollisionAngle}°)&quot;);&#10;                    return true; // Arrêter le dash&#10;                }&#10;            }&#10;            &#10;            return false; // Continuer le dash&#10;        }&#10;&#10;&#10;        // Désactive toutes les collisions d'un ennemi pour permettre au dash de passer à travers.&#10;        private void DisableEnemyCollisions(GameObject enemy)&#10;        {&#10;&#10;            Collider[] colliders = enemy.GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;&#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody rb = enemy.GetComponent&lt;Rigidbody&gt;();&#10;            if (rb != null)&#10;            {&#10;                rb.isKinematic = true;&#10;                rb.detectCollisions = false;&#10;            }&#10;&#10;            Rigidbody[] childRbs = enemy.GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        private System.Collections.IEnumerator CleanupEnemyTracking(GameObject enemy)&#10;        {&#10;            yield return new WaitForSeconds(2f);&#10;            if (enemy == null)&#10;            {&#10;                // L'ennemi a bien été détruit, on peut le retirer du tracking&#10;                enemiesKilledByDash.Remove(enemy);&#10;            }&#10;        }&#10;&#10;        // Vérifie si un ennemi a été tué par le dash&#10;        public static bool WasKilledByDash(GameObject enemy)&#10;        {&#10;            return enemiesKilledByDash.Contains(enemy);&#10;        }&#10;&#10;        private void EndDash()&#10;        {&#10;            // Appliquer le momentum de sortie si activé&#10;            if (conserveMomentum &amp;&amp; fpsMovement != null)&#10;            {&#10;                // Calculer le momentum basé sur la vitesse du dash&#10;                Vector3 dashMomentum = directionalDashDir * dashSpeed * momentumRetention;&#10;                fpsMovement.ApplyExternalMomentum(dashMomentum);&#10;                &#10;                Debug.Log($&quot;[PillarDashSystem] Momentum conservé: {dashMomentum.magnitude:F1} m/s dans la direction {directionalDashDir}&quot;);&#10;            }&#10;            &#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[PillarDashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Système de dash directionnel&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage&#10;    public class PillarDashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;Collision Settings&quot;)]&#10;        [Tooltip(&quot;Angle maximum (en degrés) entre la direction du dash et la surface pour continuer le dash. Au-delà, le dash s'arrête.&quot;)]&#10;        [SerializeField] private float maxCollisionAngle = 45f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour les obstacles qui peuvent arrêter le dash&quot;)]&#10;        [SerializeField] private LayerMask obstacleMask = ~0;&#10;        &#10;        [Tooltip(&quot;Distance de détection des obstacles devant le joueur&quot;)]&#10;        [SerializeField] private float obstacleCheckDistance = 0.5f;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [Tooltip(&quot;Conserver l'énergie cinétique à la sortie du dash&quot;)]&#10;        [SerializeField] private bool conserveMomentum = true;&#10;        &#10;        [Tooltip(&quot;Pourcentage du momentum du dash à conserver (0 à 1)&quot;)]&#10;        [SerializeField] private float momentumRetention = 0.8f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        [SerializeField] private Transform cameraTransform;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false; &#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private CharacterController characterController;&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (fpsMovement == null)&#10;            {&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            characterController = playerController.Controller;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || characterController == null) return;&#10;&#10;            // Vérifier les obstacles devant le joueur&#10;            if (CheckObstacleCollision())&#10;            {&#10;                EndDash();&#10;                return;&#10;            }&#10;            &#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Appliquer dégâts - EnemyHealth gère maintenant toute la logique&#10;                    enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                    &#10;                    // Si l'ennemi est mort et qu'il était électrique, arrêter le dash&#10;                    if (enemyHealth.IsDead &amp;&amp; enemyHealth.KilledByDash)&#10;                    {&#10;                        var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                        if (electric != null)&#10;                        {&#10;                            // Arrêter le dash immédiatement à cause du stun électrique&#10;                            EndDash();&#10;                            return;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            characterController.Move(dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;            &#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Mettre la vitesse de mouvement au maximum&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;            }&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;        // Vérifie si le dash doit être arrêté par une collision avec un obstacle à mauvais angle&#10;        private bool CheckObstacleCollision()&#10;        {&#10;            // Raycast dans la direction du dash pour détecter les obstacles&#10;            RaycastHit hit;&#10;            float checkDistance = obstacleCheckDistance;&#10;            &#10;            // SphereCast pour détecter les obstacles devant le joueur avec un rayon similaire au dashHitRadius&#10;            if (Physics.SphereCast(&#10;                transform.position,&#10;                dashHitRadius * 0.8f, // Légèrement plus petit pour éviter les faux positifs&#10;                directionalDashDir,&#10;                out hit,&#10;                checkDistance,&#10;                obstacleMask,&#10;                QueryTriggerInteraction.Ignore))&#10;            {&#10;                // Ignorer si c'est un ennemi (ils sont gérés séparément)&#10;                var enemyHealth = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth != null)&#10;                {&#10;                    return false; // Ne pas arrêter le dash pour les ennemis&#10;                }&#10;                &#10;                // Calculer l'angle entre la direction du dash et la normale de la surface&#10;                float angle = Vector3.Angle(directionalDashDir, -hit.normal);&#10;                &#10;                // Debug visuel&#10;                Debug.DrawRay(hit.point, hit.normal * 2f, Color.red, 0.1f);&#10;                Debug.DrawRay(hit.point, directionalDashDir * 2f, Color.yellow, 0.1f);&#10;                &#10;                // Si l'angle est trop abrupt (surface trop perpendiculaire à la direction du dash)&#10;                if (angle &gt; maxCollisionAngle)&#10;                {&#10;                    Debug.Log($&quot;[PillarDashSystem] Dash arrêté par collision ! Angle: {angle:F1}° (max: {maxCollisionAngle}°)&quot;);&#10;                    return true; // Arrêter le dash&#10;                }&#10;            }&#10;            &#10;            return false; // Continuer le dash&#10;        }&#10;&#10;        &#10;        private void EndDash()&#10;        {&#10;            // Appliquer le momentum de sortie si activé&#10;            if (conserveMomentum &amp;&amp; fpsMovement != null)&#10;            {&#10;                // Calculer le momentum basé sur la vitesse du dash&#10;                Vector3 dashMomentum = directionalDashDir * dashSpeed * momentumRetention;&#10;                fpsMovement.ApplyExternalMomentum(dashMomentum);&#10;                &#10;                Debug.Log($&quot;[PillarDashSystem] Momentum conservé: {dashMomentum.magnitude:F1} m/s dans la direction {directionalDashDir}&quot;);&#10;            }&#10;            &#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[PillarDashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/PillarSpawner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/PillarSpawner.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Système qui fait apparaître un pilier à la position d'un ennemi lorsqu'il meurt.&#10;    /// Le pilier apparaît avec une rotation aléatoire entre deux angles définis.&#10;    /// &lt;/summary&gt;&#10;    public class PillarSpawner : MonoBehaviour&#10;    {&#10;        [Header(&quot;Pillar Prefab&quot;)]&#10;        [Tooltip(&quot;Le prefab du pilier à faire apparaître&quot;)]&#10;        [SerializeField] private GameObject pillarPrefab;&#10;        &#10;        [Header(&quot;Rotation Settings&quot;)]&#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe X (inclinaison avant/arrière)&quot;)]&#10;        [SerializeField] private float minAngleX = -15f;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe X (inclinaison avant/arrière)&quot;)]&#10;        [SerializeField] private float maxAngleX = 15f;&#10;        &#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe Y (rotation horizontale)&quot;)]&#10;        [SerializeField] private float minAngleY = 0f;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe Y (rotation horizontale)&quot;)]&#10;        [SerializeField] private float maxAngleY = 360f;&#10;        &#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe Z (inclinaison gauche/droite)&quot;)]&#10;        [SerializeField] private float minAngleZ = -15f;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe Z (inclinaison gauche/droite)&quot;)]&#10;        [SerializeField] private float maxAngleZ = 15f;&#10;        &#10;        [Header(&quot;Spawn Settings&quot;)]&#10;        [Tooltip(&quot;Décalage vertical par rapport à la position de l'ennemi mort&quot;)]&#10;        [SerializeField] private Vector3 spawnOffset = Vector3.zero;&#10;        &#10;        [Header(&quot;Screen Shake Settings&quot;)]&#10;        [Tooltip(&quot;Active le screenshake lors du spawn&quot;)]&#10;        [SerializeField] private bool enableScreenShake = true;&#10;        &#10;        [Tooltip(&quot;Durée du screenshake en secondes&quot;)]&#10;        [SerializeField] private float shakeDuration = 0.3f;&#10;        &#10;        [Tooltip(&quot;Intensité du déplacement de la caméra&quot;)]&#10;        [SerializeField] private float shakePositionMagnitude = 0.2f;&#10;        &#10;        [Tooltip(&quot;Intensité de la rotation de la caméra&quot;)]&#10;        [SerializeField] private float shakeRotationMagnitude = 1.5f;&#10;        &#10;        [Header(&quot;Optional Settings&quot;)]&#10;        [Tooltip(&quot;Parent pour organiser les piliers dans la hiérarchie&quot;)]&#10;        [SerializeField] private Transform pillarsContainer;&#10;        &#10;        private void Awake()&#10;        {&#10;            // Créer automatiquement un conteneur pour les piliers si non assigné&#10;            if (pillarsContainer == null)&#10;            {&#10;                GameObject container = new GameObject(&quot;Pillars Container&quot;);&#10;                pillarsContainer = container.transform;&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // S'abonner aux événements de mort de tous les ennemis existants&#10;            RegisterExistingEnemies();&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Enregistre tous les ennemis existants dans la scène pour écouter leur mort.&#10;        /// &lt;/summary&gt;&#10;        private void RegisterExistingEnemies()&#10;        {&#10;            EnemyHealth[] enemies = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsSortMode.None);&#10;            foreach (EnemyHealth enemy in enemies)&#10;            {&#10;                RegisterEnemy(enemy);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Enregistre un ennemi spécifique pour écouter son événement de mort (seulement si tag &quot;Minion&quot;).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;enemy&quot;&gt;L'ennemi à enregistrer&lt;/param&gt;&#10;        public void RegisterEnemy(EnemyHealth enemy)&#10;        {&#10;            if (enemy == null) return;&#10;            // Ne s'intéresser qu'aux ennemis avec le tag &quot;Minion&quot;&#10;            if (!enemy.CompareTag(&quot;Minion&quot;)) return;&#10;&#10;            GameObject enemyObj = enemy.gameObject;&#10;            enemy.OnDeath.AddListener(() =&gt; OnEnemyDeath(enemy.transform.position, enemyObj));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Appelé lorsqu'un ennemi meurt. Fait apparaître un pilier à sa position (uniquement si tag &quot;Minion&quot;).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;enemyPosition&quot;&gt;La position de l'ennemi mort&lt;/param&gt;&#10;        /// &lt;param name=&quot;enemyObject&quot;&gt;Le GameObject de l'ennemi mort&lt;/param&gt;&#10;        private void OnEnemyDeath(Vector3 enemyPosition, GameObject enemyObject)&#10;        {&#10;            // Filtrage: uniquement si l'ennemi a le tag &quot;Minion&quot;&#10;            if (enemyObject == null || !enemyObject.CompareTag(&quot;Minion&quot;))&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Vérifier si l'ennemi a été tué par le dash&#10;            if (PillarDashSystem.WasKilledByDash(enemyObject))&#10;            {&#10;                Debug.Log($&quot;Ennemi tué par dash - Pas de pilier spawné&quot;);&#10;                return; // Ne pas spawner de pilier si tué par dash&#10;            }&#10;&#10;            if (pillarPrefab == null)&#10;            {&#10;                Debug.LogWarning(&quot;PillarSpawner: Aucun prefab de pilier assigné!&quot;);&#10;                return;&#10;            }&#10;&#10;            SpawnPillar(enemyPosition);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fait apparaître un pilier à la position spécifiée avec une rotation aléatoire.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;position&quot;&gt;La position où faire apparaître le pilier&lt;/param&gt;&#10;        private void SpawnPillar(Vector3 position)&#10;        {&#10;            // Calculer la position finale avec l'offset&#10;            Vector3 spawnPosition = position + spawnOffset;&#10;            &#10;            // Calculer la rotation aléatoire&#10;            Quaternion rotation = CalculateRandomRotation();&#10;            &#10;            // Instancier le pilier&#10;            Instantiate(pillarPrefab, spawnPosition, rotation, pillarsContainer);&#10;            &#10;            // Log pour debug&#10;            Debug.Log($&quot;Pilier spawné à {spawnPosition} avec rotation {rotation.eulerAngles}&quot;);&#10;            &#10;            // Appliquer le screenshake si activé&#10;            if (enableScreenShake &amp;&amp; CameraShake.Instance != null)&#10;            {&#10;                CameraShake.Instance.ShakeWithRotation(shakeDuration, shakePositionMagnitude, shakeRotationMagnitude);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Calcule une rotation aléatoire basée sur les paramètres définis.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;La rotation calculée&lt;/returns&gt;&#10;        private Quaternion CalculateRandomRotation()&#10;        {&#10;            // Rotation aléatoire sur tous les axes&#10;            float randomX = Random.Range(minAngleX, maxAngleX);&#10;            float randomY = Random.Range(minAngleY, maxAngleY);&#10;            float randomZ = Random.Range(minAngleZ, maxAngleZ);&#10;            return Quaternion.Euler(randomX, randomY, randomZ);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Permet de faire apparaître manuellement un pilier (utile pour tester ou appeler depuis d'autres scripts).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;position&quot;&gt;La position où faire apparaître le pilier&lt;/param&gt;&#10;        public void SpawnPillarManually(Vector3 position)&#10;        {&#10;            SpawnPillar(position);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Nettoie tous les piliers existants.&#10;        /// &lt;/summary&gt;&#10;        public void ClearAllPillars()&#10;        {&#10;            if (pillarsContainer != null)&#10;            {&#10;                foreach (Transform child in pillarsContainer)&#10;                {&#10;                    Destroy(child.gameObject);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Système qui fait apparaître un pilier à la position d'un ennemi lorsqu'il meurt.&#10;    /// Le pilier apparaît avec une rotation aléatoire entre deux angles définis.&#10;    /// &lt;/summary&gt;&#10;    public class PillarSpawner : MonoBehaviour&#10;    {&#10;        [Header(&quot;Pillar Prefab&quot;)]&#10;        [Tooltip(&quot;Le prefab du pilier à faire apparaître&quot;)]&#10;        [SerializeField] private GameObject pillarPrefab;&#10;        &#10;        [Header(&quot;Rotation Settings&quot;)]&#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe X (inclinaison avant/arrière)&quot;)]&#10;        [SerializeField] private float minAngleX = -15f;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe X (inclinaison avant/arrière)&quot;)]&#10;        [SerializeField] private float maxAngleX = 15f;&#10;        &#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe Y (rotation horizontale)&quot;)]&#10;        [SerializeField] private float minAngleY;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe Y (rotation horizontale)&quot;)]&#10;        [SerializeField] private float maxAngleY = 360f;&#10;        &#10;        [Tooltip(&quot;Angle minimum de rotation (en degrés) sur l'axe Z (inclinaison gauche/droite)&quot;)]&#10;        [SerializeField] private float minAngleZ = -15f;&#10;        &#10;        [Tooltip(&quot;Angle maximum de rotation (en degrés) sur l'axe Z (inclinaison gauche/droite)&quot;)]&#10;        [SerializeField] private float maxAngleZ = 15f;&#10;        &#10;        [Header(&quot;Spawn Settings&quot;)]&#10;        [Tooltip(&quot;Décalage vertical par rapport à la position de l'ennemi mort&quot;)]&#10;        [SerializeField] private Vector3 spawnOffset;&#10;        &#10;        [Header(&quot;Screen Shake Settings&quot;)]&#10;        [Tooltip(&quot;Active le screenshake lors du spawn&quot;)]&#10;        [SerializeField] private bool enableScreenShake = true;&#10;        &#10;        [Tooltip(&quot;Durée du screenshake en secondes&quot;)]&#10;        [SerializeField] private float shakeDuration = 0.3f;&#10;        &#10;        [Tooltip(&quot;Intensité du déplacement de la caméra&quot;)]&#10;        [SerializeField] private float shakePositionMagnitude = 0.2f;&#10;        &#10;        [Tooltip(&quot;Intensité de la rotation de la caméra&quot;)]&#10;        [SerializeField] private float shakeRotationMagnitude = 1.5f;&#10;        &#10;        [Header(&quot;Optional Settings&quot;)]&#10;        [Tooltip(&quot;Parent pour organiser les piliers dans la hiérarchie&quot;)]&#10;        [SerializeField] private Transform pillarsContainer;&#10;        &#10;        private void Awake()&#10;        {&#10;            // Créer automatiquement un conteneur pour les piliers si non assigné&#10;            if (pillarsContainer == null)&#10;            {&#10;                GameObject container = new GameObject(&quot;Pillars Container&quot;);&#10;                pillarsContainer = container.transform;&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // S'abonner aux événements de mort de tous les ennemis existants&#10;            RegisterExistingEnemies();&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Enregistre tous les ennemis existants dans la scène pour écouter leur mort.&#10;        /// &lt;/summary&gt;&#10;        private void RegisterExistingEnemies()&#10;        {&#10;            EnemyHealth[] enemies = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsSortMode.None);&#10;            foreach (EnemyHealth enemy in enemies)&#10;            {&#10;                RegisterEnemy(enemy);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Enregistre un ennemi spécifique pour écouter son événement de mort (seulement si tag &quot;Minion&quot;).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;enemy&quot;&gt;L'ennemi à enregistrer&lt;/param&gt;&#10;        public void RegisterEnemy(EnemyHealth enemy)&#10;        {&#10;            if (enemy == null) return;&#10;            // Ne s'intéresser qu'aux ennemis avec le tag &quot;Minion&quot;&#10;            if (!enemy.CompareTag(&quot;Minion&quot;)) return;&#10;&#10;            GameObject enemyObj = enemy.gameObject;&#10;            enemy.OnDeath.AddListener(() =&gt; OnEnemyDeath(enemy.transform.position, enemyObj));&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Appelé lorsqu'un ennemi meurt. Fait apparaître un pilier à sa position (uniquement si tag &quot;Minion&quot;).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;enemyPosition&quot;&gt;La position de l'ennemi mort&lt;/param&gt;&#10;        /// &lt;param name=&quot;enemyObject&quot;&gt;Le GameObject de l'ennemi mort&lt;/param&gt;&#10;        private void OnEnemyDeath(Vector3 enemyPosition, GameObject enemyObject)&#10;        {&#10;            // Filtrage: uniquement si l'ennemi a le tag &quot;Minion&quot;&#10;            if (enemyObject == null || !enemyObject.CompareTag(&quot;Minion&quot;))&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Vérifier si l'ennemi a été tué par le dash&#10;            var enemyHealth = enemyObject.GetComponent&lt;EnemyHealth&gt;();&#10;            if (enemyHealth != null &amp;&amp; enemyHealth.KilledByDash)&#10;            {&#10;                Debug.Log($&quot;Ennemi tué par dash - Pas de pilier spawné&quot;);&#10;                return; // Ne pas spawner de pilier si tué par dash&#10;            }&#10;&#10;            if (pillarPrefab == null)&#10;            {&#10;                Debug.LogWarning(&quot;PillarSpawner: Aucun prefab de pilier assigné!&quot;);&#10;                return;&#10;            }&#10;&#10;            SpawnPillar(enemyPosition);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fait apparaître un pilier à la position spécifiée avec une rotation aléatoire.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;position&quot;&gt;La position où faire apparaître le pilier&lt;/param&gt;&#10;        private void SpawnPillar(Vector3 position)&#10;        {&#10;            // Calculer la position finale avec l'offset&#10;            Vector3 spawnPosition = position + spawnOffset;&#10;            &#10;            // Calculer la rotation aléatoire&#10;            Quaternion rotation = CalculateRandomRotation();&#10;            &#10;            // Instancier le pilier&#10;            Instantiate(pillarPrefab, spawnPosition, rotation, pillarsContainer);&#10;            &#10;            // Log pour debug&#10;            Debug.Log($&quot;Pilier spawné à {spawnPosition} avec rotation {rotation.eulerAngles}&quot;);&#10;            &#10;            // Appliquer le screenshake si activé&#10;            if (enableScreenShake &amp;&amp; CameraShake.Instance != null)&#10;            {&#10;                CameraShake.Instance.ShakeWithRotation(shakeDuration, shakePositionMagnitude, shakeRotationMagnitude);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Calcule une rotation aléatoire basée sur les paramètres définis.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;La rotation calculée&lt;/returns&gt;&#10;        private Quaternion CalculateRandomRotation()&#10;        {&#10;            // Rotation aléatoire sur tous les axes&#10;            float randomX = Random.Range(minAngleX, maxAngleX);&#10;            float randomY = Random.Range(minAngleY, maxAngleY);&#10;            float randomZ = Random.Range(minAngleZ, maxAngleZ);&#10;            return Quaternion.Euler(randomX, randomY, randomZ);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Permet de faire apparaître manuellement un pilier (utile pour tester ou appeler depuis d'autres scripts).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;position&quot;&gt;La position où faire apparaître le pilier&lt;/param&gt;&#10;        public void SpawnPillarManually(Vector3 position)&#10;        {&#10;            SpawnPillar(position);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Nettoie tous les piliers existants.&#10;        /// &lt;/summary&gt;&#10;        public void ClearAllPillars()&#10;        {&#10;            if (pillarsContainer != null)&#10;            {&#10;                foreach (Transform child in pillarsContainer)&#10;                {&#10;                    Destroy(child.gameObject);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSCameraEffects.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSCameraEffects.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère les effets visuels de la caméra (headbob, FOV dynamique)&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Camera))]&#10;    public class FPSCameraEffects : MonoBehaviour&#10;    {&#10;        [Header(&quot;Headbob Settings&quot;)]&#10;        [SerializeField] private float bobFrequency = 1.8f;&#10;        [SerializeField] private float bobHorizontalAmplitude = 0.08f;&#10;        [SerializeField] private float bobVerticalAmplitude = 0.05f;&#10;        [SerializeField] private float bobSmoothing = 8f;&#10;&#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [SerializeField] private float defaultFOV = 60f;&#10;        [SerializeField] private float sprintFOV = 70f;&#10;        [SerializeField] private float jumpFOV = 65f;&#10;        [SerializeField] private float fovTransitionSpeed = 8f;&#10;&#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField, Tooltip(&quot;Caméra de l'arme à synchroniser avec le FOV principal&quot;)]&#10;        private Camera weaponCamera;&#10;&#10;        private Camera cam;&#10;        private Vector3 camDefaultLocalPos;&#10;        private float bobTimer;&#10;        private float targetFOV;&#10;        private bool isJumping;&#10;&#10;        private void Awake()&#10;        {&#10;            cam = GetComponent&lt;Camera&gt;();&#10;            if (cam == null)&#10;            {&#10;                cam = gameObject.AddComponent&lt;Camera&gt;();&#10;            }&#10;            &#10;            camDefaultLocalPos = transform.localPosition;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // Initialiser le FOV après que la caméra soit créée&#10;            if (cam != null)&#10;            {&#10;                targetFOV = defaultFOV;&#10;                cam.fieldOfView = defaultFOV;&#10;            }&#10;            &#10;            // Initialiser le FOV de la caméra d'arme&#10;            if (weaponCamera != null)&#10;            {&#10;                weaponCamera.fieldOfView = defaultFOV;&#10;            }&#10;        }&#10;&#10;        public void UpdateEffects(float currentSpeed, bool isGrounded, bool isSprinting, bool isMoving)&#10;        {&#10;            // Gérer le FOV selon l'état&#10;            if (!isGrounded &amp;&amp; !isJumping)&#10;            {&#10;                targetFOV = jumpFOV;&#10;                isJumping = true;&#10;            }&#10;            else if (isGrounded)&#10;            {&#10;                if (isJumping)&#10;                {&#10;                    isJumping = false;&#10;                }&#10;                &#10;                // FOV de sprint ou normal&#10;                if (isSprinting &amp;&amp; isMoving)&#10;                {&#10;                    targetFOV = sprintFOV;&#10;                }&#10;                else&#10;                {&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            // Appliquer le headbob&#10;            UpdateHeadbob(currentSpeed, isGrounded, isMoving);&#10;            &#10;            // Appliquer le FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void UpdateHeadbob(float currentSpeed, bool isGrounded, bool isMoving)&#10;        {&#10;            if (isGrounded &amp;&amp; isMoving &amp;&amp; currentSpeed &gt; 0.1f)&#10;            {&#10;                bobTimer += Time.deltaTime * bobFrequency * currentSpeed;&#10;                float bobX = Mathf.Sin(bobTimer) * bobHorizontalAmplitude;&#10;                float bobY = Mathf.Cos(bobTimer * 2f) * bobVerticalAmplitude;&#10;                Vector3 targetPos = camDefaultLocalPos + new Vector3(bobX, bobY, 0f);&#10;                transform.localPosition = Vector3.Lerp(transform.localPosition, targetPos, Time.deltaTime * bobSmoothing);&#10;            }&#10;            else&#10;            {&#10;                bobTimer = 0f;&#10;                transform.localPosition = Vector3.Lerp(transform.localPosition, camDefaultLocalPos, Time.deltaTime * bobSmoothing);&#10;            }&#10;        }&#10;&#10;        private void UpdateFOV()&#10;        {&#10;            if (cam != null)&#10;            {&#10;                cam.fieldOfView = Mathf.Lerp(cam.fieldOfView, targetFOV, Time.deltaTime * fovTransitionSpeed);&#10;                &#10;                // Synchroniser le FOV de la caméra d'arme&#10;                if (weaponCamera != null)&#10;                {&#10;                    weaponCamera.fieldOfView = cam.fieldOfView;&#10;                }&#10;            }&#10;        }&#10;&#10;        public Camera Camera =&gt; cam;&#10;        public float CurrentFOV =&gt; cam != null ? cam.fieldOfView : defaultFOV;&#10;        public float TargetFOV&#10;        {&#10;            get =&gt; targetFOV;&#10;            set =&gt; targetFOV = value;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSPlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSPlayerController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// Contrôleur principal du joueur FPS &#10;    [RequireComponent(typeof(FPSInputHandler))]&#10;    [RequireComponent(typeof(FPSMovement))]&#10;    [RequireComponent(typeof(FPSMouseLook))]&#10;    public class FPSPlayerController : MonoBehaviour&#10;    {&#10;        private FPSInputHandler inputHandler;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private FPSCameraEffects cameraEffects;&#10;&#10;        private void Awake()&#10;        {&#10;            inputHandler = GetComponent&lt;FPSInputHandler&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            &#10;            if (mouseLook.CameraTransform != null)&#10;            {&#10;                cameraEffects = mouseLook.CameraTransform.GetComponent&lt;FPSCameraEffects&gt;();&#10;                if (cameraEffects == null)&#10;                {&#10;                    cameraEffects = mouseLook.CameraTransform.gameObject.AddComponent&lt;FPSCameraEffects&gt;();&#10;                }&#10;            }&#10;            &#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            // Récupérer les inputs&#10;            Vector2 moveInput = inputHandler.MoveInput;&#10;            Vector2 lookInput = inputHandler.LookInput;&#10;            bool jump = inputHandler.JumpPressed;&#10;            bool sprint = inputHandler.SprintPressed;&#10;            bool leanLeft = inputHandler.LeanLeftPressed;&#10;            bool leanRight = inputHandler.LeanRightPressed;&#10;&#10;            // Si le joueur est stun, neutraliser déplacement et actions mais laisser la caméra&#10;            var stun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (stun != null &amp;&amp; stun.IsStunned)&#10;            {&#10;                moveInput = Vector2.zero;&#10;                jump = false;&#10;                sprint = false;&#10;                leanLeft = false;&#10;                leanRight = false;&#10;            }&#10;&#10;            // Appliquer le mouvement&#10;            movement.Move(moveInput, sprint, jump);&#10;            &#10;            // Consommer le jump après utilisation&#10;            if (jump)&#10;            {&#10;                inputHandler.ConsumeJump();&#10;            }&#10;            &#10;            mouseLook.Look(lookInput, moveInput, leanLeft, leanRight);&#10;            &#10;            if (cameraEffects != null)&#10;            {&#10;                cameraEffects.UpdateEffects(&#10;                    movement.IsGrounded,&#10;                    movement.IsMoving,&#10;                    movement.CurrentSpeed,&#10;                    moveInput,&#10;                    sprint&#10;                );&#10;            }&#10;        }&#10;&#10;        // Propriétés publiques pour compatibilité avec les autres systèmes&#10;        public Transform CameraTransform =&gt; mouseLook.CameraTransform;&#10;        public CharacterController Controller =&gt; movement.Controller;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// Contrôleur principal du joueur FPS &#10;    [RequireComponent(typeof(FPSInputHandler))]&#10;    [RequireComponent(typeof(FPSMovement))]&#10;    [RequireComponent(typeof(FPSMouseLook))]&#10;    public class FPSPlayerController : MonoBehaviour&#10;    {&#10;        private FPSInputHandler inputHandler;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private FPSCameraEffects cameraEffects;&#10;&#10;        private void Awake()&#10;        {&#10;            inputHandler = GetComponent&lt;FPSInputHandler&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            &#10;            if (mouseLook.CameraTransform != null)&#10;            {&#10;                cameraEffects = mouseLook.CameraTransform.GetComponent&lt;FPSCameraEffects&gt;();&#10;                if (cameraEffects == null)&#10;                {&#10;                    cameraEffects = mouseLook.CameraTransform.gameObject.AddComponent&lt;FPSCameraEffects&gt;();&#10;                }&#10;            }&#10;            &#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            // Récupérer les inputs&#10;            Vector2 moveInput = inputHandler.MoveInput;&#10;            Vector2 lookInput = inputHandler.LookInput;&#10;            bool jump = inputHandler.JumpPressed;&#10;            bool sprint = inputHandler.SprintPressed;&#10;            bool leanLeft = inputHandler.LeanLeftPressed;&#10;            bool leanRight = inputHandler.LeanRightPressed;&#10;&#10;            // Si le joueur est stun, neutraliser déplacement et actions mais laisser la caméra&#10;            var stun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (stun != null &amp;&amp; stun.IsStunned)&#10;            {&#10;                moveInput = Vector2.zero;&#10;                jump = false;&#10;                sprint = false;&#10;                leanLeft = false;&#10;                leanRight = false;&#10;            }&#10;&#10;            // Appliquer le mouvement&#10;            movement.Move(moveInput, sprint, jump);&#10;            &#10;            // Consommer le jump après utilisation&#10;            if (jump)&#10;            {&#10;                inputHandler.ConsumeJump();&#10;            }&#10;            &#10;            mouseLook.Look(lookInput, moveInput, leanLeft, leanRight);&#10;            &#10;            if (cameraEffects != null)&#10;            {&#10;                cameraEffects.UpdateEffects(&#10;                    movement.CurrentSpeed,&#10;                    movement.IsGrounded,&#10;                    sprint,&#10;                    movement.IsMoving&#10;                );&#10;            }&#10;        }&#10;&#10;        // Propriétés publiques pour compatibilité avec les autres systèmes&#10;        public Transform CameraTransform =&gt; mouseLook.CameraTransform;&#10;        public CharacterController Controller =&gt; movement.Controller;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; Time.time &lt; 0.5f) // Fenêtre de 0.5s après le dash&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * currentSlideSpeed * Time.deltaTime;&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed * 0.6f);&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; dashSystem.isDashing)&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * (currentSlideSpeed * Time.deltaTime);&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * (currentSlideSpeed * 0.6f));&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_QUICKSTART.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_QUICKSTART.md" />
              <option name="updatedContent" value="# Slide System - Quick Start&#10;&#10;## Installation Rapide&#10;Le composant `Slide` est déjà configuré et prêt à l'emploi !&#10;&#10;## Contrôles&#10;- **Ctrl gauche** = Slider&#10;&#10;## Comment l'utiliser ?&#10;&#10;### Slide Basique&#10;1. Courez avec **WASD**&#10;2. Maintenez **Ctrl** pour slider&#10;3. Relâchez **Ctrl** pour vous relever&#10;&#10;### Combo Dash → Slide (Recommandé !)&#10;1. **Clic droit** pour dasher&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash = vitesse maximale !&#10;4. Vous pouvez traverser de très grandes distances&#10;&#10;### Astuces&#10;- Plus vous allez vite, plus le slide est long&#10;- Le slide décélère progressivement&#10;- Cooldown de 0.5s entre chaque slide&#10;- Maximum 2 secondes de slide&#10;- Ne fonctionne qu'au sol&#10;&#10;## Effets Visuels&#10;- Votre personnage s'abaisse&#10;- La caméra s'incline légèrement (5°)&#10;- Transitions fluides et smooth&#10;&#10;## Paramètres Clés (Inspector)&#10;- **Slide Speed** : 12 (vitesse de base)&#10;- **Speed Multiplier** : 1.3 (multiplie votre vitesse actuelle)&#10;- **Dash Momentum Multiplier** : 1.5 (après un dash)&#10;&#10;## C'est tout !&#10;Le système fonctionne automatiquement avec :&#10;- ✅ Le dash (synergie parfaite)&#10;- ✅ Le sprint&#10;- ✅ Le système de stun&#10;- ✅ Le saut (arrête le slide)&#10;&#10;Amusez-vous à enchaîner les combos de mouvement !&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md" />
              <option name="updatedContent" value="# Guide du Système de Slide&#10;&#10;## Vue d'ensemble&#10;Le système de slide permet au joueur de glisser au sol avec la touche **Ctrl** pour un gameplay dynamique et fluide. Il est conçu pour fonctionner en parfaite synergie avec le système de dash et le mouvement.&#10;&#10;## Contrôles&#10;- **Ctrl gauche** : Maintenir pour slider&#10;- Le slide suit la direction de votre mouvement (WASD) ou la direction de la caméra si vous ne bougez pas&#10;&#10;## Fonctionnalités Principales&#10;&#10;### 1. Démarrage du Slide&#10;- Appuyez sur **Ctrl** pendant que vous êtes au sol&#10;- Nécessite une vitesse minimale (configurable)&#10;- Le slide hérite de votre vitesse actuelle et la multiplie&#10;&#10;### 2. Synergie avec le Dash&#10;- Si vous slidez juste après un dash, le momentum est conservé et amplifié&#10;- Le multiplicateur de dash momentum permet des combos spectaculaires&#10;- Parfait pour enchaîner dash → slide pour traverser de grandes distances&#10;&#10;### 3. Physique du Slide&#10;- **Décélération progressive** : Le slide ralentit naturellement&#10;- **Vitesse minimale** : Le slide s'arrête si vous devenez trop lent&#10;- **Durée maximale** : 2 secondes par défaut pour équilibrer le gameplay&#10;- **Cooldown** : 0.5s entre chaque slide&#10;&#10;### 4. Effets Visuels&#10;- **Hauteur réduite** : Le CharacterController s'abaisse pendant le slide&#10;- **Inclinaison de caméra** : 5° d'inclinaison pour un effet dynamique&#10;- **Transitions smooth** : Toutes les transitions sont interpolées&#10;&#10;## Paramètres Configurables (Inspector)&#10;&#10;### Slide Settings&#10;- **Slide Speed** (12) : Vitesse de base du slide&#10;- **Speed Multiplier** (1.3) : Multiplie votre vitesse actuelle&#10;- **Slide Deceleration** (5) : Vitesse de ralentissement&#10;- **Min Slide Speed** (3) : Vitesse minimale pour continuer&#10;- **Max Slide Duration** (2) : Durée maximale en secondes&#10;- **Slide Cooldown** (0.5) : Temps entre chaque slide&#10;&#10;### Height Settings&#10;- **Slide Height** (1) : Hauteur du controller pendant le slide&#10;- **Height Transition Speed** (10) : Vitesse de transition de hauteur&#10;&#10;### Camera Settings&#10;- **Camera Tilt** (5) : Inclinaison en degrés&#10;- **Tilt Transition Speed** (8) : Vitesse de transition de l'inclinaison&#10;&#10;### Momentum Settings&#10;- **Inherit Dash Momentum** (true) : Hériter du momentum du dash&#10;- **Dash Momentum Multiplier** (1.5) : Multiplicateur du momentum hérité&#10;&#10;## Utilisation dans Unity&#10;&#10;### Configuration du Joueur&#10;1. Ajoutez le composant `Slide` à votre GameObject joueur&#10;2. Assurez-vous que les composants suivants sont présents :&#10;   - `CharacterController`&#10;   - `FPSMovement`&#10;   - `FPSMouseLook`&#10;   - `FPSInputHandler`&#10;   - `PillarDashSystem` (optionnel, pour la synergie)&#10;&#10;### Intégration dans le Code&#10;```csharp&#10;// Vérifier si le joueur peut slider&#10;Slide slideComponent = GetComponent&lt;Slide&gt;();&#10;if (slideComponent.CanSlide())&#10;{&#10;    // Le joueur peut slider&#10;}&#10;&#10;// Vérifier si le joueur est en train de slider&#10;if (slideComponent.IsSliding)&#10;{&#10;    // Le joueur slide actuellement&#10;}&#10;```&#10;&#10;## Mécaniques Avancées&#10;&#10;### Combo Dash → Slide&#10;1. Dashez avec clic droit vers un groupe d'ennemis&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash × 1.5&#10;4. Vous pouvez traverser de grandes distances à haute vitesse&#10;&#10;### Gestion du Momentum&#10;- Le slide conserve 60% du momentum à la fin pour une transition fluide&#10;- Le système `ApplyExternalMomentum()` assure une transition smooth avec le système de mouvement&#10;- Pas de téléportation ou de changement brusque de vitesse&#10;&#10;### Conditions d'Arrêt&#10;Le slide s'arrête automatiquement si :&#10;- Vous relâchez la touche **Ctrl**&#10;- La durée maximale est atteinte&#10;- Votre vitesse descend sous le minimum&#10;- Vous quittez le sol (saut ou chute)&#10;- Vous êtes stunné&#10;&#10;## Optimisation et Performance&#10;&#10;### Interpolations Smooth&#10;- Utilisation de `Mathf.Lerp` pour toutes les transitions&#10;- Évite les changements brusques qui pourraient causer du motion sickness&#10;- Les vitesses de transition sont configurables&#10;&#10;### Gestion de l'État&#10;- Le système vérifie automatiquement le stun&#10;- Intégration avec `PlayerStunAutoFire`&#10;- Désactivation automatique du slide pendant le stun&#10;&#10;## Conseils de Gameplay&#10;&#10;### Pour les Level Designers&#10;- Créez des pentes pour des slides spectaculaires&#10;- Placez des ennemis pour encourager les combos dash-slide&#10;- Utilisez le slide pour créer des shortcuts optionnels&#10;&#10;### Pour les Joueurs&#10;- Combinez sprint + slide pour une vitesse maximale&#10;- Utilisez le slide pour esquiver les projectiles&#10;- Le slide est parfait pour se repositionner rapidement&#10;- Dash → Slide → Saut = combo de mobilité ultime&#10;&#10;## Dépannage&#10;&#10;### Le slide ne démarre pas&#10;- Vérifiez que vous êtes au sol (`IsGrounded`)&#10;- Vérifiez que le cooldown est terminé&#10;- Vérifiez que vous n'êtes pas stunné&#10;- Vérifiez que vous avez une vitesse minimale&#10;&#10;### Le slide s'arrête trop vite&#10;- Augmentez `Min Slide Speed`&#10;- Réduisez `Slide Deceleration`&#10;- Augmentez `Max Slide Duration`&#10;&#10;### Transitions saccadées&#10;- Augmentez `Height Transition Speed`&#10;- Augmentez `Tilt Transition Speed`&#10;- Vérifiez que le framerate est stable&#10;&#10;## API Publique&#10;&#10;```csharp&#10;public class Slide : MonoBehaviour&#10;{&#10;    // Propriétés&#10;    public bool IsSliding { get; }  // Le joueur slide-t-il ?&#10;    &#10;    // Méthodes&#10;    public bool CanSlide();  // Le joueur peut-il slider ?&#10;}&#10;```&#10;&#10;## Notes Techniques&#10;&#10;### Synergie avec les Systèmes Existants&#10;- **FPSMovement** : Utilise `ApplyExternalMomentum()` pour le momentum&#10;- **FPSInputHandler** : Lit `MoveInput` pour la direction&#10;- **PillarDashSystem** : Vérifie `isDashing` pour hériter du momentum&#10;- **PlayerStunAutoFire** : Désactive le slide pendant le stun&#10;&#10;### Gestion de la Hauteur&#10;- Modifie dynamiquement `CharacterController.height` et `center`&#10;- Conserve les valeurs originales pour la restauration&#10;- Évite les problèmes de collision grâce aux transitions smooth&#10;&#10;### Performance&#10;- Aucun allocation mémoire pendant le slide&#10;- Utilisation optimale de `Vector3` et `Mathf`&#10;- Pas de coroutines, tout dans `Update()`&#10;&#10;## Améliorations Futures Possibles&#10;- Particules de poussière pendant le slide&#10;- Son de glissement&#10;- Trail renderer pour l'effet de vitesse&#10;- Bonus de vitesse sur certaines surfaces (glace, etc.)&#10;- Dégâts aux ennemis pendant le slide (comme le dash)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md" />
              <option name="updatedContent" value="# Résumé du Système de Slide&#10;&#10;##  Vue d'ensemble&#10;Système de slide activé avec **Ctrl** qui s'intègre parfaitement avec le dash et le système de mouvement pour créer un gameplay fluide et dynamique.&#10;&#10;## ✨ Caractéristiques Principales&#10;&#10;###  Contrôles&#10;- **Ctrl gauche (maintenu)** : Activer/maintenir le slide&#10;- Fonctionne uniquement au sol&#10;- Direction = mouvement actuel ou direction de la caméra&#10;&#10;### ⚡ Synergie avec le Dash&#10;- Hérite automatiquement du momentum du dash&#10;- Multiplicateur de 1.5x sur la vitesse du dash&#10;- Permet des combos dash → slide spectaculaires&#10;- Transition parfaitement smooth&#10;&#10;###  Physique du Slide&#10;- **Vitesse de base** : 12 unités/s&#10;- **Multiplicateur de vitesse** : 1.3x de votre vitesse actuelle&#10;- **Décélération** : 5 unités/s² (progressive et naturelle)&#10;- **Vitesse minimale** : 3 unités/s (arrêt automatique en dessous)&#10;- **Durée max** : 2 secondes&#10;- **Cooldown** : 0.5 secondes&#10;&#10;###  Effets Visuels&#10;- **Hauteur réduite** : CharacterController passe à 1 unité&#10;- **Inclinaison caméra** : 5° pour effet de vitesse&#10;- **Transitions smooth** : Interpolation Lerp sur tous les paramètres&#10;- Pas de téléportation ou changement brusque&#10;&#10;##  Architecture Technique&#10;&#10;### Composants Requis&#10;```&#10;GameObject Joueur&#10;├── CharacterController (Unity)&#10;├── FPSMovement (vitesse et momentum)&#10;├── FPSMouseLook (caméra)&#10;├── FPSInputHandler (inputs)&#10;├── PillarDashSystem (optionnel, pour synergie)&#10;└── Slide (nouveau composant) ✨&#10;```&#10;&#10;### Méthodes Publiques&#10;```csharp&#10;public bool IsSliding { get; }  // État actuel&#10;public bool CanSlide();         // Vérification de disponibilité&#10;```&#10;&#10;### Intégration avec Systèmes Existants&#10;- ✅ **FPSMovement** : `ApplyExternalMomentum()` pour momentum smooth&#10;- ✅ **PillarDashSystem** : Détection de `isDashing` pour héritage&#10;- ✅ **PlayerStunAutoFire** : Désactivation automatique pendant stun&#10;- ✅ **FPSInputHandler** : Lecture de `MoveInput` pour direction&#10;&#10;##  Conditions de Fonctionnement&#10;&#10;### Démarrage du Slide&#10;1. Joueur au sol (`IsGrounded`)&#10;2. Cooldown terminé (0.5s)&#10;3. Pas de stun actif&#10;4. Vitesse minimale atteinte OU mouvement actif&#10;5. Touche Ctrl maintenue&#10;&#10;### Arrêt du Slide&#10;- Touche Ctrl relâchée&#10;- Durée maximale atteinte (2s)&#10;- Vitesse trop faible (&lt; 3)&#10;- Joueur en l'air&#10;- Stun appliqué&#10;&#10;##  Flux de Gameplay&#10;&#10;### Combo Recommandé&#10;```&#10;1. Sprint (Shift) → Vitesse augmente&#10;2. Dash (Clic droit) → Vitesse maximale + kill ennemis&#10;3. Slide (Ctrl) → Hérite momentum × 1.5&#10;4. Transition smooth vers mouvement normal&#10;```&#10;&#10;### Gestion du Momentum&#10;```&#10;Début slide : Max(slideSpeed, currentSpeed × multiplier)&#10;Pendant slide : Décélération progressive&#10;Fin slide : Conservation de 60% du momentum&#10;→ Transition fluide sans rupture de vitesse&#10;```&#10;&#10;##  Paramètres Configurables&#10;&#10;| Paramètre | Valeur par défaut | Description |&#10;|-----------|-------------------|-------------|&#10;| Slide Speed | 12 | Vitesse de base |&#10;| Speed Multiplier | 1.3 | Multiplie vitesse actuelle |&#10;| Slide Deceleration | 5 | Ralentissement progressif |&#10;| Min Slide Speed | 3 | Seuil d'arrêt |&#10;| Max Slide Duration | 2 | Durée maximale (s) |&#10;| Slide Cooldown | 0.5 | Temps entre slides (s) |&#10;| Slide Height | 1 | Hauteur du controller |&#10;| Camera Tilt | 5 | Inclinaison (degrés) |&#10;| Dash Momentum Multiplier | 1.5 | Bonus après dash |&#10;&#10;##  Performance&#10;&#10;### Optimisations&#10;- ❌ Pas d'allocation mémoire pendant l'exécution&#10;- ❌ Pas de coroutines&#10;- ✅ Tout dans `Update()` avec early returns&#10;- ✅ Ordre de multiplication optimisé&#10;- ✅ Utilisation de propriétés cached&#10;&#10;### Garbage Collection&#10;- 0 allocation par frame&#10;- Références cached dans `Awake()`&#10;- Pas de `GetComponent()` dans `Update()`&#10;&#10;##  Documentation&#10;&#10;### Fichiers Créés&#10;- `Slide.cs` : Composant principal (280 lignes)&#10;- `SLIDE_SYSTEM_GUIDE.md` : Guide complet&#10;- `SLIDE_QUICKSTART.md` : Démarrage rapide&#10;- `SLIDE_SYSTEM_SUMMARY.md` : Ce fichier&#10;&#10;### Modifications Apportées&#10;- `FPSInputHandler.cs` : Ajout de `SprintPressed`&#10;&#10;##  Cas d'Usage&#10;&#10;### Level Design&#10;- Pentes pour slides spectaculaires&#10;- Zones de combat avec dash-slide combos&#10;- Shortcuts nécessitant maîtrise du momentum&#10;&#10;### Gameplay&#10;- Mobilité tactique en combat&#10;- Esquive de projectiles&#10;- Traversée rapide de maps&#10;- Combos de mouvement créatifs&#10;&#10;## ⚠️ Notes Importantes&#10;&#10;### Limitations&#10;- Fonctionne uniquement au sol&#10;- Pas de slide en l'air (arrêt automatique)&#10;- Cooldown impose un rythme&#10;- Durée max évite les abus&#10;&#10;### Compatibilité&#10;- Compatible avec tous les systèmes FPS existants&#10;- Pas d'impact sur les autres mécaniques&#10;- Peut être désactivé sans casser le jeu&#10;&#10;##  Extensions Possibles&#10;&#10;### Améliorations Futures&#10;- Particules de poussière/friction&#10;- Son de glissement dynamique&#10;- Trail renderer pour effet de vitesse&#10;- Surfaces spéciales (glace = moins de friction)&#10;- Dégâts aux ennemis pendant le slide&#10;- Animation du personnage&#10;- Shake de caméra proportionnel à la vitesse&#10;&#10;### API Extensible&#10;Le système est conçu pour être facilement étendu :&#10;- Méthode `CanSlide()` pour conditions custom&#10;- Events possibles (OnSlideStart, OnSlideEnd)&#10;- Paramètres exposés dans l'inspector&#10;&#10;## ✅ Status&#10;- [x] Implémentation complète&#10;- [x] Intégration avec systèmes existants&#10;- [x] Documentation complète&#10;- [x] Tests de compilation OK&#10;- [x] Optimisations appliquées&#10;- [x] Guides utilisateur créés&#10;&#10;**Le système est prêt à l'emploi !** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>