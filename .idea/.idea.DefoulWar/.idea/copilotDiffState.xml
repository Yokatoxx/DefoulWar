<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/DashCooldownUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/DashCooldownUI.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace FPS&#10;{&#10;    public class DashCooldownUI : MonoBehaviour&#10;    {&#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField, Tooltip(&quot;Référence au dash ciblé pour connaître le nombre de charges&quot;)]&#10;        private DashCible dashCible;&#10;        &#10;        [SerializeField, Tooltip(&quot;Texte optionnel pour afficher l'état des charges&quot;)]&#10;        private TMPro.TextMeshProUGUI cooldownText;&#10;        &#10;        [Header(&quot;Dash Icons&quot;)]&#10;        [SerializeField, Tooltip(&quot;Liste ordonnée des icônes représentant chaque charge&quot;)]&#10;        private List&lt;Image&gt; dashIcons = new();&#10;&#10;        [Header(&quot;Visual Settings&quot;)] [SerializeField, Tooltip(&quot;Couleur quand le dash est en cours de charge&quot;)]&#10;        private Color cooldownColor;&#10;        [SerializeField, Tooltip(&quot;Couleur quand le dash est complètement chargé&quot;)]&#10;        private Color readyColor;&#10;&#10;        [SerializeField, Tooltip(&quot;Couleur lorsqu'un slow-mo est actif&quot;)]&#10;        private Color slowMoColor;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée de l'animation de transition&quot;)]&#10;        private float transitionSpeed = 5f;&#10;        &#10;        [Header(&quot;Pulse Effect (Slow-Mo)&quot;)]&#10;        [SerializeField, Tooltip(&quot;Intensité de la pulsation pendant le slow-mo (0.1 à 0.3 recommandé)&quot;)]&#10;        [Range(0f, 0.5f)]&#10;        private float pulseIntensity = 0.15f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de la pulsation pendant le slow-mo&quot;)]&#10;        private float pulseSpeed = 4f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Afficher le texte de pourcentage&quot;)]&#10;        private bool showPercentageText = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cacher la jauge quand elle est complètement chargée&quot;)]&#10;        private bool hideWhenReady = false;&#10;&#10;        private CanvasGroup canvasGroup;&#10;        private readonly List&lt;float&gt; iconFillAmounts = new();&#10;        private readonly List&lt;Vector3&gt; iconOriginalScales = new();&#10;        private Color initialTextColor;&#10;        private bool warnedAboutSlotShortage;&#10;        private float pulseTimer;&#10;        &#10;        private void Awake()&#10;        {&#10;            canvasGroup = GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup == null)&#10;            {&#10;                canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();&#10;            }&#10;            &#10;            SyncFillBuffer();&#10;            &#10;            if (showPercentageText &amp;&amp; cooldownText == null)&#10;            {&#10;                cooldownText = GetComponentInChildren&lt;TMPro.TextMeshProUGUI&gt;();&#10;            }&#10;            &#10;            if (cooldownText != null)&#10;            {&#10;                initialTextColor = cooldownText.color;&#10;            }&#10;        }&#10;        &#10;        private void SyncFillBuffer()&#10;        {&#10;            iconFillAmounts.Clear();&#10;            iconOriginalScales.Clear();&#10;            for (int i = 0; i &lt; dashIcons.Count; i++)&#10;            {&#10;                iconFillAmounts.Add(0f);&#10;                if (dashIcons[i] != null)&#10;                    iconOriginalScales.Add(dashIcons[i].transform.localScale);&#10;                else&#10;                    iconOriginalScales.Add(Vector3.one);&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (dashCible == null || dashIcons.Count == 0) return;&#10;            if (iconFillAmounts.Count != dashIcons.Count)&#10;            {&#10;                SyncFillBuffer();&#10;            }&#10;            &#10;            int totalCharges = Mathf.Max(1, dashCible.CountDash);&#10;            int availableCharges = dashCible.IsChainActive ? Mathf.Clamp(dashCible.RemainingChains, 0, totalCharges) : totalCharges;&#10;            &#10;            bool isSlowMo = dashCible.IsSlowMoActive;&#10;            bool isCooldown = dashCible.IsCooldownActive;&#10;            float cooldownProgress = dashCible.CooldownProgress;&#10;            &#10;            UpdateDashIcons(totalCharges, availableCharges, isSlowMo, isCooldown, cooldownProgress);&#10;            UpdateCooldownText(availableCharges, totalCharges, isSlowMo, isCooldown, cooldownProgress);&#10;            UpdateVisibility(availableCharges, totalCharges);&#10;        }&#10;        &#10;        private void UpdateDashIcons(int totalCharges, int availableCharges, bool isSlowMo, bool isCooldown, float cooldownProgress)&#10;        {&#10;            int iconCap = dashIcons.Count;&#10;            if (totalCharges &gt; iconCap &amp;&amp; !warnedAboutSlotShortage)&#10;            {&#10;                Debug.LogWarning($&quot;DashCooldownUI: {name} n'a que {iconCap} icônes mais DashCible en demande {totalCharges}. Seules les premières seront utilisées.&quot;);&#10;                warnedAboutSlotShortage = true;&#10;            }&#10;            int activeIcons = Mathf.Min(totalCharges, iconCap);&#10;            &#10;            // Mise à jour du timer de pulsation (en temps non-scalé pour fonctionner pendant le slow-mo)&#10;            if (isSlowMo)&#10;            {&#10;                pulseTimer += Time.unscaledDeltaTime * pulseSpeed;&#10;            }&#10;            else&#10;            {&#10;                pulseTimer = 0f;&#10;            }&#10;        &#10;            for (int i = 0; i &lt; dashIcons.Count; i++)&#10;            {&#10;                Image icon = dashIcons[i];&#10;                if (icon == null) continue;&#10;                bool active = i &lt; activeIcons;&#10;                if (icon.gameObject.activeSelf != active)&#10;                {&#10;                    icon.gameObject.SetActive(active);&#10;                }&#10;                if (!active) continue;&#10;                &#10;                float targetFill;&#10;                Color targetColor;&#10;                float pulseScale = 1f;&#10;                &#10;                if (isSlowMo)&#10;                {&#10;                    // Pendant le slow-mo : bulles consommées vides, bulles restantes pleines et jaunes avec pulsation&#10;                    targetFill = i &lt; availableCharges ? 1f : 0f;&#10;                    targetColor = slowMoColor;&#10;                    &#10;                    // Effet de pulsation sur les bulles restantes&#10;                    if (i &lt; availableCharges)&#10;                    {&#10;                        pulseScale = 1f + Mathf.Sin(pulseTimer) * pulseIntensity;&#10;                    }&#10;                }&#10;                else if (isCooldown)&#10;                {&#10;                    // Pendant le cooldown : rechargement progressif en cascade&#10;                    // Chaque bulle se remplit l'une après l'autre&#10;                    float progressPerIcon = 1f / activeIcons;&#10;                    float iconStartProgress = i * progressPerIcon;&#10;                    float iconEndProgress = (i + 1) * progressPerIcon;&#10;                    &#10;                    // Calcul du remplissage pour cette bulle spécifique&#10;                    if (cooldownProgress &gt;= iconEndProgress)&#10;                    {&#10;                        targetFill = 1f;&#10;                    }&#10;                    else if (cooldownProgress &lt;= iconStartProgress)&#10;                    {&#10;                        targetFill = 0f;&#10;                    }&#10;                    else&#10;                    {&#10;                        // Remplissage progressif de cette bulle&#10;                        targetFill = (cooldownProgress - iconStartProgress) / progressPerIcon;&#10;                    }&#10;                    &#10;                    targetColor = targetFill &gt;= 0.999f ? readyColor : cooldownColor;&#10;                }&#10;                else&#10;                {&#10;                    // État normal : toutes les bulles sont pleines et prêtes&#10;                    targetFill = 1f;&#10;                    targetColor = readyColor;&#10;                }&#10;                &#10;                // Animation fluide du remplissage&#10;                iconFillAmounts[i] = Mathf.Lerp(iconFillAmounts[i], targetFill, Time.unscaledDeltaTime * transitionSpeed);&#10;                icon.fillAmount = iconFillAmounts[i];&#10;                icon.color = targetColor;&#10;                &#10;                // Application de l'effet de pulsation (scale)&#10;                if (i &lt; iconOriginalScales.Count)&#10;                {&#10;                    icon.transform.localScale = iconOriginalScales[i] * pulseScale;&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void UpdateCooldownText(int availableCharges, int totalCharges, bool isSlowMo, bool isCooldown, float cooldownProgress)&#10;        {&#10;            if (!showPercentageText || cooldownText == null) return;&#10;        &#10;            float percent;&#10;            if (isSlowMo)&#10;            {&#10;                // Pendant le slow-mo, afficher le pourcentage de charges restantes&#10;                percent = totalCharges &gt; 0 ? (availableCharges / (float)totalCharges) * 100f : 0f;&#10;                cooldownText.color = slowMoColor;&#10;            }&#10;            else if (isCooldown)&#10;            {&#10;                // Pendant le cooldown, afficher la progression du rechargement&#10;                percent = cooldownProgress * 100f;&#10;                cooldownText.color = cooldownColor;&#10;            }&#10;            else&#10;            {&#10;                // État normal : 100%&#10;                percent = 100f;&#10;                cooldownText.color = initialTextColor;&#10;            }&#10;            &#10;            cooldownText.text = $&quot;{Mathf.RoundToInt(percent)}%&quot;;&#10;        }&#10;        &#10;        private void UpdateVisibility(int availableCharges, int totalCharges)&#10;        {&#10;            if (!hideWhenReady)&#10;            {&#10;                canvasGroup.alpha = 1f;&#10;                return;&#10;            }&#10;        &#10;            bool allReady = availableCharges &gt;= totalCharges;&#10;            float targetAlpha = allReady ? 0f : 1f;&#10;            canvasGroup.alpha = Mathf.Lerp(canvasGroup.alpha, targetAlpha, Time.deltaTime * transitionSpeed);&#10;        }&#10;        &#10;        public void SetDashCible(DashCible cible)&#10;        {&#10;            dashCible = cible;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace FPS&#10;{&#10;    public class DashCooldownUI : MonoBehaviour&#10;    {&#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField, Tooltip(&quot;Référence au dash ciblé pour connaître le nombre de charges&quot;)]&#10;        private DashCible dashCible;&#10;        &#10;        [SerializeField, Tooltip(&quot;Texte optionnel pour afficher l'état des charges&quot;)]&#10;        private TMPro.TextMeshProUGUI cooldownText;&#10;        &#10;        [Header(&quot;Dash Icons&quot;)]&#10;        [SerializeField, Tooltip(&quot;Liste ordonnée des icônes représentant chaque charge&quot;)]&#10;        private List&lt;Image&gt; dashIcons = new();&#10;&#10;        [Header(&quot;Visual Settings&quot;)] [SerializeField, Tooltip(&quot;Couleur quand le dash est en cours de charge&quot;)]&#10;        private Color cooldownColor;&#10;        [SerializeField, Tooltip(&quot;Couleur quand le dash est complètement chargé&quot;)]&#10;        private Color readyColor;&#10;&#10;        [SerializeField, Tooltip(&quot;Couleur lorsqu'un slow-mo est actif&quot;)]&#10;        private Color slowMoColor;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée de l'animation de transition&quot;)]&#10;        private float transitionSpeed = 5f;&#10;        &#10;        [Header(&quot;Pulse Effect (Slow-Mo)&quot;)]&#10;        [SerializeField, Tooltip(&quot;Intensité de la pulsation pendant le slow-mo (0.1 à 0.3 recommandé)&quot;)]&#10;        [Range(0f, 0.5f)]&#10;        private float pulseIntensity = 0.15f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de la pulsation pendant le slow-mo&quot;)]&#10;        private float pulseSpeed = 4f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Afficher le texte de pourcentage&quot;)]&#10;        private bool showPercentageText = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cacher la jauge quand elle est complètement chargée&quot;)]&#10;        private bool hideWhenReady = false;&#10;&#10;        private CanvasGroup canvasGroup;&#10;        private readonly List&lt;float&gt; iconFillAmounts = new();&#10;        private readonly List&lt;Vector3&gt; iconOriginalScales = new();&#10;        private Color initialTextColor;&#10;        private bool warnedAboutSlotShortage;&#10;        private float pulseTimer;&#10;        private bool wasCooldownActive;&#10;        &#10;        private void Awake()&#10;        {&#10;            canvasGroup = GetComponent&lt;CanvasGroup&gt;();&#10;            if (canvasGroup == null)&#10;            {&#10;                canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();&#10;            }&#10;            &#10;            SyncFillBuffer();&#10;            &#10;            if (showPercentageText &amp;&amp; cooldownText == null)&#10;            {&#10;                cooldownText = GetComponentInChildren&lt;TMPro.TextMeshProUGUI&gt;();&#10;            }&#10;            &#10;            if (cooldownText != null)&#10;            {&#10;                initialTextColor = cooldownText.color;&#10;            }&#10;        }&#10;        &#10;        private void SyncFillBuffer()&#10;        {&#10;            iconFillAmounts.Clear();&#10;            iconOriginalScales.Clear();&#10;            for (int i = 0; i &lt; dashIcons.Count; i++)&#10;            {&#10;                iconFillAmounts.Add(0f);&#10;                if (dashIcons[i] != null)&#10;                    iconOriginalScales.Add(dashIcons[i].transform.localScale);&#10;                else&#10;                    iconOriginalScales.Add(Vector3.one);&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (dashCible == null || dashIcons.Count == 0) return;&#10;            if (iconFillAmounts.Count != dashIcons.Count)&#10;            {&#10;                SyncFillBuffer();&#10;            }&#10;            &#10;            int totalCharges = Mathf.Max(1, dashCible.CountDash);&#10;            int availableCharges = dashCible.IsChainActive ? Mathf.Clamp(dashCible.RemainingChains, 0, totalCharges) : totalCharges;&#10;            &#10;            bool isSlowMo = dashCible.IsSlowMoActive;&#10;            bool isCooldown = dashCible.IsCooldownActive;&#10;            float cooldownProgress = dashCible.CooldownProgress;&#10;            &#10;            UpdateDashIcons(totalCharges, availableCharges, isSlowMo, isCooldown, cooldownProgress);&#10;            UpdateCooldownText(availableCharges, totalCharges, isSlowMo, isCooldown, cooldownProgress);&#10;            UpdateVisibility(availableCharges, totalCharges);&#10;            &#10;            wasCooldownActive = isCooldown;&#10;        }&#10;        &#10;        private void UpdateDashIcons(int totalCharges, int availableCharges, bool isSlowMo, bool isCooldown, float cooldownProgress)&#10;        {&#10;            int iconCap = dashIcons.Count;&#10;            if (totalCharges &gt; iconCap &amp;&amp; !warnedAboutSlotShortage)&#10;            {&#10;                Debug.LogWarning($&quot;DashCooldownUI: {name} n'a que {iconCap} icônes mais DashCible en demande {totalCharges}. Seules les premières seront utilisées.&quot;);&#10;                warnedAboutSlotShortage = true;&#10;            }&#10;            int activeIcons = Mathf.Min(totalCharges, iconCap);&#10;            &#10;            // Mise à jour du timer de pulsation (en temps non-scalé pour fonctionner pendant le slow-mo)&#10;            if (isSlowMo)&#10;            {&#10;                pulseTimer += Time.unscaledDeltaTime * pulseSpeed;&#10;            }&#10;            else&#10;            {&#10;                pulseTimer = 0f;&#10;            }&#10;        &#10;            for (int i = 0; i &lt; dashIcons.Count; i++)&#10;            {&#10;                Image icon = dashIcons[i];&#10;                if (icon == null) continue;&#10;                bool active = i &lt; activeIcons;&#10;                if (icon.gameObject.activeSelf != active)&#10;                {&#10;                    icon.gameObject.SetActive(active);&#10;                }&#10;                if (!active) continue;&#10;                &#10;                float targetFill;&#10;                Color targetColor;&#10;                float pulseScale = 1f;&#10;                &#10;                if (isSlowMo)&#10;                {&#10;                    // Pendant le slow-mo : bulles consommées vides, bulles restantes pleines et jaunes avec pulsation&#10;                    targetFill = i &lt; availableCharges ? 1f : 0f;&#10;                    targetColor = slowMoColor;&#10;                    &#10;                    // Effet de pulsation sur les bulles restantes&#10;                    if (i &lt; availableCharges)&#10;                    {&#10;                        pulseScale = 1f + Mathf.Sin(pulseTimer) * pulseIntensity;&#10;                    }&#10;                }&#10;                else if (isCooldown)&#10;                {&#10;                    // Pendant le cooldown : rechargement progressif en cascade&#10;                    // Chaque bulle se remplit l'une après l'autre&#10;                    float progressPerIcon = 1f / activeIcons;&#10;                    float iconStartProgress = i * progressPerIcon;&#10;                    float iconEndProgress = (i + 1) * progressPerIcon;&#10;                    &#10;                    // Calcul du remplissage pour cette bulle spécifique&#10;                    if (cooldownProgress &gt;= iconEndProgress)&#10;                    {&#10;                        targetFill = 1f;&#10;                    }&#10;                    else if (cooldownProgress &lt;= iconStartProgress)&#10;                    {&#10;                        targetFill = 0f;&#10;                    }&#10;                    else&#10;                    {&#10;                        // Remplissage progressif de cette bulle&#10;                        targetFill = (cooldownProgress - iconStartProgress) / progressPerIcon;&#10;                    }&#10;                    &#10;                    targetColor = targetFill &gt;= 0.999f ? readyColor : cooldownColor;&#10;                }&#10;                else&#10;                {&#10;                    // État normal : toutes les bulles sont pleines et prêtes&#10;                    targetFill = 1f;&#10;                    targetColor = readyColor;&#10;                }&#10;                &#10;                // Snap instantané pendant le cooldown et à la fin du cooldown, animation fluide sinon&#10;                if (isCooldown || wasCooldownActive)&#10;                {&#10;                    iconFillAmounts[i] = targetFill;&#10;                }&#10;                else&#10;                {&#10;                    iconFillAmounts[i] = Mathf.Lerp(iconFillAmounts[i], targetFill, Time.unscaledDeltaTime * transitionSpeed);&#10;                }&#10;                icon.fillAmount = iconFillAmounts[i];&#10;                icon.color = targetColor;&#10;                &#10;                // Application de l'effet de pulsation (scale)&#10;                if (i &lt; iconOriginalScales.Count)&#10;                {&#10;                    icon.transform.localScale = iconOriginalScales[i] * pulseScale;&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void UpdateCooldownText(int availableCharges, int totalCharges, bool isSlowMo, bool isCooldown, float cooldownProgress)&#10;        {&#10;            if (!showPercentageText || cooldownText == null) return;&#10;        &#10;            float percent;&#10;            if (isSlowMo)&#10;            {&#10;                // Pendant le slow-mo, afficher le pourcentage de charges restantes&#10;                percent = totalCharges &gt; 0 ? (availableCharges / (float)totalCharges) * 100f : 0f;&#10;                cooldownText.color = slowMoColor;&#10;            }&#10;            else if (isCooldown)&#10;            {&#10;                // Pendant le cooldown, afficher la progression du rechargement&#10;                percent = cooldownProgress * 100f;&#10;                cooldownText.color = cooldownColor;&#10;            }&#10;            else&#10;            {&#10;                // État normal : 100%&#10;                percent = 100f;&#10;                cooldownText.color = initialTextColor;&#10;            }&#10;            &#10;            cooldownText.text = $&quot;{Mathf.RoundToInt(percent)}%&quot;;&#10;        }&#10;        &#10;        private void UpdateVisibility(int availableCharges, int totalCharges)&#10;        {&#10;            if (!hideWhenReady)&#10;            {&#10;                canvasGroup.alpha = 1f;&#10;                return;&#10;            }&#10;        &#10;            bool allReady = availableCharges &gt;= totalCharges;&#10;            float targetAlpha = allReady ? 0f : 1f;&#10;            canvasGroup.alpha = Mathf.Lerp(canvasGroup.alpha, targetAlpha, Time.deltaTime * transitionSpeed);&#10;        }&#10;        &#10;        public void SetDashCible(DashCible cible)&#10;        {&#10;            dashCible = cible;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/DashSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/DashSystem.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System.Runtime.CompilerServices;&#10;using FPS; // EnemyHealth&#10;namespace FPS&#10;{&#10;&#10;    // Système de dash directionnel&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage&#10;    public class DashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;Collision Settings&quot;)]&#10;        [Tooltip(&quot;Angle maximum (en degrés) entre la direction du dash et la surface pour continuer le dash. Au-delà, le dash s'arrête.&quot;)]&#10;        [SerializeField] private float maxCollisionAngle = 45f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour les obstacles qui peuvent arrêter le dash&quot;)]&#10;        [SerializeField] private LayerMask obstacleMask = ~0;&#10;        &#10;        [Tooltip(&quot;Distance de détection des obstacles devant le joueur&quot;)]&#10;        [SerializeField] private float obstacleCheckDistance = 0.5f;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [Tooltip(&quot;Conserver l'énergie cinétique à la sortie du dash&quot;)]&#10;        [SerializeField] private bool conserveMomentum = true;&#10;        &#10;        [Tooltip(&quot;Pourcentage du momentum du dash à conserver (0 à 1)&quot;)]&#10;        [SerializeField] private float momentumRetention = 0.8f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        [SerializeField] private Transform cameraTransform;&#10;        [SerializeField] private SoundPlayer sound;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false;&#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private CharacterController characterController;&#10;        &#10;        private static System.Collections.Generic.HashSet&lt;GameObject&gt; enemiesKilledByDash = new System.Collections.Generic.HashSet&lt;GameObject&gt;();&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (fpsMovement == null)&#10;            {&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            characterController = playerController.Controller;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || characterController == null) return;&#10;&#10;            // Vérifier les obstacles devant le joueur&#10;            if (CheckObstacleCollision())&#10;            {&#10;                EndDash();&#10;                return;&#10;            }&#10;            &#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Si c'est un ennemi électrique -&gt; stun le joueur (auto-fire)&#10;                    var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                    if (electric != null)&#10;                    {&#10;                        var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (electric.OverrideAutoFireInterval)&#10;                            playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                        else&#10;                            playerStun.ApplyStun(electric.StunDuration);&#10;                        &#10;                        // Arrêter le dash immédiatement à cause du stun électrique&#10;                        EndDash();&#10;                        return;&#10;                    }&#10;&#10;                    // Marquer comme kill par dash si le coup sera létal&#10;                    bool willDie = enemyHealth.CurrentHealth &lt;= dashDamage;&#10;                    if (willDie)&#10;                    {&#10;                        enemiesKilledByDash.Add(enemyRoot);&#10;                        StartCoroutine(CleanupEnemyTracking(enemyRoot));&#10;                        &#10;                        // Désactiver immédiatement les collisions pour permettre le dash à travers&#10;                        DisableEnemyCollisions(enemyRoot);&#10;                    }&#10;&#10;                    // Appliquer dégâts&#10;                    // enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                    enemyHealth.TakeDamage(new DamageInfo(dashDamage, &quot;Dash&quot;, DamageType.Dash));&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            characterController.Move(dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;&#10;            if(sound != null)&#10;            {&#10;                sound.PlayOneShot(&quot;Dash&quot;);&#10;            }&#10;&#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Mettre la vitesse de mouvement au maximum&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;            }&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;        // Vérifie si le dash doit être arrêté par une collision avec un obstacle à mauvais angle&#10;        private bool CheckObstacleCollision()&#10;        {&#10;            // Raycast dans la direction du dash pour détecter les obstacles&#10;            RaycastHit hit;&#10;            float checkDistance = obstacleCheckDistance;&#10;            &#10;            // SphereCast pour détecter les obstacles devant le joueur avec un rayon similaire au dashHitRadius&#10;            if (Physics.SphereCast(&#10;                transform.position,&#10;                dashHitRadius * 0.8f, // Légèrement plus petit pour éviter les faux positifs&#10;                directionalDashDir,&#10;                out hit,&#10;                checkDistance,&#10;                obstacleMask,&#10;                QueryTriggerInteraction.Ignore))&#10;            {&#10;                // Ignorer si c'est un ennemi (ils sont gérés séparément)&#10;                var enemyHealth = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth != null)&#10;                {&#10;                    return false; // Ne pas arrêter le dash pour les ennemis&#10;                }&#10;                &#10;                // Calculer l'angle entre la direction du dash et la normale de la surface&#10;                float angle = Vector3.Angle(directionalDashDir, -hit.normal);&#10;                &#10;                // Debug visuel&#10;                Debug.DrawRay(hit.point, hit.normal * 2f, Color.red, 0.1f);&#10;                Debug.DrawRay(hit.point, directionalDashDir * 2f, Color.yellow, 0.1f);&#10;                &#10;                // Si l'angle est trop abrupt (surface trop perpendiculaire à la direction du dash)&#10;                if (angle &gt; maxCollisionAngle)&#10;                {&#10;                    Debug.Log($&quot;[DashSystem] Dash arrêté par collision ! Angle: {angle:F1}° (max: {maxCollisionAngle}°)&quot;);&#10;                    return true; // Arrêter le dash&#10;                }&#10;            }&#10;            &#10;            return false; // Continuer le dash&#10;        }&#10;        &#10;&#10;        // Désactive toutes les collisions d'un ennemi pour permettre au dash de passer à travers.&#10;        private void DisableEnemyCollisions(GameObject enemy)&#10;        {&#10;&#10;            Collider[] colliders = enemy.GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;            &#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody rb = enemy.GetComponent&lt;Rigidbody&gt;();&#10;            if (rb != null)&#10;            {&#10;                rb.isKinematic = true;&#10;                rb.detectCollisions = false;&#10;            }&#10;            &#10;            Rigidbody[] childRbs = enemy.GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        private System.Collections.IEnumerator CleanupEnemyTracking(GameObject enemy)&#10;        {&#10;            yield return new WaitForSeconds(2f);&#10;            if (enemy == null)&#10;            {&#10;                // L'ennemi a bien été détruit, on peut le retirer du tracking&#10;                enemiesKilledByDash.Remove(enemy);&#10;            }&#10;        }&#10;        &#10;        // Vérifie si un ennemi a été tué par le dash&#10;        public static bool WasKilledByDash(GameObject enemy)&#10;        {&#10;            return enemiesKilledByDash.Contains(enemy);&#10;        }&#10;        &#10;        private void EndDash()&#10;        {&#10;            // Appliquer le momentum de sortie si activé&#10;            if (conserveMomentum &amp;&amp; fpsMovement != null)&#10;            {&#10;                // Calculer le momentum basé sur la vitesse du dash&#10;                Vector3 dashMomentum = directionalDashDir * dashSpeed * momentumRetention;&#10;                fpsMovement.ApplyExternalMomentum(dashMomentum);&#10;                &#10;                Debug.Log($&quot;[DashSystem] Momentum conservé: {dashMomentum.magnitude:F1} m/s dans la direction {directionalDashDir}&quot;);&#10;            }&#10;            &#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[DashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System.Runtime.CompilerServices;&#10;using FPS; // EnemyHealth&#10;namespace FPS&#10;{&#10;&#10;    // Système de dash directionnel&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage&#10;    public class DashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;Collision Settings&quot;)]&#10;        [Tooltip(&quot;Angle maximum (en degrés) entre la direction du dash et la surface pour continuer le dash. Au-delà, le dash s'arrête.&quot;)]&#10;        [SerializeField] private float maxCollisionAngle = 45f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour les obstacles qui peuvent arrêter le dash&quot;)]&#10;        [SerializeField] private LayerMask obstacleMask = ~0;&#10;        &#10;        [Tooltip(&quot;Distance de détection des obstacles devant le joueur&quot;)]&#10;        [SerializeField] private float obstacleCheckDistance = 0.5f;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [Tooltip(&quot;Conserver l'énergie cinétique à la sortie du dash&quot;)]&#10;        [SerializeField] private bool conserveMomentum = true;&#10;        &#10;        [Tooltip(&quot;Pourcentage du momentum du dash à conserver (0 à 1)&quot;)]&#10;        [SerializeField] private float momentumRetention = 0.8f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        [SerializeField] private Transform cameraTransform;&#10;        [SerializeField] private SoundPlayer sound;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false;&#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private Rigidbody rb;&#10;        &#10;        private static System.Collections.Generic.HashSet&lt;GameObject&gt; enemiesKilledByDash = new System.Collections.Generic.HashSet&lt;GameObject&gt;();&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (fpsMovement == null)&#10;            {&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            rb = fpsMovement != null ? fpsMovement.Rb : GetComponent&lt;Rigidbody&gt;();&#10;            &#10;            if (rb == null)&#10;            {&#10;                rb = GetComponent&lt;Rigidbody&gt;();&#10;                Debug.LogWarning(&quot;[DashSystem] Rigidbody obtenu directement car fpsMovement.Rb était null&quot;);&#10;            }&#10;            &#10;            if (rb == null)&#10;            {&#10;                Debug.LogError(&quot;[DashSystem] Rigidbody non trouvé! Le dash ne fonctionnera pas.&quot;);&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || rb == null) return;&#10;&#10;            // Vérifier les obstacles devant le joueur&#10;            if (CheckObstacleCollision())&#10;            {&#10;                EndDash();&#10;                return;&#10;            }&#10;            &#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Si c'est un ennemi électrique -&gt; stun le joueur (auto-fire)&#10;                    var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                    if (electric != null)&#10;                    {&#10;                        var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (electric.OverrideAutoFireInterval)&#10;                            playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                        else&#10;                            playerStun.ApplyStun(electric.StunDuration);&#10;                        &#10;                        // Arrêter le dash immédiatement à cause du stun électrique&#10;                        EndDash();&#10;                        return;&#10;                    }&#10;&#10;                    // Marquer comme kill par dash si le coup sera létal&#10;                    bool willDie = enemyHealth.CurrentHealth &lt;= dashDamage;&#10;                    if (willDie)&#10;                    {&#10;                        enemiesKilledByDash.Add(enemyRoot);&#10;                        StartCoroutine(CleanupEnemyTracking(enemyRoot));&#10;                        &#10;                        // Désactiver immédiatement les collisions pour permettre le dash à travers&#10;                        DisableEnemyCollisions(enemyRoot);&#10;                    }&#10;&#10;                    // Appliquer dégâts&#10;                    // enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                    enemyHealth.TakeDamage(new DamageInfo(dashDamage, &quot;Dash&quot;, DamageType.Dash));&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            rb.MovePosition(rb.position + dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;&#10;            if(sound != null)&#10;            {&#10;                sound.PlayOneShot(&quot;Dash&quot;);&#10;            }&#10;&#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Mettre la vitesse de mouvement au maximum et désactiver le mouvement normal&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;                fpsMovement.DisableMovement();&#10;            }&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;        // Vérifie si le dash doit être arrêté par une collision avec un obstacle à mauvais angle&#10;        private bool CheckObstacleCollision()&#10;        {&#10;            // Raycast dans la direction du dash pour détecter les obstacles&#10;            RaycastHit hit;&#10;            float checkDistance = obstacleCheckDistance;&#10;            &#10;            // SphereCast pour détecter les obstacles devant le joueur avec un rayon similaire au dashHitRadius&#10;            if (Physics.SphereCast(&#10;                transform.position,&#10;                dashHitRadius * 0.8f, // Légèrement plus petit pour éviter les faux positifs&#10;                directionalDashDir,&#10;                out hit,&#10;                checkDistance,&#10;                obstacleMask,&#10;                QueryTriggerInteraction.Ignore))&#10;            {&#10;                // Ignorer si c'est un ennemi (ils sont gérés séparément)&#10;                var enemyHealth = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth != null)&#10;                {&#10;                    return false; // Ne pas arrêter le dash pour les ennemis&#10;                }&#10;                &#10;                // Calculer l'angle entre la direction du dash et la normale de la surface&#10;                float angle = Vector3.Angle(directionalDashDir, -hit.normal);&#10;                &#10;                // Debug visuel&#10;                Debug.DrawRay(hit.point, hit.normal * 2f, Color.red, 0.1f);&#10;                Debug.DrawRay(hit.point, directionalDashDir * 2f, Color.yellow, 0.1f);&#10;                &#10;                // Si l'angle est trop abrupt (surface trop perpendiculaire à la direction du dash)&#10;                if (angle &gt; maxCollisionAngle)&#10;                {&#10;                    Debug.Log($&quot;[DashSystem] Dash arrêté par collision ! Angle: {angle:F1}° (max: {maxCollisionAngle}°)&quot;);&#10;                    return true; // Arrêter le dash&#10;                }&#10;            }&#10;            &#10;            return false; // Continuer le dash&#10;        }&#10;        &#10;&#10;        // Désactive toutes les collisions d'un ennemi pour permettre au dash de passer à travers.&#10;        private void DisableEnemyCollisions(GameObject enemy)&#10;        {&#10;&#10;            Collider[] colliders = enemy.GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;            &#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody enemyRb = enemy.GetComponent&lt;Rigidbody&gt;();&#10;            if (enemyRb != null)&#10;            {&#10;                enemyRb.isKinematic = true;&#10;                enemyRb.detectCollisions = false;&#10;            }&#10;            &#10;            Rigidbody[] childRbs = enemy.GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        private System.Collections.IEnumerator CleanupEnemyTracking(GameObject enemy)&#10;        {&#10;            yield return new WaitForSeconds(2f);&#10;            if (enemy == null)&#10;            {&#10;                // L'ennemi a bien été détruit, on peut le retirer du tracking&#10;                enemiesKilledByDash.Remove(enemy);&#10;            }&#10;        }&#10;        &#10;        // Vérifie si un ennemi a été tué par le dash&#10;        public static bool WasKilledByDash(GameObject enemy)&#10;        {&#10;            return enemiesKilledByDash.Contains(enemy);&#10;        }&#10;        &#10;        private void EndDash()&#10;        {&#10;            // Réactiver le mouvement normal&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.EnableMovement();&#10;            }&#10;            &#10;            // Appliquer le momentum de sortie si activé&#10;            if (conserveMomentum &amp;&amp; fpsMovement != null)&#10;            {&#10;                // Calculer le momentum basé sur la vitesse du dash&#10;                Vector3 dashMomentum = directionalDashDir * dashSpeed * momentumRetention;&#10;                fpsMovement.ApplyExternalMomentum(dashMomentum);&#10;                &#10;                Debug.Log($&quot;[DashSystem] Momentum conservé: {dashMomentum.magnitude:F1} m/s dans la direction {directionalDashDir}&quot;);&#10;            }&#10;            &#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[DashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Death.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Death.cs" />
              <option name="originalContent" value="using FPS;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(PlayerHealth))]&#10;public class Death : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform spawnRoot;&#10;&#10;    private PlayerHealth playerHealth;&#10;    private CharacterController characterController;&#10;    private Vector3 spawnPosition;&#10;    private Quaternion spawnRotation;&#10;&#10;    // Start is called once before the first execution of Update after the MonoBehaviour is created&#10;    void Awake()&#10;    {&#10;        playerHealth = GetComponent&lt;PlayerHealth&gt;();&#10;        characterController = GetComponent&lt;CharacterController&gt;();&#10;        spawnRoot = spawnRoot != null ? spawnRoot : transform;&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        if (playerHealth != null)&#10;        {&#10;            playerHealth.OnDeath.AddListener(HandleDeath);&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        CacheSpawnPoint();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (playerHealth != null)&#10;        {&#10;            playerHealth.OnDeath.RemoveListener(HandleDeath);&#10;        }&#10;    }&#10;&#10;    private void CacheSpawnPoint()&#10;    {&#10;        spawnPosition = spawnRoot.position;&#10;        spawnRotation = spawnRoot.rotation;&#10;    }&#10;&#10;    public void SetSpawnPoint(Transform newSpawn)&#10;    {&#10;        if (newSpawn == null) return;&#10;        spawnRoot = newSpawn;&#10;        CacheSpawnPoint();&#10;    }&#10;&#10;    private void HandleDeath()&#10;    {&#10;        RespawnPlayer();&#10;        playerHealth.ResetHealth();&#10;    }&#10;&#10;    private void RespawnPlayer()&#10;    {&#10;        bool controllerInitiallyEnabled = characterController != null &amp;&amp; characterController.enabled;&#10;        if (characterController != null)&#10;        {&#10;            characterController.enabled = false;&#10;        }&#10;&#10;        transform.SetPositionAndRotation(spawnPosition, spawnRotation);&#10;&#10;        if (controllerInitiallyEnabled)&#10;        {&#10;            characterController.enabled = true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using FPS;&#10;using UnityEngine;&#10;&#10;[RequireComponent(typeof(PlayerHealth))]&#10;public class Death : MonoBehaviour&#10;{&#10;    [SerializeField] private Transform spawnRoot;&#10;&#10;    private PlayerHealth playerHealth;&#10;    private Rigidbody rb;&#10;    private Vector3 spawnPosition;&#10;    private Quaternion spawnRotation;&#10;&#10;    // Start is called once before the first execution of Update after the MonoBehaviour is created&#10;    void Awake()&#10;    {&#10;        playerHealth = GetComponent&lt;PlayerHealth&gt;();&#10;        rb = GetComponent&lt;Rigidbody&gt;();&#10;        spawnRoot = spawnRoot != null ? spawnRoot : transform;&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        if (playerHealth != null)&#10;        {&#10;            playerHealth.OnDeath.AddListener(HandleDeath);&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        CacheSpawnPoint();&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (playerHealth != null)&#10;        {&#10;            playerHealth.OnDeath.RemoveListener(HandleDeath);&#10;        }&#10;    }&#10;&#10;    private void CacheSpawnPoint()&#10;    {&#10;        spawnPosition = spawnRoot.position;&#10;        spawnRotation = spawnRoot.rotation;&#10;    }&#10;&#10;    public void SetSpawnPoint(Transform newSpawn)&#10;    {&#10;        if (newSpawn == null) return;&#10;        spawnRoot = newSpawn;&#10;        CacheSpawnPoint();&#10;    }&#10;&#10;    private void HandleDeath()&#10;    {&#10;        RespawnPlayer();&#10;        playerHealth.ResetHealth();&#10;    }&#10;&#10;    private void RespawnPlayer()&#10;    {&#10;        if (rb != null)&#10;        {&#10;            // Reset velocity before teleporting&#10;            rb.linearVelocity = Vector3.zero;&#10;            rb.angularVelocity = Vector3.zero;&#10;            &#10;            // Teleport using Rigidbody&#10;            rb.position = spawnPosition;&#10;            rb.rotation = spawnRotation;&#10;        }&#10;        else&#10;        {&#10;            transform.SetPositionAndRotation(spawnPosition, spawnRotation);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/DashCible.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/DashCible.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;    public class DashCible : MonoBehaviour&#10;    {&#10;        [Header(&quot;Ciblage&quot;)]&#10;        [SerializeField] private Camera aimCamera;&#10;&#10;        [Header(&quot;Définition du Dash&quot;)]&#10;        [SerializeField] private DashDefinition dashDefinition;&#10;        [SerializeField] private BounceDefinition groundBounce;&#10;        [SerializeField] private BounceDefinition airBounce;&#10;&#10;        [Header(&quot;Input&quot;)]&#10;        [SerializeField] private KeyCode activationKey = KeyCode.Q;&#10;&#10;        [Header(&quot;Références Joueur&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private CharacterController characterController;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        private PlayerHealth playerHealth;&#10;&#10;        public bool isDashing;&#10;        private bool chainActive;&#10;        private int remainingChains;&#10;        private float nextAvailableTime;&#10;        private float slowMoEndUnscaled;&#10;        public bool slowMoApplied;&#10;        private float previousTimeScale = 1f;&#10;        private bool pathElectricStunned;&#10;&#10;        private static readonly Collider[] OverlapBuffer = new Collider[16];&#10;&#10;        private DashDefinition Config =&gt; dashDefinition;&#10;        private LayerMask EnemyMask =&gt; Config?.enemyMask ?? ~0;&#10;        private LayerMask ObstacleMask =&gt; Config?.obstacleMask ?? ~0;&#10;        private float MaxAimAngle =&gt; Mathf.Max(0f, Config?.maxAimAngle ?? 30f);&#10;        private int ConfigCountDash =&gt; Mathf.Max(1, Config?.countDash ?? 3);&#10;        private float ConfigSlowMoTime =&gt; Mathf.Max(0.01f, Config?.slowMoTime ?? 0.75f);&#10;        private float ConfigSlowMoScale =&gt; Mathf.Clamp(Config?.slowMoScale ?? 0.2f, 0.01f, 1f);&#10;        private float ConfigDistanceDash =&gt; Mathf.Max(0.5f, Config?.distanceDash ?? 25f);&#10;        private float ConfigCooldown =&gt; Mathf.Max(0f, Config?.cooldown ?? 1.5f);&#10;        private float ConfigDashDamage =&gt; Mathf.Max(0f, Config?.dashDamage ?? 9999f);&#10;        private float ConfigDashTravelTime =&gt; Mathf.Max(0.01f, Config?.dashTravelTime ?? 0.08f);&#10;        private float ConfigCapsuleRadius =&gt; Mathf.Max(0f, Config?.capsuleRadius ?? 0.4f);&#10;        private float ConfigStopOffset =&gt; Mathf.Max(0f, Config?.stopOffset ?? 1f);&#10;        private BounceDefinition CurrentBounce&#10;        {&#10;            get&#10;            {&#10;                bool grounded = fpsMovement == null || fpsMovement.IsGrounded;&#10;                if (grounded)&#10;                    return groundBounce ?? airBounce;&#10;                return airBounce ?? groundBounce;&#10;            }&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            if (playerController == null)&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;            if (characterController == null &amp;&amp; playerController != null)&#10;                characterController = playerController.Controller;&#10;            if (fpsMovement == null)&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            if (aimCamera == null)&#10;                aimCamera = Camera.main;&#10;            playerHealth = GetComponent&lt;PlayerHealth&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (slowMoApplied &amp;&amp; Time.unscaledTime &gt;= slowMoEndUnscaled)&#10;            {&#10;                ClearSlowMo();&#10;                if (!isDashing &amp;&amp; chainActive)&#10;                {&#10;                    EndChain();&#10;                }&#10;            }&#10;&#10;            if (Input.GetKeyDown(activationKey))&#10;            {&#10;                TryTriggerOrChain();&#10;            }&#10;        }&#10;&#10;        private void TryTriggerOrChain()&#10;        {&#10;            if (isDashing) return;&#10;&#10;            bool isFirstDash = !chainActive;&#10;&#10;            if (!chainActive)&#10;            {&#10;                if (Time.time &lt; nextAvailableTime) return;&#10;                remainingChains = ConfigCountDash;&#10;                chainActive = true;&#10;            }&#10;            else&#10;            {&#10;                if (!slowMoApplied || remainingChains &lt;= 0)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            var target = AcquireTarget();&#10;            if (target == null)&#10;            {&#10;                // Pas de cible trouvée&#10;                if (isFirstDash)&#10;                {&#10;                    // Premier dash sans cible - annuler la chaîne&#10;                    chainActive = false;&#10;                }&#10;                // Sinon, ignorer le clic sans annuler la chaîne (le slow-mo continue)&#10;                return;&#10;            }&#10;&#10;            remainingChains = Mathf.Max(0, remainingChains - 1);&#10;            StartCoroutine(DoTargetDash(target));&#10;        }&#10;&#10;        private EnemyHealth AcquireTarget()&#10;        {&#10;            if (aimCamera == null) return null;&#10;&#10;            Ray ray = aimCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;            if (Physics.Raycast(ray, out RaycastHit hit, ConfigDistanceDash, EnemyMask, QueryTriggerInteraction.Ignore))&#10;            {&#10;                var eh = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (eh != null &amp;&amp; !eh.IsDead)&#10;                {&#10;                    if (!IsObstructed(aimCamera.transform.position, eh.transform.position))&#10;                        return eh;&#10;                }&#10;            }&#10;&#10;            var all = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsInactive.Exclude, FindObjectsSortMode.None);&#10;            EnemyHealth best = null;&#10;            float bestScore = float.MaxValue;&#10;            Vector3 camPos = aimCamera.transform.position;&#10;            Vector3 camFwd = aimCamera.transform.forward;&#10;&#10;            foreach (var eh in all)&#10;            {&#10;                if (eh == null || eh.IsDead) continue;&#10;                Vector3 to = eh.transform.position - camPos;&#10;                float dist = to.magnitude;&#10;                if (dist &gt; ConfigDistanceDash) continue;&#10;                Vector3 dir = to / (dist + 1e-5f);&#10;                float angle = Mathf.Acos(Mathf.Clamp(Vector3.Dot(camFwd, dir), -1f, 1f)) * Mathf.Rad2Deg;&#10;                if (angle &gt; MaxAimAngle) continue;&#10;                if (IsObstructed(camPos, eh.transform.position)) continue;&#10;                float score = angle * 2f + dist * 0.2f;&#10;                if (score &lt; bestScore)&#10;                {&#10;                    bestScore = score;&#10;                    best = eh;&#10;                }&#10;            }&#10;&#10;            return best;&#10;        }&#10;&#10;        private bool IsObstructed(Vector3 from, Vector3 to)&#10;        {&#10;            Vector3 dir = to - from;&#10;            float dist = dir.magnitude;&#10;            if (dist &lt;= 0.01f) return false;&#10;            // Utiliser uniquement ObstacleMask sans le layer des ennemis&#10;            LayerMask obstructionMask = ObstacleMask &amp; ~EnemyMask;&#10;            return Physics.Raycast(from, dir.normalized, dist - 0.1f, obstructionMask, QueryTriggerInteraction.Ignore);&#10;        }&#10;&#10;        private IEnumerator DoTargetDash(EnemyHealth target)&#10;        {&#10;            isDashing = true;&#10;            pathElectricStunned = false;&#10;&#10;            Vector3 start = transform.position;&#10;            Vector3 targetPos = target.transform.position;&#10;            Vector3 dirToTarget = (targetPos - start).normalized;&#10;            float distToTarget = Vector3.Distance(start, targetPos);&#10;&#10;            float stopDist = Mathf.Clamp(ConfigStopOffset, 0f, Mathf.Max(0f, distToTarget - 0.1f));&#10;            Vector3 end = targetPos - dirToTarget * stopDist;&#10;&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;            }&#10;&#10;            float t0 = Time.unscaledTime;&#10;            float dur = Mathf.Max(0.01f, ConfigDashTravelTime);&#10;            Vector3 prev = transform.position;&#10;&#10;            while (Time.unscaledTime - t0 &lt; dur)&#10;            {&#10;                // Recalculer la destination en temps réel (l'ennemi peut bouger)&#10;                targetPos = target.transform.position;&#10;                dirToTarget = (targetPos - start).normalized;&#10;                stopDist = Mathf.Clamp(ConfigStopOffset, 0f, Mathf.Max(0f, Vector3.Distance(start, targetPos) - 0.1f));&#10;                end = targetPos - dirToTarget * stopDist;&#10;&#10;                float u = (Time.unscaledTime - t0) / dur;&#10;                Vector3 desiredPos = Vector3.Lerp(start, end, u);&#10;                Vector3 delta = desiredPos - prev;&#10;&#10;                // Appliquer le mouvement avec sliding sur les obstacles&#10;                if (characterController != null &amp;&amp; delta.sqrMagnitude &gt; 0.0001f)&#10;                {&#10;                    delta = SlideMove(prev, delta);&#10;                    characterController.Move(delta);&#10;                }&#10;                else if (delta.sqrMagnitude &gt; 0.0001f)&#10;                {&#10;                    transform.position = desiredPos;&#10;                }&#10;&#10;                prev = transform.position;&#10;&#10;                TryStunElectricOnPath(prev);&#10;&#10;                yield return null;&#10;            }&#10;&#10;            // Mouvement final vers la destination&#10;            Vector3 finalDelta = end - transform.position;&#10;            if (characterController != null &amp;&amp; finalDelta.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                finalDelta = SlideMove(transform.position, finalDelta);&#10;                characterController.Move(finalDelta);&#10;            }&#10;            else if (finalDelta.sqrMagnitude &gt; 0.0001f)&#10;            {&#10;                transform.position = end;&#10;            }&#10;&#10;            // Vérifier si on est assez proche de l'ennemi pour appliquer les dégâts&#10;            float finalDistance = Vector3.Distance(transform.position, target.transform.position);&#10;            bool reachedTarget = finalDistance &lt;= ConfigStopOffset + 1f;&#10;&#10;            var electric = target.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;            if (electric != null)&#10;            {&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;&#10;                if (electric.ResistToDash)&#10;                {&#10;                    isDashing = false;&#10;                    ClearSlowMo();&#10;                    EndChain();&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Appliquer les dégâts seulement si on a atteint la cible&#10;            if (reachedTarget)&#10;            {&#10;                var hitCol = target.GetComponentInChildren&lt;Collider&gt;();&#10;                var dmg = new DamageInfo(amount: ConfigDashDamage, zoneName: &quot;Dash&quot;, type: DamageType.Dash, hitPoint: target.transform.position, hitNormal: -dirToTarget, attacker: transform, hitCollider: hitCol);&#10;                bool applied = target.TryApplyDamage(dmg);&#10;&#10;                if (applied)&#10;                {&#10;                    ApplyOrRefreshSlowMo();&#10;                    ApplyBounceImpulse(dirToTarget);&#10;                }&#10;            }&#10;&#10;            isDashing = false;&#10;&#10;            if (remainingChains &lt;= 0)&#10;            {&#10;                if (!slowMoApplied)&#10;                {&#10;                    EndChain();&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calcule un vecteur de déplacement qui glisse le long des obstacles.&#10;        /// &lt;/summary&gt;&#10;        private Vector3 SlideMove(Vector3 currentPos, Vector3 desiredDelta)&#10;        {&#10;            Vector3 totalMove = Vector3.zero;&#10;            Vector3 remainingMove = desiredDelta;&#10;            const int maxIterations = 3;&#10;&#10;            for (int i = 0; i &lt; maxIterations; i++)&#10;            {&#10;                if (remainingMove.sqrMagnitude &lt; 0.0001f)&#10;                    break;&#10;&#10;                float moveLen = remainingMove.magnitude;&#10;                Vector3 moveDir = remainingMove / moveLen;&#10;&#10;                Vector3 top = currentPos + totalMove + Vector3.up * 1.5f;&#10;                Vector3 bottom = currentPos + totalMove + Vector3.up * 0.2f;&#10;&#10;                if (Physics.CapsuleCast(top, bottom, ConfigCapsuleRadius, moveDir, out RaycastHit hit, moveLen, ObstacleMask, QueryTriggerInteraction.Ignore))&#10;                {&#10;                    // Avancer jusqu'au point de contact (avec une petite marge)&#10;                    float safeDistance = Mathf.Max(0f, hit.distance - 0.05f);&#10;                    Vector3 safeMove = moveDir * safeDistance;&#10;                    totalMove += safeMove;&#10;&#10;                    // Calculer le mouvement restant projeté sur le plan de l'obstacle (sliding)&#10;                    float leftoverDist = moveLen - hit.distance;&#10;                    if (leftoverDist &gt; 0.01f)&#10;                    {&#10;                        Vector3 leftoverDir = moveDir * leftoverDist;&#10;                        remainingMove = Vector3.ProjectOnPlane(leftoverDir, hit.normal);&#10;                    }&#10;                    else&#10;                    {&#10;                        break;&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Pas d'obstacle, on peut avancer complètement&#10;                    totalMove += remainingMove;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            return totalMove;&#10;        }&#10;&#10;        private void ApplyOrRefreshSlowMo()&#10;        {&#10;            slowMoEndUnscaled = Time.unscaledTime + ConfigSlowMoTime;&#10;            if (!slowMoApplied)&#10;            {&#10;                previousTimeScale = Time.timeScale;&#10;                Time.timeScale = ConfigSlowMoScale;&#10;                Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;                slowMoApplied = true;&#10;            }&#10;        }&#10;&#10;        private void ClearSlowMo()&#10;        {&#10;            if (!slowMoApplied) return;&#10;            Time.timeScale = previousTimeScale;&#10;            Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;            slowMoApplied = false;&#10;        }&#10;&#10;        private void EndChain()&#10;        {&#10;            chainActive = false;&#10;            remainingChains = 0;&#10;            nextAvailableTime = Time.time + ConfigCooldown;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (slowMoApplied) ClearSlowMo();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (slowMoApplied) ClearSlowMo();&#10;        }&#10;&#10;        public int CountDash =&gt; ConfigCountDash;&#10;        public float SlowMoTime =&gt; ConfigSlowMoTime;&#10;        public float DistanceDash =&gt; ConfigDistanceDash;&#10;        public float Cooldown =&gt; ConfigCooldown;&#10;        &#10;        public bool IsChainActive =&gt; chainActive;&#10;        public int RemainingChains =&gt; chainActive ? Mathf.Clamp(remainingChains, 0, ConfigCountDash) : ConfigCountDash;&#10;        public bool IsSlowMoActive =&gt; slowMoApplied;&#10;        &#10;        /// &lt;summary&gt;True si le cooldown global est en cours (après la fin du slow-mo)&lt;/summary&gt;&#10;        public bool IsCooldownActive =&gt; !chainActive &amp;&amp; Time.time &lt; nextAvailableTime;&#10;        &#10;        /// &lt;summary&gt;Progression du cooldown de 0 (début) à 1 (terminé)&lt;/summary&gt;&#10;        public float CooldownProgress =&gt; IsCooldownActive &#10;            ? 1f - ((nextAvailableTime - Time.time) / ConfigCooldown) &#10;            : 1f;&#10;        &#10;        private void TryStunElectricOnPath(Vector3 currentPos)&#10;        {&#10;            if (pathElectricStunned) return;&#10;            Vector3 top = currentPos + Vector3.up * 1.5f;&#10;            Vector3 bottom = currentPos + Vector3.up * 0.2f;&#10;            int count = Physics.OverlapCapsuleNonAlloc(top, bottom, ConfigCapsuleRadius, OverlapBuffer, EnemyMask, QueryTriggerInteraction.Ignore);&#10;            for (int i = 0; i &lt; count; i++)&#10;            {&#10;                var col = OverlapBuffer[i];&#10;                if (col == null) continue;&#10;                var electric = col.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? col.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electric == null) continue;&#10;&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;() ?? gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;&#10;                pathElectricStunned = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        private void ApplyBounceImpulse(Vector3 dashDirection)&#10;        {&#10;            BounceDefinition config = CurrentBounce;&#10;            if (config == null || config.force &lt;= 0f)&#10;                return;&#10;&#10;            Vector3 dir = ResolveBounceDirection(dashDirection, config);&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                return;&#10;&#10;            Vector3 momentum = dir.normalized * config.force;&#10;&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.ApplyExternalMomentum(momentum);&#10;            }&#10;            else if (characterController != null)&#10;            {&#10;                characterController.Move(momentum * Time.deltaTime);&#10;            }&#10;            else&#10;            {&#10;                transform.position += momentum * Time.deltaTime;&#10;            }&#10;        }&#10;&#10;        private Vector3 ResolveBounceDirection(Vector3 fallbackDashDirection, BounceDefinition config)&#10;        {&#10;            Vector3 dir = config.directionIsLocal ? transform.TransformDirection(config.direction) : config.direction;&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                dir = -fallbackDashDirection;&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                return Vector3.up;&#10;            return dir.normalized;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;    public class DashCible : MonoBehaviour&#10;    {&#10;        [Header(&quot;Ciblage&quot;)]&#10;        [SerializeField] private Camera aimCamera;&#10;&#10;        [Header(&quot;Définition du Dash&quot;)]&#10;        [SerializeField] private DashDefinition dashDefinition;&#10;        [SerializeField] private BounceDefinition groundBounce;&#10;        [SerializeField] private BounceDefinition airBounce;&#10;&#10;        [Header(&quot;Input&quot;)]&#10;        [SerializeField] private KeyCode activationKey = KeyCode.Q;&#10;&#10;        [Header(&quot;Références Joueur&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private Rigidbody rb;&#10;        [SerializeField] private FPSMovement fpsMovement;&#10;        private PlayerHealth playerHealth;&#10;&#10;        public bool isDashing;&#10;        private bool chainActive;&#10;        private int remainingChains;&#10;        private float nextAvailableTime;&#10;        private float slowMoEndUnscaled;&#10;        public bool slowMoApplied;&#10;        private float previousTimeScale = 1f;&#10;        private bool pathElectricStunned;&#10;        private float dashStartTime; // Pour détecter les dashs bloqués&#10;&#10;        private static readonly Collider[] OverlapBuffer = new Collider[16];&#10;&#10;        private DashDefinition Config =&gt; dashDefinition;&#10;        private LayerMask EnemyMask =&gt; Config?.enemyMask ?? ~0;&#10;        private LayerMask ObstacleMask =&gt; Config?.obstacleMask ?? ~0;&#10;        private float MaxAimAngle =&gt; Mathf.Max(0f, Config?.maxAimAngle ?? 30f);&#10;        private int ConfigCountDash =&gt; Mathf.Max(1, Config?.countDash ?? 3);&#10;        private float ConfigSlowMoTime =&gt; Mathf.Max(0.01f, Config?.slowMoTime ?? 0.75f);&#10;        private float ConfigSlowMoScale =&gt; Mathf.Clamp(Config?.slowMoScale ?? 0.2f, 0.01f, 1f);&#10;        private float ConfigDistanceDash =&gt; Mathf.Max(0.5f, Config?.distanceDash ?? 25f);&#10;        private float ConfigCooldown =&gt; Mathf.Max(0f, Config?.cooldown ?? 1.5f);&#10;        private float ConfigDashDamage =&gt; Mathf.Max(0f, Config?.dashDamage ?? 9999f);&#10;        private float ConfigDashTravelTime =&gt; Mathf.Max(0.01f, Config?.dashTravelTime ?? 0.08f);&#10;        private float ConfigCapsuleRadius =&gt; Mathf.Max(0f, Config?.capsuleRadius ?? 0.4f);&#10;        private float ConfigStopOffset =&gt; Mathf.Max(0f, Config?.stopOffset ?? 1f);&#10;        private BounceDefinition CurrentBounce&#10;        {&#10;            get&#10;            {&#10;                bool grounded = fpsMovement == null || fpsMovement.IsGrounded;&#10;                if (grounded)&#10;                    return groundBounce ?? airBounce;&#10;                return airBounce ?? groundBounce;&#10;            }&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            if (playerController == null)&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;            if (fpsMovement == null)&#10;                fpsMovement = GetComponent&lt;FPSMovement&gt;();&#10;            // Obtenir le Rigidbody directement pour éviter les problèmes d'ordre d'exécution&#10;            if (rb == null)&#10;                rb = GetComponent&lt;Rigidbody&gt;();&#10;            if (aimCamera == null)&#10;                aimCamera = Camera.main;&#10;            playerHealth = GetComponent&lt;PlayerHealth&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            // Sécurité: détecter si le dash est bloqué (plus de 2 secondes)&#10;            if (isDashing &amp;&amp; Time.unscaledTime - dashStartTime &gt; 2f)&#10;            {&#10;                Debug.LogWarning(&quot;[DashCible] Dash bloqué depuis plus de 2s! Réinitialisation forcée.&quot;);&#10;                FinalizeDash();&#10;                if (chainActive) EndChain();&#10;            }&#10;            &#10;            if (slowMoApplied &amp;&amp; Time.unscaledTime &gt;= slowMoEndUnscaled)&#10;            {&#10;                ClearSlowMo();&#10;                if (!isDashing &amp;&amp; chainActive)&#10;                {&#10;                    EndChain();&#10;                }&#10;            }&#10;&#10;            if (Input.GetKeyDown(activationKey))&#10;            {&#10;                TryTriggerOrChain();&#10;            }&#10;        }&#10;&#10;        private void TryTriggerOrChain()&#10;        {&#10;            // Vérifier si le mouvement est bloqué (bug potentiel)&#10;            if (fpsMovement != null &amp;&amp; fpsMovement.IsMovementDisabled &amp;&amp; !isDashing)&#10;            {&#10;                Debug.LogWarning(&quot;[DashCible] Mouvement était désactivé alors qu'on ne dashait pas! Réactivation forcée.&quot;);&#10;                fpsMovement.EnableMovement();&#10;            }&#10;            &#10;            if (isDashing)&#10;            {&#10;                Debug.Log(&quot;[DashCible] Dash bloqué: déjà en train de dasher&quot;);&#10;                return;&#10;            }&#10;&#10;            // Si la chaîne est active mais le slow-mo a expiré et le cooldown est terminé,&#10;            // on peut recommencer une nouvelle chaîne&#10;            if (chainActive &amp;&amp; !slowMoApplied &amp;&amp; Time.time &gt;= nextAvailableTime)&#10;            {&#10;                Debug.Log(&quot;[DashCible] Chaîne précédente expirée, reset pour nouvelle chaîne&quot;);&#10;                chainActive = false;&#10;            }&#10;&#10;            bool isFirstDash = !chainActive;&#10;&#10;            if (!chainActive)&#10;            {&#10;                if (Time.time &lt; nextAvailableTime)&#10;                {&#10;                    Debug.Log($&quot;[DashCible] Dash bloqué: cooldown actif ({nextAvailableTime - Time.time:F2}s restant)&quot;);&#10;                    return;&#10;                }&#10;                remainingChains = ConfigCountDash;&#10;                chainActive = true;&#10;                Debug.Log($&quot;[DashCible] Nouvelle chaîne démarrée, {remainingChains} dashs disponibles&quot;);&#10;            }&#10;            else&#10;            {&#10;                if (!slowMoApplied || remainingChains &lt;= 0)&#10;                {&#10;                    Debug.Log($&quot;[DashCible] Dash bloqué: slowMo={slowMoApplied}, remainingChains={remainingChains}&quot;);&#10;                    return;&#10;                }&#10;            }&#10;&#10;            var target = AcquireTarget();&#10;            if (target == null)&#10;            {&#10;                Debug.Log(&quot;[DashCible] Pas de cible trouvée&quot;);&#10;                // Pas de cible trouvée&#10;                if (isFirstDash)&#10;                {&#10;                    // Premier dash sans cible - annuler la chaîne&#10;                    chainActive = false;&#10;                }&#10;                // Sinon, ignorer le clic sans annuler la chaîne (le slow-mo continue)&#10;                return;&#10;            }&#10;&#10;            remainingChains = Mathf.Max(0, remainingChains - 1);&#10;            StartCoroutine(DoTargetDash(target));&#10;        }&#10;&#10;        private EnemyHealth AcquireTarget()&#10;        {&#10;            if (aimCamera == null) return null;&#10;&#10;            Ray ray = aimCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;            if (Physics.Raycast(ray, out RaycastHit hit, ConfigDistanceDash, EnemyMask, QueryTriggerInteraction.Ignore))&#10;            {&#10;                var eh = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (eh != null &amp;&amp; !eh.IsDead)&#10;                {&#10;                    if (!IsObstructed(aimCamera.transform.position, eh.transform.position))&#10;                        return eh;&#10;                }&#10;            }&#10;&#10;            var all = FindObjectsByType&lt;EnemyHealth&gt;(FindObjectsInactive.Exclude, FindObjectsSortMode.None);&#10;            EnemyHealth best = null;&#10;            float bestScore = float.MaxValue;&#10;            Vector3 camPos = aimCamera.transform.position;&#10;            Vector3 camFwd = aimCamera.transform.forward;&#10;&#10;            foreach (var eh in all)&#10;            {&#10;                if (eh == null || eh.IsDead) continue;&#10;                Vector3 to = eh.transform.position - camPos;&#10;                float dist = to.magnitude;&#10;                if (dist &gt; ConfigDistanceDash) continue;&#10;                Vector3 dir = to / (dist + 1e-5f);&#10;                float angle = Mathf.Acos(Mathf.Clamp(Vector3.Dot(camFwd, dir), -1f, 1f)) * Mathf.Rad2Deg;&#10;                if (angle &gt; MaxAimAngle) continue;&#10;                if (IsObstructed(camPos, eh.transform.position)) continue;&#10;                float score = angle * 2f + dist * 0.2f;&#10;                if (score &lt; bestScore)&#10;                {&#10;                    bestScore = score;&#10;                    best = eh;&#10;                }&#10;            }&#10;&#10;            return best;&#10;        }&#10;&#10;        private bool IsObstructed(Vector3 from, Vector3 to)&#10;        {&#10;            Vector3 dir = to - from;&#10;            float dist = dir.magnitude;&#10;            if (dist &lt;= 0.01f) return false;&#10;            // Utiliser uniquement ObstacleMask sans le layer des ennemis&#10;            LayerMask obstructionMask = ObstacleMask &amp; ~EnemyMask;&#10;            return Physics.Raycast(from, dir.normalized, dist - 0.1f, obstructionMask, QueryTriggerInteraction.Ignore);&#10;        }&#10;&#10;        private IEnumerator DoTargetDash(EnemyHealth target)&#10;        {&#10;            Debug.Log($&quot;[DashCible] DoTargetDash démarré vers {target.name}&quot;);&#10;            isDashing = true;&#10;            dashStartTime = Time.unscaledTime;&#10;            pathElectricStunned = false;&#10;&#10;            Vector3 start = transform.position;&#10;            Vector3 targetPos = target.transform.position;&#10;            Vector3 dirToTarget = (targetPos - start).normalized;&#10;            float distToTarget = Vector3.Distance(start, targetPos);&#10;&#10;            // Calculer la position d'arrêt devant l'ennemi&#10;            float stopDist = Mathf.Clamp(ConfigStopOffset, 0f, Mathf.Max(0f, distToTarget - 0.1f));&#10;            Vector3 end = targetPos - dirToTarget * stopDist;&#10;&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.SetSpeedToMax();&#10;                fpsMovement.DisableMovement();&#10;            }&#10;&#10;            float t0 = Time.unscaledTime;&#10;            float dur = Mathf.Max(0.01f, ConfigDashTravelTime);&#10;            Vector3 prev = transform.position;&#10;&#10;            while (Time.unscaledTime - t0 &lt; dur)&#10;            {&#10;                // Vérifier si la cible existe encore&#10;                if (target == null)&#10;                {&#10;                    Debug.Log(&quot;[DashCible] Cible détruite pendant le dash&quot;);&#10;                    break;&#10;                }&#10;                &#10;                // Recalculer la destination en temps réel (l'ennemi peut bouger)&#10;                targetPos = target.transform.position;&#10;                &#10;                // Recalculer la direction depuis la position de DEPART (pas la position actuelle)&#10;                // pour maintenir une trajectoire cohérente&#10;                dirToTarget = (targetPos - start).normalized;&#10;                &#10;                // Recalculer la distance totale et la position d'arrêt&#10;                float currentDistToTarget = Vector3.Distance(start, targetPos);&#10;                stopDist = Mathf.Clamp(ConfigStopOffset, 0f, Mathf.Max(0f, currentDistToTarget - 0.1f));&#10;                end = targetPos - dirToTarget * stopDist;&#10;&#10;                float u = (Time.unscaledTime - t0) / dur;&#10;                Vector3 desiredPos = Vector3.Lerp(start, end, u);&#10;                &#10;                // Vérifier si on a dépassé la position d'arrêt&#10;                float distToEnd = Vector3.Distance(transform.position, end);&#10;                float distFromStartToEnd = Vector3.Distance(start, end);&#10;                float progressToEnd = 1f - (distToEnd / Mathf.Max(0.01f, distFromStartToEnd));&#10;                &#10;                // Si on est très proche ou on a dépassé, arrêter (mais vérifier les collisions d'abord)&#10;                if (distToEnd &lt; 0.5f || progressToEnd &gt; 0.95f)&#10;                {&#10;                    // Vérifier s'il y a un obstacle entre nous et la position finale&#10;                    Vector3 finalDelta = end - transform.position;&#10;                    Vector3 safeFinalPos = GetSafePosition(transform.position, finalDelta);&#10;                    &#10;                    if (rb != null)&#10;                        rb.MovePosition(safeFinalPos);&#10;                    else&#10;                        transform.position = safeFinalPos;&#10;                    break;&#10;                }&#10;                &#10;                Vector3 delta = desiredPos - prev;&#10;&#10;                // Appliquer le mouvement avec vérification de collision&#10;                if (delta.sqrMagnitude &gt; 0.0001f)&#10;                {&#10;                    Vector3 safePos = GetSafePosition(prev, delta);&#10;                    &#10;                    if (rb != null)&#10;                        rb.MovePosition(safePos);&#10;                    else&#10;                        transform.position = safePos;&#10;                }&#10;&#10;                prev = transform.position;&#10;&#10;                TryStunElectricOnPath(prev);&#10;&#10;                yield return null;&#10;            }&#10;&#10;            // Mouvement final vers la destination (seulement si on n'est pas déjà arrivé)&#10;            float finalDistToEnd = Vector3.Distance(transform.position, end);&#10;            if (finalDistToEnd &gt; 0.1f &amp;&amp; finalDistToEnd &lt; 3f)&#10;            {&#10;                Vector3 finalDelta = end - transform.position;&#10;                if (finalDelta.sqrMagnitude &gt; 0.0001f)&#10;                {&#10;                    Vector3 safeEndPos = GetSafePosition(transform.position, finalDelta);&#10;                    &#10;                    if (rb != null)&#10;                        rb.MovePosition(safeEndPos);&#10;                    else&#10;                        transform.position = safeEndPos;&#10;                }&#10;            }&#10;&#10;            // Vérifier si la cible existe encore avant de continuer&#10;            if (target == null)&#10;            {&#10;                Debug.Log(&quot;[DashCible] Cible détruite, fin du dash sans dégâts&quot;);&#10;                FinalizeDash();&#10;                yield break;&#10;            }&#10;&#10;            // Vérifier si on est assez proche de l'ennemi pour appliquer les dégâts&#10;            float finalDistance = Vector3.Distance(transform.position, target.transform.position);&#10;            // Augmenter la tolérance pour s'assurer que le dash compte comme réussi&#10;            bool reachedTarget = finalDistance &lt;= ConfigStopOffset + 3f;&#10;            &#10;            Debug.Log($&quot;[DashCible] Distance finale: {finalDistance:F2}, StopOffset: {ConfigStopOffset:F2}, reachedTarget: {reachedTarget}&quot;);&#10;&#10;            var electric = target.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;            if (electric != null)&#10;            {&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;&#10;                if (electric.ResistToDash)&#10;                {&#10;                    FinalizeDash();&#10;                    ClearSlowMo();&#10;                    EndChain();&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Appliquer les dégâts seulement si on a atteint la cible&#10;            if (reachedTarget &amp;&amp; target != null)&#10;            {&#10;                var hitCol = target.GetComponentInChildren&lt;Collider&gt;();&#10;                var dmg = new DamageInfo(amount: ConfigDashDamage, zoneName: &quot;Dash&quot;, type: DamageType.Dash, hitPoint: target.transform.position, hitNormal: -dirToTarget, attacker: transform, hitCollider: hitCol);&#10;                bool applied = target.TryApplyDamage(dmg);&#10;&#10;                if (applied)&#10;                {&#10;                    ApplyOrRefreshSlowMo();&#10;                    ApplyBounceImpulse(dirToTarget);&#10;                }&#10;            }&#10;&#10;            FinalizeDash();&#10;&#10;            if (remainingChains &lt;= 0)&#10;            {&#10;                if (!slowMoApplied)&#10;                {&#10;                    EndChain();&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retourne une position sûre en vérifiant les collisions entre la position actuelle et la destination.&#10;        /// Exclut les ennemis pour permettre de dasher à travers eux.&#10;        /// &lt;/summary&gt;&#10;        private Vector3 GetSafePosition(Vector3 fromPos, Vector3 delta)&#10;        {&#10;            if (delta.sqrMagnitude &lt; 0.0001f)&#10;                return fromPos;&#10;            &#10;            float moveLen = delta.magnitude;&#10;            Vector3 moveDir = delta.normalized;&#10;            &#10;            // Utiliser un SphereCast pour détecter les obstacles (SANS les ennemis)&#10;            float radius = ConfigCapsuleRadius &gt; 0 ? ConfigCapsuleRadius : 0.4f;&#10;            &#10;            // Exclure les ennemis du masque de collision pour le dash&#10;            LayerMask collisionMask = ObstacleMask &amp; ~EnemyMask;&#10;            &#10;            if (Physics.SphereCast(fromPos + Vector3.up * 0.5f, radius, moveDir, out RaycastHit hit, moveLen, collisionMask, QueryTriggerInteraction.Ignore))&#10;            {&#10;                // On a touché un obstacle (pas un ennemi), s'arrêter juste avant&#10;                float safeDistance = Mathf.Max(0f, hit.distance - 0.1f);&#10;                return fromPos + moveDir * safeDistance;&#10;            }&#10;            &#10;            // Pas d'obstacle, on peut aller à la destination&#10;            return fromPos + delta;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calcule un vecteur de déplacement qui glisse le long des obstacles.&#10;        /// &lt;/summary&gt;&#10;        private Vector3 SlideMove(Vector3 currentPos, Vector3 desiredDelta)&#10;        {&#10;            Vector3 totalMove = Vector3.zero;&#10;            Vector3 remainingMove = desiredDelta;&#10;            const int maxIterations = 3;&#10;&#10;            for (int i = 0; i &lt; maxIterations; i++)&#10;            {&#10;                if (remainingMove.sqrMagnitude &lt; 0.0001f)&#10;                    break;&#10;&#10;                float moveLen = remainingMove.magnitude;&#10;                Vector3 moveDir = remainingMove / moveLen;&#10;&#10;                Vector3 top = currentPos + totalMove + Vector3.up * 1.5f;&#10;                Vector3 bottom = currentPos + totalMove + Vector3.up * 0.2f;&#10;&#10;                if (Physics.CapsuleCast(top, bottom, ConfigCapsuleRadius, moveDir, out RaycastHit hit, moveLen, ObstacleMask, QueryTriggerInteraction.Ignore))&#10;                {&#10;                    // Avancer jusqu'au point de contact (avec une petite marge)&#10;                    float safeDistance = Mathf.Max(0f, hit.distance - 0.05f);&#10;                    Vector3 safeMove = moveDir * safeDistance;&#10;                    totalMove += safeMove;&#10;&#10;                    // Calculer le mouvement restant projeté sur le plan de l'obstacle (sliding)&#10;                    float leftoverDist = moveLen - hit.distance;&#10;                    if (leftoverDist &gt; 0.01f)&#10;                    {&#10;                        Vector3 leftoverDir = moveDir * leftoverDist;&#10;                        remainingMove = Vector3.ProjectOnPlane(leftoverDir, hit.normal);&#10;                    }&#10;                    else&#10;                    {&#10;                        break;&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Pas d'obstacle, on peut avancer complètement&#10;                    totalMove += remainingMove;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            return totalMove;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Finalise le dash en réactivant le mouvement et en mettant à jour les flags&#10;        /// &lt;/summary&gt;&#10;        private void FinalizeDash()&#10;        {&#10;            isDashing = false;&#10;            Debug.Log($&quot;[DashCible] Dash finalisé, remainingChains={remainingChains}, slowMoApplied={slowMoApplied}&quot;);&#10;            &#10;            // Réactiver le mouvement normal&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.EnableMovement();&#10;            }&#10;        }&#10;&#10;        private void ApplyOrRefreshSlowMo()&#10;        {&#10;            slowMoEndUnscaled = Time.unscaledTime + ConfigSlowMoTime;&#10;            if (!slowMoApplied)&#10;            {&#10;                previousTimeScale = Time.timeScale;&#10;                Time.timeScale = ConfigSlowMoScale;&#10;                Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;                slowMoApplied = true;&#10;            }&#10;        }&#10;&#10;        private void ClearSlowMo()&#10;        {&#10;            if (!slowMoApplied) return;&#10;            Time.timeScale = previousTimeScale;&#10;            Time.fixedDeltaTime = 0.02f * Time.timeScale;&#10;            slowMoApplied = false;&#10;            &#10;            // S'assurer que le mouvement est réactivé si on n'est plus en train de dasher&#10;            if (!isDashing &amp;&amp; fpsMovement != null)&#10;            {&#10;                fpsMovement.EnableMovement();&#10;            }&#10;        }&#10;&#10;        private void EndChain()&#10;        {&#10;            chainActive = false;&#10;            remainingChains = 0;&#10;            nextAvailableTime = Time.time + ConfigCooldown;&#10;            &#10;            // S'assurer que le mouvement est réactivé&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.EnableMovement();&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (slowMoApplied) ClearSlowMo();&#10;            if (fpsMovement != null) fpsMovement.EnableMovement();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (slowMoApplied) ClearSlowMo();&#10;            if (fpsMovement != null) fpsMovement.EnableMovement();&#10;        }&#10;&#10;        public int CountDash =&gt; ConfigCountDash;&#10;        public float SlowMoTime =&gt; ConfigSlowMoTime;&#10;        public float DistanceDash =&gt; ConfigDistanceDash;&#10;        public float Cooldown =&gt; ConfigCooldown;&#10;        &#10;        public bool IsChainActive =&gt; chainActive;&#10;        public int RemainingChains =&gt; chainActive ? Mathf.Clamp(remainingChains, 0, ConfigCountDash) : ConfigCountDash;&#10;        public bool IsSlowMoActive =&gt; slowMoApplied;&#10;        &#10;        /// &lt;summary&gt;True si le cooldown global est en cours (après la fin du slow-mo)&lt;/summary&gt;&#10;        public bool IsCooldownActive =&gt; !chainActive &amp;&amp; Time.time &lt; nextAvailableTime;&#10;        &#10;        /// &lt;summary&gt;Progression du cooldown de 0 (début) à 1 (terminé)&lt;/summary&gt;&#10;        public float CooldownProgress =&gt; IsCooldownActive &#10;            ? 1f - ((nextAvailableTime - Time.time) / ConfigCooldown) &#10;            : 1f;&#10;        &#10;        private void TryStunElectricOnPath(Vector3 currentPos)&#10;        {&#10;            if (pathElectricStunned) return;&#10;            Vector3 top = currentPos + Vector3.up * 1.5f;&#10;            Vector3 bottom = currentPos + Vector3.up * 0.2f;&#10;            int count = Physics.OverlapCapsuleNonAlloc(top, bottom, ConfigCapsuleRadius, OverlapBuffer, EnemyMask, QueryTriggerInteraction.Ignore);&#10;            for (int i = 0; i &lt; count; i++)&#10;            {&#10;                var col = OverlapBuffer[i];&#10;                if (col == null) continue;&#10;                var electric = col.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? col.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electric == null) continue;&#10;&#10;                var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;() ?? gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                if (electric.OverrideAutoFireInterval)&#10;                    playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                else&#10;                    playerStun.ApplyStun(electric.StunDuration);&#10;&#10;                pathElectricStunned = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        private void ApplyBounceImpulse(Vector3 dashDirection)&#10;        {&#10;            BounceDefinition config = CurrentBounce;&#10;            if (config == null || config.force &lt;= 0f)&#10;                return;&#10;&#10;            Vector3 dir = ResolveBounceDirection(dashDirection, config);&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                return;&#10;&#10;            Vector3 momentum = dir.normalized * config.force;&#10;&#10;            if (fpsMovement != null)&#10;            {&#10;                fpsMovement.ApplyExternalMomentum(momentum);&#10;            }&#10;            else if (rb != null)&#10;            {&#10;                rb.MovePosition(rb.position + momentum * Time.deltaTime);&#10;            }&#10;            else&#10;            {&#10;                transform.position += momentum * Time.deltaTime;&#10;            }&#10;        }&#10;&#10;        private Vector3 ResolveBounceDirection(Vector3 fallbackDashDirection, BounceDefinition config)&#10;        {&#10;            Vector3 dir = config.directionIsLocal ? transform.TransformDirection(config.direction) : config.direction;&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                dir = -fallbackDashDirection;&#10;            if (dir.sqrMagnitude &lt;= 1e-4f)&#10;                return Vector3.up;&#10;            return dir.normalized;&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMouseLook.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMouseLook.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère la rotation de la caméra et le lean (inclinaison)&#10;    /// &lt;/summary&gt;&#10;    public class FPSMouseLook : MonoBehaviour&#10;    {&#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField] private Transform cameraTransform;&#10;        [SerializeField] private float mouseSensitivity = 2f;&#10;        [SerializeField] private float minVerticalAngle = -80f;&#10;        [SerializeField] private float maxVerticalAngle = 80f;&#10;&#10;        [Header(&quot;Lean Settings&quot;)]&#10;        [SerializeField] private float leanAngle = 15f;&#10;        [SerializeField] private float leanInputAngle = 20f;&#10;        [SerializeField] private float leanSpeed = 8f;&#10;&#10;        private float verticalRotation = 0f;&#10;        private float currentLean = 0f;&#10;&#10;        private void Awake()&#10;        {&#10;            // Créer la caméra si elle n'existe pas&#10;            if (cameraTransform == null)&#10;            {&#10;                GameObject camObj = new GameObject(&quot;PlayerCamera&quot;);&#10;                camObj.transform.SetParent(transform);&#10;                camObj.transform.localPosition = new Vector3(0, 0.8f, 0);&#10;                cameraTransform = camObj.transform;&#10;&#10;                Camera createdCam = camObj.AddComponent&lt;Camera&gt;();&#10;                createdCam.fieldOfView = 60f;&#10;                camObj.tag = &quot;MainCamera&quot;;&#10;            }&#10;            &#10;            Cursor.lockState = CursorLockMode.Locked;&#10;            Cursor.visible = false;&#10;        }&#10;&#10;        public void Look(Vector2 lookInput, Vector2 moveInput, bool leanLeft, bool leanRight)&#10;        {&#10;            // Rotation horizontale (corps du joueur)&#10;            float mouseX = lookInput.x * mouseSensitivity;&#10;            transform.Rotate(Vector3.up * mouseX);&#10;            &#10;            // Rotation verticale (caméra)&#10;            float mouseY = lookInput.y * mouseSensitivity;&#10;            verticalRotation -= mouseY;&#10;            verticalRotation = Mathf.Clamp(verticalRotation, minVerticalAngle, maxVerticalAngle);&#10;            &#10;            // Lean (inclinaison)&#10;            float targetLean = 0f;&#10;            if (Mathf.Abs(moveInput.x) &gt; 0.01f)&#10;            {&#10;                targetLean = Mathf.Clamp(moveInput.x, -1f, 1f) * leanAngle;&#10;            }&#10;            if (leanLeft) targetLean = leanInputAngle;&#10;            if (leanRight) targetLean = -leanInputAngle;&#10;            &#10;            currentLean = Mathf.Lerp(currentLean, targetLean, Time.deltaTime * leanSpeed);&#10;            &#10;            // Appliquer les rotations à la caméra&#10;            cameraTransform.localRotation = Quaternion.Euler(verticalRotation, 0f, currentLean);&#10;        }&#10;&#10;        public Transform CameraTransform =&gt; cameraTransform;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère la rotation de la caméra et le lean (inclinaison)&#10;    /// &lt;/summary&gt;&#10;    public class FPSMouseLook : MonoBehaviour&#10;    {&#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField] private Transform cameraTransform;&#10;        [SerializeField] private float mouseSensitivity = 2f;&#10;        [SerializeField] private float minVerticalAngle = -80f;&#10;        [SerializeField] private float maxVerticalAngle = 80f;&#10;&#10;        [Header(&quot;Lean Settings&quot;)]&#10;        [SerializeField] private float leanAngle = 15f;&#10;        [SerializeField] private float leanInputAngle = 20f;&#10;        [SerializeField] private float leanSpeed = 8f;&#10;&#10;        private float verticalRotation;&#10;        private float currentLean;&#10;        private float yaw;&#10;&#10;        private void Awake()&#10;        {&#10;            // Créer la caméra si elle n'existe pas&#10;            if (cameraTransform == null)&#10;            {&#10;                GameObject camObj = new GameObject(&quot;PlayerCamera&quot;);&#10;                camObj.transform.SetParent(transform);&#10;                camObj.transform.localPosition = new Vector3(0, 0.8f, 0);&#10;                cameraTransform = camObj.transform;&#10;&#10;                Camera createdCam = camObj.AddComponent&lt;Camera&gt;();&#10;                createdCam.fieldOfView = 60f;&#10;                camObj.tag = &quot;MainCamera&quot;;&#10;            }&#10;            &#10;            Cursor.lockState = CursorLockMode.Locked;&#10;            Cursor.visible = false;&#10;            &#10;            // Initialiser avec la rotation actuelle&#10;            yaw = transform.eulerAngles.y;&#10;            verticalRotation = 0f;&#10;        }&#10;&#10;        public void Look(Vector2 lookInput, Vector2 moveInput, bool leanLeft, bool leanRight)&#10;        {&#10;            // Rotation horizontale (corps du joueur) - appliquée directement au transform&#10;            float mouseX = lookInput.x * mouseSensitivity;&#10;            yaw += mouseX;&#10;            transform.rotation = Quaternion.Euler(0f, yaw, 0f);&#10;            &#10;            // Rotation verticale (caméra)&#10;            float mouseY = lookInput.y * mouseSensitivity;&#10;            verticalRotation -= mouseY;&#10;            verticalRotation = Mathf.Clamp(verticalRotation, minVerticalAngle, maxVerticalAngle);&#10;            &#10;            // Lean (inclinaison)&#10;            float targetLean = 0f;&#10;            if (Mathf.Abs(moveInput.x) &gt; 0.01f)&#10;            {&#10;                targetLean = Mathf.Clamp(moveInput.x, -1f, 1f) * leanAngle;&#10;            }&#10;            if (leanLeft) targetLean = leanInputAngle;&#10;            if (leanRight) targetLean = -leanInputAngle;&#10;            &#10;            currentLean = Mathf.Lerp(currentLean, targetLean, Time.deltaTime * leanSpeed);&#10;            &#10;            // Appliquer les rotations à la caméra&#10;            cameraTransform.localRotation = Quaternion.Euler(verticalRotation, 0f, currentLean);&#10;        }&#10;&#10;        public Transform CameraTransform =&gt; cameraTransform;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSMovement.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    /// Gère le mouvement du joueur&#10;    [RequireComponent(typeof(CharacterController))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnSpeedChanged = new UnityEvent&lt;float&gt;();&#10;&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;        &#10;        [Header(&quot;Jump Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Temps après avoir quitté le sol pendant lequel on peut encore sauter&quot;)]&#10;        private float coyoteTime = 0.15f;&#10;&#10;        private float defaultMoveSpeed;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de momentum lors du saut (1 = vitesse normale, &gt;1 = boost)&quot;)]&#10;        private float jumpMomentumMultiplier = 1f;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        [Header(&quot;External Momentum&quot;)]&#10;        [SerializeField, Tooltip(&quot;Facteur de dissipation appliqué au momentum externe (0 = sans dissipation).&quot;)]&#10;        private float externalMomentumDamping = 12f;&#10;        [SerializeField, Tooltip(&quot;Durée pendant laquelle la composante verticale du momentum est conservée même si le joueur est au sol.&quot;)]&#10;        private float externalMomentumGroundGrace = 0.08f;&#10;&#10;        private CharacterController controller;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private Vector3 externalMomentum = Vector3.zero;&#10;        private float externalMomentumGroundTimer;&#10;        private bool isGrounded;&#10;        private float coyoteTimeCounter;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;        &#10;        // Méthode pour forcer la vitesse au max (utilisée par le dash)&#10;        public void SetSpeedToMax()&#10;        {&#10;            moveSpeed = speedLimit;&#10;        }&#10;        &#10;        // Méthode pour appliquer un momentum externe (utilisée par le dash)&#10;        public void ApplyExternalMomentum(Vector3 momentum)&#10;        {&#10;            externalMomentum = momentum;&#10;            externalMomentumGroundTimer = externalMomentumGroundGrace;&#10;            moveSpeed = Mathf.Max(moveSpeed, momentum.magnitude);&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        // Cette méthode sera appelée par le PlayerController&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            float previousSpeed = moveSpeed;&#10;&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;&#10;            if (!Mathf.Approximately(previousSpeed, moveSpeed))&#10;            {&#10;                OnSpeedChanged?.Invoke(moveSpeed);&#10;            }&#10;        }&#10;&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * input.x + transform.forward * input.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = sprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    controller.Move(desired * (CurrentSpeed * Time.deltaTime));&#10;                }&#10;&#10;                // Saut&#10;                if (jump)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); //&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Permettre le saut pendant le coyote time&#10;                if (jump &amp;&amp; coyoteTimeCounter &gt; 0f)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                }&#10;                &#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    controller.Move(jumpMomentum * Time.deltaTime);&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        controller.Move(desired * (CurrentSpeed * airControlFactor * Time.deltaTime));&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Vector3 airMove = desired * CurrentSpeed * airControlFactor;&#10;                    moveDirection.x = Mathf.Lerp(moveDirection.x, airMove.x, airControlFactor);&#10;                    moveDirection.z = Mathf.Lerp(moveDirection.z, airMove.z, airControlFactor);&#10;&#10;                    controller.Move(new Vector3(moveDirection.x, 0, moveDirection.z) * Time.deltaTime);&#10;                }&#10;            }&#10;&#10;            ProcessExternalMomentum();&#10;            velocity.y += gravity * gravityMultiplier * Time.deltaTime;&#10;            controller.Move(new Vector3(0, velocity.y, 0) * Time.deltaTime);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            if (groundCheck != null &amp;&amp; groundMask != 0)&#10;            {&#10;                isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;            }&#10;            else&#10;            {&#10;                isGrounded = controller.isGrounded;&#10;            }&#10;&#10;            // Gérer le coyote time&#10;            if (isGrounded)&#10;            {&#10;                coyoteTimeCounter = coyoteTime;&#10;            }&#10;            else&#10;            {&#10;                coyoteTimeCounter -= Time.deltaTime;&#10;            }&#10;&#10;            // Réinitialiser la vélocité verticale au sol&#10;            if (isGrounded &amp;&amp; velocity.y &lt; 0)&#10;            {&#10;                velocity.y = -2f;&#10;            }&#10;        }&#10;&#10;        private void ProcessExternalMomentum()&#10;        {&#10;            if (externalMomentum.sqrMagnitude &lt;= 1e-4f)&#10;                return;&#10;&#10;            if (externalMomentumGroundTimer &gt; 0f)&#10;                externalMomentumGroundTimer -= Time.deltaTime;&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; externalMomentum.y &gt; 0f)&#10;                externalMomentum.y = 0f;&#10;&#10;            controller.Move(externalMomentum * Time.deltaTime);&#10;&#10;            float damping = externalMomentumDamping;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f)&#10;                damping *= 1.5f;&#10;&#10;            if (damping &gt; 0f)&#10;            {&#10;                externalMomentum = Vector3.MoveTowards(externalMomentum, Vector3.zero, damping * Time.deltaTime);&#10;            }&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; Mathf.Abs(externalMomentum.y) &lt; 0.01f)&#10;                externalMomentum.y = 0f;&#10;        }&#10;&#10;        public CharacterController Controller =&gt; controller;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    /// Gère le mouvement du joueur avec Rigidbody&#10;    [RequireComponent(typeof(Rigidbody))]&#10;    [RequireComponent(typeof(CapsuleCollider))]&#10;    public class FPSMovement : MonoBehaviour&#10;    {&#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnSpeedChanged = new UnityEvent&lt;float&gt;();&#10;&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float sprintSpeed = 8f;&#10;        [SerializeField] private float jumpHeight = 1.5f;&#10;        [SerializeField] private float gravity = -9.81f;&#10;        [SerializeField] private float gravityMultiplier = 2f;&#10;        [SerializeField] private float maxFallSpeed = -20f;&#10;        [SerializeField] private float increaseSpeedFactor = 25f;&#10;        [SerializeField] private float speedLimit = 20f;&#10;        &#10;        [Header(&quot;Jump Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Temps après avoir quitté le sol pendant lequel on peut encore sauter&quot;)]&#10;        private float coyoteTime = 0.15f;&#10;&#10;        private float defaultMoveSpeed;&#10;&#10;        [Header(&quot;Air Control&quot;)]&#10;        [SerializeField, Tooltip(&quot;Contrôle en l'air (0 = aucun, 1 = identique au sol)&quot;)]&#10;        private float airControlFactor = 0.4f;&#10;        [SerializeField, Tooltip(&quot;Conserver la vitesse horizontale lors du saut&quot;)]&#10;        private bool preserveJumpMomentum = false;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de momentum lors du saut (1 = vitesse normale, &gt;1 = boost)&quot;)]&#10;        private float jumpMomentumMultiplier = 1f;&#10;        [SerializeField, Tooltip(&quot;Vitesse maximale en l'air&quot;)]&#10;        private float maxAirSpeed = 10f;&#10;&#10;        [Header(&quot;Ground Check&quot;)]&#10;        [SerializeField] private Transform groundCheck;&#10;        [SerializeField] private float groundDistance = 0.4f;&#10;        [SerializeField] private LayerMask groundMask;&#10;&#10;        [Header(&quot;External Momentum&quot;)]&#10;        [SerializeField, Tooltip(&quot;Facteur de dissipation appliqué au momentum externe (0 = sans dissipation).&quot;)]&#10;        private float externalMomentumDamping = 12f;&#10;        [SerializeField, Tooltip(&quot;Durée pendant laquelle la composante verticale du momentum est conservée même si le joueur est au sol.&quot;)]&#10;        private float externalMomentumGroundGrace = 0.08f;&#10;&#10;        private Rigidbody rb;&#10;        private CapsuleCollider capsuleCollider;&#10;        private Vector3 velocity;&#10;        private Vector3 moveDirection = Vector3.zero;&#10;        private Vector3 jumpMomentum = Vector3.zero;&#10;        private Vector3 externalMomentum = Vector3.zero;&#10;        private float externalMomentumGroundTimer;&#10;        private bool isGrounded;&#10;        private float coyoteTimeCounter;&#10;&#10;        // Variables pour stocker les inputs entre Update et FixedUpdate&#10;        private Vector2 inputMove;&#10;        private bool inputSprint;&#10;        private bool jumpRequested;&#10;        &#10;        // Flag pour désactiver le mouvement normal (pendant le dash)&#10;        private bool movementDisabled;&#10;&#10;        public bool IsGrounded =&gt; isGrounded;&#10;        public bool IsMoving { get; private set; }&#10;        public float CurrentSpeed { get; private set; }&#10;        &#10;        // Méthode pour forcer la vitesse au max (utilisée par le dash)&#10;        public void SetSpeedToMax()&#10;        {&#10;            moveSpeed = speedLimit;&#10;        }&#10;        &#10;        // Méthode pour appliquer un momentum externe (utilisée par le dash)&#10;        public void ApplyExternalMomentum(Vector3 momentum)&#10;        {&#10;            externalMomentum = momentum;&#10;            externalMomentumGroundTimer = externalMomentumGroundGrace;&#10;            moveSpeed = Mathf.Max(moveSpeed, momentum.magnitude);&#10;        }&#10;        &#10;        // Désactiver le mouvement normal (pendant le dash)&#10;        public void DisableMovement()&#10;        {&#10;            movementDisabled = true;&#10;            velocity.y = 0f; // Reset la gravité&#10;            Debug.Log(&quot;[FPSMovement] Mouvement désactivé&quot;);&#10;        }&#10;        &#10;        // Réactiver le mouvement normal (après le dash)&#10;        public void EnableMovement()&#10;        {&#10;            if (movementDisabled)&#10;            {&#10;                Debug.Log(&quot;[FPSMovement] Mouvement réactivé&quot;);&#10;            }&#10;            movementDisabled = false;&#10;        }&#10;        &#10;        // Propriété pour vérifier si le mouvement est désactivé&#10;        public bool IsMovementDisabled =&gt; movementDisabled;&#10;&#10;        private void Awake()&#10;        {&#10;            rb = GetComponent&lt;Rigidbody&gt;();&#10;            capsuleCollider = GetComponent&lt;CapsuleCollider&gt;();&#10;&#10;            // Configuration du Rigidbody pour un contrôle FPS&#10;            rb.interpolation = RigidbodyInterpolation.Interpolate;&#10;            rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;&#10;            rb.constraints = RigidbodyConstraints.FreezeRotation; // Freeze toutes les rotations&#10;            rb.useGravity = false; // On gère la gravité manuellement&#10;            rb.linearDamping = 0f; // Pas de résistance au mouvement&#10;            rb.angularDamping = 0f;&#10;            &#10;            // Créer un PhysicMaterial sans friction pour éviter le ralentissement sur les surfaces&#10;            PhysicsMaterial frictionlessMat = new PhysicsMaterial(&quot;PlayerNoFriction&quot;)&#10;            {&#10;                dynamicFriction = 0f,&#10;                staticFriction = 0f,&#10;                frictionCombine = PhysicsMaterialCombine.Minimum,&#10;                bounciness = 0f,&#10;                bounceCombine = PhysicsMaterialCombine.Minimum&#10;            };&#10;            capsuleCollider.material = frictionlessMat;&#10;&#10;            defaultMoveSpeed = moveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            IncreaseSpeed();&#10;            HandleGroundCheck();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            ApplyMovement();&#10;        }&#10;&#10;        private void IncreaseSpeed()&#10;        {&#10;            float previousSpeed = moveSpeed;&#10;&#10;            if (IsMoving)&#10;            {&#10;                if (moveSpeed &lt; speedLimit)&#10;                {&#10;                    moveSpeed += increaseSpeedFactor * Time.deltaTime;&#10;                    if (CurrentSpeed &gt; maxAirSpeed)&#10;                    {&#10;                        CurrentSpeed = maxAirSpeed;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                moveSpeed = defaultMoveSpeed;&#10;            }&#10;&#10;            if (!Mathf.Approximately(previousSpeed, moveSpeed))&#10;            {&#10;                OnSpeedChanged?.Invoke(moveSpeed);&#10;            }&#10;        }&#10;&#10;        // Cette méthode sera appelée par le PlayerController (dans Update)&#10;        public void Move(Vector2 input, bool sprint, bool jump)&#10;        {&#10;            inputMove = input;&#10;            inputSprint = sprint;&#10;            if (jump) jumpRequested = true;&#10;        }&#10;&#10;        private void ApplyMovement()&#10;        {&#10;            // Ne pas appliquer le mouvement normal si désactivé (pendant le dash)&#10;            if (movementDisabled) return;&#10;            &#10;            // Calculer la direction de mouvement&#10;            Vector3 desired = (transform.right * inputMove.x + transform.forward * inputMove.y);&#10;            float desiredMag = desired.magnitude;&#10;            if (desiredMag &gt; 1f) desired /= desiredMag;&#10;            &#10;            CurrentSpeed = inputSprint ? sprintSpeed : moveSpeed;&#10;            IsMoving = desired.sqrMagnitude &gt; 0.01f;&#10;&#10;            Vector3 horizontalVelocity = Vector3.zero;&#10;&#10;            if (isGrounded)&#10;            {&#10;                // Réinitialiser le momentum au sol&#10;                jumpMomentum = Vector3.zero;&#10;                &#10;                // Mouvement au sol&#10;                if (desired.sqrMagnitude &gt; 0f)&#10;                {&#10;                    horizontalVelocity = desired * CurrentSpeed;&#10;                }&#10;&#10;                // Saut&#10;                if (jumpRequested)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                    jumpRequested = false;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Permettre le saut pendant le coyote time&#10;                if (jumpRequested &amp;&amp; coyoteTimeCounter &gt; 0f)&#10;                {&#10;                    velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);&#10;                    &#10;                    // Capturer le momentum actuel pour le préserver en l'air&#10;                    if (preserveJumpMomentum &amp;&amp; desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        jumpMomentum = desired * CurrentSpeed * jumpMomentumMultiplier;&#10;                    }&#10;                    &#10;                    // Consommer le coyote time&#10;                    coyoteTimeCounter = 0f;&#10;                    jumpRequested = false;&#10;                }&#10;                &#10;                // En l'air&#10;                if (preserveJumpMomentum &amp;&amp; jumpMomentum.sqrMagnitude &gt; 0f)&#10;                {&#10;                    // Appliquer le momentum capturé au moment du saut&#10;                    horizontalVelocity = jumpMomentum;&#10;                    &#10;                    // Permettre un contrôle limité en l'air en PLUS du momentum&#10;                    if (desired.sqrMagnitude &gt; 0f)&#10;                    {&#10;                        horizontalVelocity += desired * CurrentSpeed * airControlFactor;&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    // Mouvement aérien sans momentum préservé&#10;                    horizontalVelocity = desired * CurrentSpeed * airControlFactor;&#10;                }&#10;            }&#10;&#10;            // Reset jump request si pas utilisé&#10;            jumpRequested = false;&#10;&#10;            // Traiter le momentum externe&#10;            ProcessExternalMomentum();&#10;            horizontalVelocity += new Vector3(externalMomentum.x, 0, externalMomentum.z);&#10;&#10;            // Appliquer la gravité seulement en l'air&#10;            if (!isGrounded)&#10;            {&#10;                velocity.y += gravity * gravityMultiplier * Time.fixedDeltaTime;&#10;                &#10;                // Limiter la vitesse de chute&#10;                if (velocity.y &lt; maxFallSpeed)&#10;                {&#10;                    velocity.y = maxFallSpeed;&#10;                }&#10;            }&#10;            &#10;            // Ajouter le momentum vertical externe&#10;            float verticalVelocity = velocity.y + externalMomentum.y;&#10;&#10;            // Appliquer la vélocité au Rigidbody (les collisions seront gérées automatiquement)&#10;            rb.linearVelocity = new Vector3(horizontalVelocity.x, verticalVelocity, horizontalVelocity.z);&#10;        }&#10;&#10;        private void HandleGroundCheck()&#10;        {&#10;            bool wasGrounded = isGrounded;&#10;            &#10;            // Créer un masque qui exclut le layer du joueur&#10;            int playerLayer = gameObject.layer;&#10;            int excludePlayerMask = ~(1 &lt;&lt; playerLayer);&#10;            &#10;            if (groundCheck != null)&#10;            {&#10;                // Utiliser groundMask si défini, sinon détecter tout sauf le joueur&#10;                if (groundMask != 0)&#10;                {&#10;                    isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);&#10;                }&#10;                else&#10;                {&#10;                    // Détecter tous les colliders sauf le joueur et les triggers&#10;                    isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, excludePlayerMask, QueryTriggerInteraction.Ignore);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Fallback: raycast vers le bas depuis le bas du collider&#10;                float rayLength = groundDistance + 0.1f;&#10;                Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;&#10;                &#10;                if (groundMask != 0)&#10;                {&#10;                    isGrounded = Physics.Raycast(rayOrigin, Vector3.down, rayLength, groundMask);&#10;                }&#10;                else&#10;                {&#10;                    // Détecter tous les colliders sauf le joueur et les triggers&#10;                    isGrounded = Physics.Raycast(rayOrigin, Vector3.down, rayLength, excludePlayerMask, QueryTriggerInteraction.Ignore);&#10;                }&#10;            }&#10;&#10;            // Gérer le coyote time&#10;            if (isGrounded)&#10;            {&#10;                coyoteTimeCounter = coyoteTime;&#10;                &#10;                // Réinitialiser la vélocité verticale au sol&#10;                if (velocity.y &lt; 0)&#10;                {&#10;                    velocity.y = 0f;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                coyoteTimeCounter -= Time.deltaTime;&#10;                &#10;                // Si on vient de quitter le sol naturellement (sans sauter), &#10;                // commencer avec une vélocité verticale nulle pour une chute progressive&#10;                if (wasGrounded &amp;&amp; velocity.y &lt;= 0)&#10;                {&#10;                    velocity.y = 0f;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void ProcessExternalMomentum()&#10;        {&#10;            if (externalMomentum.sqrMagnitude &lt;= 1e-4f)&#10;                return;&#10;&#10;            if (externalMomentumGroundTimer &gt; 0f)&#10;                externalMomentumGroundTimer -= Time.fixedDeltaTime;&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; externalMomentum.y &gt; 0f)&#10;                externalMomentum.y = 0f;&#10;&#10;            float damping = externalMomentumDamping;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f)&#10;                damping *= 1.5f;&#10;&#10;            if (damping &gt; 0f)&#10;            {&#10;                externalMomentum = Vector3.MoveTowards(externalMomentum, Vector3.zero, damping * Time.fixedDeltaTime);&#10;            }&#10;&#10;            if (isGrounded &amp;&amp; externalMomentumGroundTimer &lt;= 0f &amp;&amp; Mathf.Abs(externalMomentum.y) &lt; 0.01f)&#10;                externalMomentum.y = 0f;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Accès au Rigidbody pour les systèmes externes (Dash, etc.)&#10;        /// &lt;/summary&gt;&#10;        public Rigidbody Rb =&gt; rb;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSPlayerController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/FPSPlayerController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace FPS&#10;{&#10;    /// Contrôleur principal du joueur FPS &#10;    [RequireComponent(typeof(FPSInputHandler))]&#10;    [RequireComponent(typeof(FPSMovement))]&#10;    [RequireComponent(typeof(FPSMouseLook))]&#10;    public class FPSPlayerController : MonoBehaviour&#10;    {&#10;        private FPSInputHandler inputHandler;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private FPSCameraEffects cameraEffects;&#10;&#10;        private void Awake()&#10;        {&#10;            inputHandler = GetComponent&lt;FPSInputHandler&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            &#10;            if (mouseLook.CameraTransform != null)&#10;            {&#10;                cameraEffects = mouseLook.CameraTransform.GetComponent&lt;FPSCameraEffects&gt;();&#10;                if (cameraEffects == null)&#10;                {&#10;                    cameraEffects = mouseLook.CameraTransform.gameObject.AddComponent&lt;FPSCameraEffects&gt;();&#10;                }&#10;            }&#10;            &#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            // Récupérer les inputs&#10;            Vector2 moveInput = inputHandler.MoveInput;&#10;            Vector2 lookInput = inputHandler.LookInput;&#10;            bool jump = inputHandler.JumpPressed;&#10;            bool sprint = inputHandler.SprintPressed;&#10;            bool leanLeft = inputHandler.LeanLeftPressed;&#10;            bool leanRight = inputHandler.LeanRightPressed;&#10;&#10;            // Si le joueur est stun, neutraliser déplacement et actions mais laisser la caméra&#10;            var stun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            if (stun != null &amp;&amp; stun.IsStunned)&#10;            {&#10;                moveInput = Vector2.zero;&#10;                jump = false;&#10;                sprint = false;&#10;                leanLeft = false;&#10;                leanRight = false;&#10;            }&#10;&#10;            // Appliquer le mouvement&#10;            movement.Move(moveInput, sprint, jump);&#10;            &#10;            // Consommer le jump après utilisation&#10;            if (jump)&#10;            {&#10;                inputHandler.ConsumeJump();&#10;            }&#10;            &#10;            mouseLook.Look(lookInput, moveInput, leanLeft, leanRight);&#10;            &#10;            if (cameraEffects != null)&#10;            {&#10;                cameraEffects.UpdateEffects(&#10;                    movement.CurrentSpeed,&#10;                    movement.IsGrounded,&#10;                    sprint,&#10;                    movement.IsMoving&#10;                );&#10;            }&#10;        }&#10;&#10;        // Propriétés publiques pour compatibilité avec les autres systèmes&#10;        public Transform CameraTransform =&gt; mouseLook.CameraTransform;&#10;        public CharacterController Controller =&gt; movement.Controller;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;&#13;&#10;namespace FPS&#13;&#10;{&#13;&#10;    /// Contrôleur principal du joueur FPS &#13;&#10;    [RequireComponent(typeof(FPSInputHandler))]&#13;&#10;    [RequireComponent(typeof(FPSMovement))]&#13;&#10;    [RequireComponent(typeof(FPSMouseLook))]&#13;&#10;    public class FPSPlayerController : MonoBehaviour&#13;&#10;    {&#13;&#10;        private FPSInputHandler inputHandler;&#13;&#10;        private FPSMovement movement;&#13;&#10;        private FPSMouseLook mouseLook;&#13;&#10;        private FPSCameraEffects cameraEffects;&#13;&#10;&#13;&#10;        private void Awake()&#13;&#10;        {&#13;&#10;            inputHandler = GetComponent&lt;FPSInputHandler&gt;();&#13;&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#13;&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#13;&#10;            &#13;&#10;            if (mouseLook.CameraTransform != null)&#13;&#10;            {&#13;&#10;                cameraEffects = mouseLook.CameraTransform.GetComponent&lt;FPSCameraEffects&gt;();&#13;&#10;                if (cameraEffects == null)&#13;&#10;                {&#13;&#10;                    cameraEffects = mouseLook.CameraTransform.gameObject.AddComponent&lt;FPSCameraEffects&gt;();&#13;&#10;                }&#13;&#10;            }&#13;&#10;            &#13;&#10;        }&#13;&#10;&#13;&#10;        private void Update()&#13;&#10;        {&#13;&#10;            // Récupérer les inputs&#13;&#10;            Vector2 moveInput = inputHandler.MoveInput;&#13;&#10;            Vector2 lookInput = inputHandler.LookInput;&#13;&#10;            bool jump = inputHandler.JumpPressed;&#13;&#10;            bool sprint = inputHandler.SprintPressed;&#13;&#10;            bool leanLeft = inputHandler.LeanLeftPressed;&#13;&#10;            bool leanRight = inputHandler.LeanRightPressed;&#13;&#10;&#13;&#10;            // Si le joueur est stun, neutraliser déplacement et actions mais laisser la caméra&#13;&#10;            var stun = GetComponent&lt;PlayerStunAutoFire&gt;();&#13;&#10;            if (stun != null &amp;&amp; stun.IsStunned)&#13;&#10;            {&#13;&#10;                moveInput = Vector2.zero;&#13;&#10;                jump = false;&#13;&#10;                sprint = false;&#13;&#10;                leanLeft = false;&#13;&#10;                leanRight = false;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Appliquer le mouvement&#13;&#10;            movement.Move(moveInput, sprint, jump);&#13;&#10;            &#13;&#10;            // Consommer le jump après utilisation&#13;&#10;            if (jump)&#13;&#10;            {&#13;&#10;                inputHandler.ConsumeJump();&#13;&#10;            }&#13;&#10;            &#13;&#10;            mouseLook.Look(lookInput, moveInput, leanLeft, leanRight);&#13;&#10;            &#13;&#10;            if (cameraEffects != null)&#13;&#10;            {&#13;&#10;                cameraEffects.UpdateEffects(&#13;&#10;                    movement.CurrentSpeed,&#13;&#10;                    movement.IsGrounded,&#13;&#10;                    sprint,&#13;&#10;                    movement.IsMoving&#13;&#10;                );&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Propriétés publiques pour compatibilité avec les autres systèmes&#10;        public Transform CameraTransform =&gt; mouseLook.CameraTransform;&#10;        public Rigidbody Rb =&gt; movement.Rb;&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; Time.time &lt; 0.5f) // Fenêtre de 0.5s après le dash&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * currentSlideSpeed * Time.deltaTime;&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed * 0.6f);&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; dashSystem.isDashing)&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * (currentSlideSpeed * Time.deltaTime);&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * (currentSlideSpeed * 0.6f));&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/PlayerHealth.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/PlayerHealth.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    public class PlayerHealth : MonoBehaviour&#10;    {&#10;        [SerializeField] private SoundPlayer soundPlayer;&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Regeneration&quot;)]&#10;        [SerializeField] private bool enableRegen = true;&#10;        [SerializeField] private float regenDelay = 3f;&#10;        [SerializeField] private float regenRate = 5f;&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnHealthChanged;&#10;        public UnityEvent OnDeath;&#10;        &#10;        private float timeSinceLastDamage;&#10;        private bool isDead;&#10;        private bool isInvulnerable;&#10;        private DashCible dashCible;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            // Chercher DashCible sur cet objet, dans les enfants, ou dans les parents&#10;            dashCible = GetComponent&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = GetComponentInChildren&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = GetComponentInParent&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = FindFirstObjectByType&lt;DashCible&gt;();&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (enableRegen &amp;&amp; !isDead &amp;&amp; currentHealth &lt; maxHealth)&#10;            {&#10;                timeSinceLastDamage += Time.deltaTime;&#10;                &#10;                if (timeSinceLastDamage &gt;= regenDelay)&#10;                {&#10;                    Heal(regenRate * Time.deltaTime);&#10;                }&#10;            }&#10;        }&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            // Ignorer les dégâts si mort, invulnérable, ou en train de dasher&#10;            if (isDead || isInvulnerable) return;&#10;            if (dashCible != null &amp;&amp; dashCible.isDashing) return;&#10;&#10;            soundPlayer.PlayOneShot(&quot;OuchRoblox&quot;, 0.5f, Random.Range(0.9f, 1.1f));  &#10;&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            timeSinceLastDamage = 0f;&#10;            &#10;            OnHealthChanged?.Invoke(currentHealth / maxHealth);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;&#10;        public void Heal(float amount)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            currentHealth = Mathf.Min(maxHealth, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth / maxHealth);&#10;        }&#10;        &#10;        public void ResetHealth()&#10;        {&#10;            currentHealth = maxHealth;&#10;            isDead = false;&#10;            timeSinceLastDamage = 0f;&#10;            OnHealthChanged?.Invoke(1f);&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            Debug.Log(&quot;Player died!&quot;);&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public float HealthPercentage =&gt; currentHealth / maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public bool IsInvulnerable =&gt; isInvulnerable;&#10;&#10;        public void SetInvulnerable(bool invulnerable)&#10;        {&#10;            isInvulnerable = invulnerable;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace FPS&#10;{&#10;    public class PlayerHealth : MonoBehaviour&#10;    {&#10;        [SerializeField] private SoundPlayer soundPlayer;&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Regeneration&quot;)]&#10;        [SerializeField] private bool enableRegen = true;&#10;        [SerializeField] private float regenDelay = 3f;&#10;        [SerializeField] private float regenRate = 5f;&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent&lt;float&gt; OnHealthChanged;&#10;        public UnityEvent OnDeath;&#10;        &#10;        private float timeSinceLastDamage;&#10;        private bool isDead;&#10;        private bool isInvulnerable;&#10;        private DashCible dashCible;&#10;        private DashSystem dashSystem;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            // Chercher DashCible sur cet objet, dans les enfants, ou dans les parents&#10;            dashCible = GetComponent&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = GetComponentInChildren&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = GetComponentInParent&lt;DashCible&gt;();&#10;            if (dashCible == null)&#10;                dashCible = FindFirstObjectByType&lt;DashCible&gt;();&#10;            &#10;            // Chercher DashSystem de la même façon&#10;            dashSystem = GetComponent&lt;DashSystem&gt;();&#10;            if (dashSystem == null)&#10;                dashSystem = GetComponentInChildren&lt;DashSystem&gt;();&#10;            if (dashSystem == null)&#10;                dashSystem = GetComponentInParent&lt;DashSystem&gt;();&#10;            if (dashSystem == null)&#10;                dashSystem = FindFirstObjectByType&lt;DashSystem&gt;();&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Vérifie si le joueur est en train de dasher (avec l'un ou l'autre système)&#10;        /// &lt;/summary&gt;&#10;        private bool IsDashing()&#10;        {&#10;            if (dashCible != null &amp;&amp; dashCible.isDashing) return true;&#10;            if (dashSystem != null &amp;&amp; dashSystem.isDashing) return true;&#10;            return false;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            if (enableRegen &amp;&amp; !isDead &amp;&amp; currentHealth &lt; maxHealth)&#10;            {&#10;                timeSinceLastDamage += Time.deltaTime;&#10;                &#10;                if (timeSinceLastDamage &gt;= regenDelay)&#10;                {&#10;                    Heal(regenRate * Time.deltaTime);&#10;                }&#10;            }&#10;        }&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            // Ignorer les dégâts si mort, invulnérable, ou en train de dasher&#10;            if (isDead || isInvulnerable) return;&#10;            if (IsDashing()) return;&#10;&#10;            soundPlayer.PlayOneShot(&quot;OuchRoblox&quot;, 0.5f, Random.Range(0.9f, 1.1f));  &#10;&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            timeSinceLastDamage = 0f;&#10;            &#10;            OnHealthChanged?.Invoke(currentHealth / maxHealth);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;&#10;        public void Heal(float amount)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            currentHealth = Mathf.Min(maxHealth, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth / maxHealth);&#10;        }&#10;        &#10;        public void ResetHealth()&#10;        {&#10;            currentHealth = maxHealth;&#10;            isDead = false;&#10;            timeSinceLastDamage = 0f;&#10;            OnHealthChanged?.Invoke(1f);&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            Debug.Log(&quot;Player died!&quot;);&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public float HealthPercentage =&gt; currentHealth / maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public bool IsInvulnerable =&gt; isInvulnerable;&#10;&#10;        public void SetInvulnerable(bool invulnerable)&#10;        {&#10;            isInvulnerable = invulnerable;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_QUICKSTART.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_QUICKSTART.md" />
              <option name="updatedContent" value="# Slide System - Quick Start&#10;&#10;## Installation Rapide&#10;Le composant `Slide` est déjà configuré et prêt à l'emploi !&#10;&#10;## Contrôles&#10;- **Ctrl gauche** = Slider&#10;&#10;## Comment l'utiliser ?&#10;&#10;### Slide Basique&#10;1. Courez avec **WASD**&#10;2. Maintenez **Ctrl** pour slider&#10;3. Relâchez **Ctrl** pour vous relever&#10;&#10;### Combo Dash → Slide (Recommandé !)&#10;1. **Clic droit** pour dasher&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash = vitesse maximale !&#10;4. Vous pouvez traverser de très grandes distances&#10;&#10;### Astuces&#10;- Plus vous allez vite, plus le slide est long&#10;- Le slide décélère progressivement&#10;- Cooldown de 0.5s entre chaque slide&#10;- Maximum 2 secondes de slide&#10;- Ne fonctionne qu'au sol&#10;&#10;## Effets Visuels&#10;- Votre personnage s'abaisse&#10;- La caméra s'incline légèrement (5°)&#10;- Transitions fluides et smooth&#10;&#10;## Paramètres Clés (Inspector)&#10;- **Slide Speed** : 12 (vitesse de base)&#10;- **Speed Multiplier** : 1.3 (multiplie votre vitesse actuelle)&#10;- **Dash Momentum Multiplier** : 1.5 (après un dash)&#10;&#10;## C'est tout !&#10;Le système fonctionne automatiquement avec :&#10;- ✅ Le dash (synergie parfaite)&#10;- ✅ Le sprint&#10;- ✅ Le système de stun&#10;- ✅ Le saut (arrête le slide)&#10;&#10;Amusez-vous à enchaîner les combos de mouvement !&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md" />
              <option name="updatedContent" value="# Guide du Système de Slide&#10;&#10;## Vue d'ensemble&#10;Le système de slide permet au joueur de glisser au sol avec la touche **Ctrl** pour un gameplay dynamique et fluide. Il est conçu pour fonctionner en parfaite synergie avec le système de dash et le mouvement.&#10;&#10;## Contrôles&#10;- **Ctrl gauche** : Maintenir pour slider&#10;- Le slide suit la direction de votre mouvement (WASD) ou la direction de la caméra si vous ne bougez pas&#10;&#10;## Fonctionnalités Principales&#10;&#10;### 1. Démarrage du Slide&#10;- Appuyez sur **Ctrl** pendant que vous êtes au sol&#10;- Nécessite une vitesse minimale (configurable)&#10;- Le slide hérite de votre vitesse actuelle et la multiplie&#10;&#10;### 2. Synergie avec le Dash&#10;- Si vous slidez juste après un dash, le momentum est conservé et amplifié&#10;- Le multiplicateur de dash momentum permet des combos spectaculaires&#10;- Parfait pour enchaîner dash → slide pour traverser de grandes distances&#10;&#10;### 3. Physique du Slide&#10;- **Décélération progressive** : Le slide ralentit naturellement&#10;- **Vitesse minimale** : Le slide s'arrête si vous devenez trop lent&#10;- **Durée maximale** : 2 secondes par défaut pour équilibrer le gameplay&#10;- **Cooldown** : 0.5s entre chaque slide&#10;&#10;### 4. Effets Visuels&#10;- **Hauteur réduite** : Le CharacterController s'abaisse pendant le slide&#10;- **Inclinaison de caméra** : 5° d'inclinaison pour un effet dynamique&#10;- **Transitions smooth** : Toutes les transitions sont interpolées&#10;&#10;## Paramètres Configurables (Inspector)&#10;&#10;### Slide Settings&#10;- **Slide Speed** (12) : Vitesse de base du slide&#10;- **Speed Multiplier** (1.3) : Multiplie votre vitesse actuelle&#10;- **Slide Deceleration** (5) : Vitesse de ralentissement&#10;- **Min Slide Speed** (3) : Vitesse minimale pour continuer&#10;- **Max Slide Duration** (2) : Durée maximale en secondes&#10;- **Slide Cooldown** (0.5) : Temps entre chaque slide&#10;&#10;### Height Settings&#10;- **Slide Height** (1) : Hauteur du controller pendant le slide&#10;- **Height Transition Speed** (10) : Vitesse de transition de hauteur&#10;&#10;### Camera Settings&#10;- **Camera Tilt** (5) : Inclinaison en degrés&#10;- **Tilt Transition Speed** (8) : Vitesse de transition de l'inclinaison&#10;&#10;### Momentum Settings&#10;- **Inherit Dash Momentum** (true) : Hériter du momentum du dash&#10;- **Dash Momentum Multiplier** (1.5) : Multiplicateur du momentum hérité&#10;&#10;## Utilisation dans Unity&#10;&#10;### Configuration du Joueur&#10;1. Ajoutez le composant `Slide` à votre GameObject joueur&#10;2. Assurez-vous que les composants suivants sont présents :&#10;   - `CharacterController`&#10;   - `FPSMovement`&#10;   - `FPSMouseLook`&#10;   - `FPSInputHandler`&#10;   - `PillarDashSystem` (optionnel, pour la synergie)&#10;&#10;### Intégration dans le Code&#10;```csharp&#10;// Vérifier si le joueur peut slider&#10;Slide slideComponent = GetComponent&lt;Slide&gt;();&#10;if (slideComponent.CanSlide())&#10;{&#10;    // Le joueur peut slider&#10;}&#10;&#10;// Vérifier si le joueur est en train de slider&#10;if (slideComponent.IsSliding)&#10;{&#10;    // Le joueur slide actuellement&#10;}&#10;```&#10;&#10;## Mécaniques Avancées&#10;&#10;### Combo Dash → Slide&#10;1. Dashez avec clic droit vers un groupe d'ennemis&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash × 1.5&#10;4. Vous pouvez traverser de grandes distances à haute vitesse&#10;&#10;### Gestion du Momentum&#10;- Le slide conserve 60% du momentum à la fin pour une transition fluide&#10;- Le système `ApplyExternalMomentum()` assure une transition smooth avec le système de mouvement&#10;- Pas de téléportation ou de changement brusque de vitesse&#10;&#10;### Conditions d'Arrêt&#10;Le slide s'arrête automatiquement si :&#10;- Vous relâchez la touche **Ctrl**&#10;- La durée maximale est atteinte&#10;- Votre vitesse descend sous le minimum&#10;- Vous quittez le sol (saut ou chute)&#10;- Vous êtes stunné&#10;&#10;## Optimisation et Performance&#10;&#10;### Interpolations Smooth&#10;- Utilisation de `Mathf.Lerp` pour toutes les transitions&#10;- Évite les changements brusques qui pourraient causer du motion sickness&#10;- Les vitesses de transition sont configurables&#10;&#10;### Gestion de l'État&#10;- Le système vérifie automatiquement le stun&#10;- Intégration avec `PlayerStunAutoFire`&#10;- Désactivation automatique du slide pendant le stun&#10;&#10;## Conseils de Gameplay&#10;&#10;### Pour les Level Designers&#10;- Créez des pentes pour des slides spectaculaires&#10;- Placez des ennemis pour encourager les combos dash-slide&#10;- Utilisez le slide pour créer des shortcuts optionnels&#10;&#10;### Pour les Joueurs&#10;- Combinez sprint + slide pour une vitesse maximale&#10;- Utilisez le slide pour esquiver les projectiles&#10;- Le slide est parfait pour se repositionner rapidement&#10;- Dash → Slide → Saut = combo de mobilité ultime&#10;&#10;## Dépannage&#10;&#10;### Le slide ne démarre pas&#10;- Vérifiez que vous êtes au sol (`IsGrounded`)&#10;- Vérifiez que le cooldown est terminé&#10;- Vérifiez que vous n'êtes pas stunné&#10;- Vérifiez que vous avez une vitesse minimale&#10;&#10;### Le slide s'arrête trop vite&#10;- Augmentez `Min Slide Speed`&#10;- Réduisez `Slide Deceleration`&#10;- Augmentez `Max Slide Duration`&#10;&#10;### Transitions saccadées&#10;- Augmentez `Height Transition Speed`&#10;- Augmentez `Tilt Transition Speed`&#10;- Vérifiez que le framerate est stable&#10;&#10;## API Publique&#10;&#10;```csharp&#10;public class Slide : MonoBehaviour&#10;{&#10;    // Propriétés&#10;    public bool IsSliding { get; }  // Le joueur slide-t-il ?&#10;    &#10;    // Méthodes&#10;    public bool CanSlide();  // Le joueur peut-il slider ?&#10;}&#10;```&#10;&#10;## Notes Techniques&#10;&#10;### Synergie avec les Systèmes Existants&#10;- **FPSMovement** : Utilise `ApplyExternalMomentum()` pour le momentum&#10;- **FPSInputHandler** : Lit `MoveInput` pour la direction&#10;- **PillarDashSystem** : Vérifie `isDashing` pour hériter du momentum&#10;- **PlayerStunAutoFire** : Désactive le slide pendant le stun&#10;&#10;### Gestion de la Hauteur&#10;- Modifie dynamiquement `CharacterController.height` et `center`&#10;- Conserve les valeurs originales pour la restauration&#10;- Évite les problèmes de collision grâce aux transitions smooth&#10;&#10;### Performance&#10;- Aucun allocation mémoire pendant le slide&#10;- Utilisation optimale de `Vector3` et `Mathf`&#10;- Pas de coroutines, tout dans `Update()`&#10;&#10;## Améliorations Futures Possibles&#10;- Particules de poussière pendant le slide&#10;- Son de glissement&#10;- Trail renderer pour l'effet de vitesse&#10;- Bonus de vitesse sur certaines surfaces (glace, etc.)&#10;- Dégâts aux ennemis pendant le slide (comme le dash)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md" />
              <option name="updatedContent" value="# Résumé du Système de Slide&#10;&#10;##  Vue d'ensemble&#10;Système de slide activé avec **Ctrl** qui s'intègre parfaitement avec le dash et le système de mouvement pour créer un gameplay fluide et dynamique.&#10;&#10;## ✨ Caractéristiques Principales&#10;&#10;###  Contrôles&#10;- **Ctrl gauche (maintenu)** : Activer/maintenir le slide&#10;- Fonctionne uniquement au sol&#10;- Direction = mouvement actuel ou direction de la caméra&#10;&#10;### ⚡ Synergie avec le Dash&#10;- Hérite automatiquement du momentum du dash&#10;- Multiplicateur de 1.5x sur la vitesse du dash&#10;- Permet des combos dash → slide spectaculaires&#10;- Transition parfaitement smooth&#10;&#10;###  Physique du Slide&#10;- **Vitesse de base** : 12 unités/s&#10;- **Multiplicateur de vitesse** : 1.3x de votre vitesse actuelle&#10;- **Décélération** : 5 unités/s² (progressive et naturelle)&#10;- **Vitesse minimale** : 3 unités/s (arrêt automatique en dessous)&#10;- **Durée max** : 2 secondes&#10;- **Cooldown** : 0.5 secondes&#10;&#10;###  Effets Visuels&#10;- **Hauteur réduite** : CharacterController passe à 1 unité&#10;- **Inclinaison caméra** : 5° pour effet de vitesse&#10;- **Transitions smooth** : Interpolation Lerp sur tous les paramètres&#10;- Pas de téléportation ou changement brusque&#10;&#10;##  Architecture Technique&#10;&#10;### Composants Requis&#10;```&#10;GameObject Joueur&#10;├── CharacterController (Unity)&#10;├── FPSMovement (vitesse et momentum)&#10;├── FPSMouseLook (caméra)&#10;├── FPSInputHandler (inputs)&#10;├── PillarDashSystem (optionnel, pour synergie)&#10;└── Slide (nouveau composant) ✨&#10;```&#10;&#10;### Méthodes Publiques&#10;```csharp&#10;public bool IsSliding { get; }  // État actuel&#10;public bool CanSlide();         // Vérification de disponibilité&#10;```&#10;&#10;### Intégration avec Systèmes Existants&#10;- ✅ **FPSMovement** : `ApplyExternalMomentum()` pour momentum smooth&#10;- ✅ **PillarDashSystem** : Détection de `isDashing` pour héritage&#10;- ✅ **PlayerStunAutoFire** : Désactivation automatique pendant stun&#10;- ✅ **FPSInputHandler** : Lecture de `MoveInput` pour direction&#10;&#10;##  Conditions de Fonctionnement&#10;&#10;### Démarrage du Slide&#10;1. Joueur au sol (`IsGrounded`)&#10;2. Cooldown terminé (0.5s)&#10;3. Pas de stun actif&#10;4. Vitesse minimale atteinte OU mouvement actif&#10;5. Touche Ctrl maintenue&#10;&#10;### Arrêt du Slide&#10;- Touche Ctrl relâchée&#10;- Durée maximale atteinte (2s)&#10;- Vitesse trop faible (&lt; 3)&#10;- Joueur en l'air&#10;- Stun appliqué&#10;&#10;##  Flux de Gameplay&#10;&#10;### Combo Recommandé&#10;```&#10;1. Sprint (Shift) → Vitesse augmente&#10;2. Dash (Clic droit) → Vitesse maximale + kill ennemis&#10;3. Slide (Ctrl) → Hérite momentum × 1.5&#10;4. Transition smooth vers mouvement normal&#10;```&#10;&#10;### Gestion du Momentum&#10;```&#10;Début slide : Max(slideSpeed, currentSpeed × multiplier)&#10;Pendant slide : Décélération progressive&#10;Fin slide : Conservation de 60% du momentum&#10;→ Transition fluide sans rupture de vitesse&#10;```&#10;&#10;##  Paramètres Configurables&#10;&#10;| Paramètre | Valeur par défaut | Description |&#10;|-----------|-------------------|-------------|&#10;| Slide Speed | 12 | Vitesse de base |&#10;| Speed Multiplier | 1.3 | Multiplie vitesse actuelle |&#10;| Slide Deceleration | 5 | Ralentissement progressif |&#10;| Min Slide Speed | 3 | Seuil d'arrêt |&#10;| Max Slide Duration | 2 | Durée maximale (s) |&#10;| Slide Cooldown | 0.5 | Temps entre slides (s) |&#10;| Slide Height | 1 | Hauteur du controller |&#10;| Camera Tilt | 5 | Inclinaison (degrés) |&#10;| Dash Momentum Multiplier | 1.5 | Bonus après dash |&#10;&#10;##  Performance&#10;&#10;### Optimisations&#10;- ❌ Pas d'allocation mémoire pendant l'exécution&#10;- ❌ Pas de coroutines&#10;- ✅ Tout dans `Update()` avec early returns&#10;- ✅ Ordre de multiplication optimisé&#10;- ✅ Utilisation de propriétés cached&#10;&#10;### Garbage Collection&#10;- 0 allocation par frame&#10;- Références cached dans `Awake()`&#10;- Pas de `GetComponent()` dans `Update()`&#10;&#10;##  Documentation&#10;&#10;### Fichiers Créés&#10;- `Slide.cs` : Composant principal (280 lignes)&#10;- `SLIDE_SYSTEM_GUIDE.md` : Guide complet&#10;- `SLIDE_QUICKSTART.md` : Démarrage rapide&#10;- `SLIDE_SYSTEM_SUMMARY.md` : Ce fichier&#10;&#10;### Modifications Apportées&#10;- `FPSInputHandler.cs` : Ajout de `SprintPressed`&#10;&#10;##  Cas d'Usage&#10;&#10;### Level Design&#10;- Pentes pour slides spectaculaires&#10;- Zones de combat avec dash-slide combos&#10;- Shortcuts nécessitant maîtrise du momentum&#10;&#10;### Gameplay&#10;- Mobilité tactique en combat&#10;- Esquive de projectiles&#10;- Traversée rapide de maps&#10;- Combos de mouvement créatifs&#10;&#10;## ⚠️ Notes Importantes&#10;&#10;### Limitations&#10;- Fonctionne uniquement au sol&#10;- Pas de slide en l'air (arrêt automatique)&#10;- Cooldown impose un rythme&#10;- Durée max évite les abus&#10;&#10;### Compatibilité&#10;- Compatible avec tous les systèmes FPS existants&#10;- Pas d'impact sur les autres mécaniques&#10;- Peut être désactivé sans casser le jeu&#10;&#10;##  Extensions Possibles&#10;&#10;### Améliorations Futures&#10;- Particules de poussière/friction&#10;- Son de glissement dynamique&#10;- Trail renderer pour effet de vitesse&#10;- Surfaces spéciales (glace = moins de friction)&#10;- Dégâts aux ennemis pendant le slide&#10;- Animation du personnage&#10;- Shake de caméra proportionnel à la vitesse&#10;&#10;### API Extensible&#10;Le système est conçu pour être facilement étendu :&#10;- Méthode `CanSlide()` pour conditions custom&#10;- Events possibles (OnSlideStart, OnSlideEnd)&#10;- Paramètres exposés dans l'inspector&#10;&#10;## ✅ Status&#10;- [x] Implémentation complète&#10;- [x] Intégration avec systèmes existants&#10;- [x] Documentation complète&#10;- [x] Tests de compilation OK&#10;- [x] Optimisations appliquées&#10;- [x] Guides utilisateur créés&#10;&#10;**Le système est prêt à l'emploi !** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>