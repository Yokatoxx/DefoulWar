<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Ennemies/Effect/ElectricEnnemis.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Ennemies/Effect/ElectricEnnemis.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Proto3GD.FPS;&#10;&#10;namespace Ennemies.Effect&#10;{&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class ElectricEnnemis : MonoBehaviour&#10;    {&#10;        [Header(&quot;Effet appliqué au joueur si ce PNJ est touché par un dash&quot;)]&#10;        [SerializeField] private float stunDuration = 2.5f;&#10;&#10;        [Header(&quot;Auto-fire pendant le stun (override optionnel)&quot;)]&#10;        [Tooltip(&quot;Si activé, remplace l'intervalle d'auto-fire du joueur pendant ce stun.&quot;)]&#10;        [SerializeField] private bool overrideAutoFireInterval = false;&#10;        [SerializeField, Min(0.01f)] private float stunAutoFireInterval = 0.12f;&#10;&#10;        [Header(&quot;Dégâts électriques aux ennemis proches&quot;)]&#10;        [Tooltip(&quot;Rayon de la décharge électrique quand l'ennemi est touché par un tir.&quot;)]&#10;        [SerializeField] private float electricDischargeRadius = 5f;&#10;        [Tooltip(&quot;Dégâts infligés aux ennemis dans le rayon de décharge.&quot;)]&#10;        [SerializeField] private float electricDamage = 15f;&#10;        [Tooltip(&quot;Effet visuel de décharge (optionnel).&quot;)]&#10;        [SerializeField] private GameObject electricEffectPrefab;&#10;        [Tooltip(&quot;Durée de l'effet visuel en secondes.&quot;)]&#10;        [SerializeField] private float effectDuration = 0.5f;&#10;        [Tooltip(&quot;Temps minimum entre deux décharges (en secondes).&quot;)]&#10;        [SerializeField] private float dischargeCooldown = 0.2f;&#10;&#10;        private EnemyHealth health;&#10;        private static readonly Collider[] DischargeBuffer = new Collider[32];&#10;        private float lastDischargeTime = -999f;&#10;&#10;        private void Awake()&#10;        {&#10;            health = GetComponent&lt;EnemyHealth&gt;();&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.AddListener(OnDeath);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.RemoveListener(OnDeath);&#10;            }&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            // Déclencher la décharge électrique à la mort&#10;            TriggerElectricDischarge();&#10;        }&#10;&#10;        // Méthode publique pour déclencher manuellement la décharge (ex: quand touché)&#10;        public void TriggerElectricDischarge()&#10;        {&#10;            if (electricDischargeRadius &lt;= 0f || electricDamage &lt;= 0f) return;&#10;&#10;            // Trouver tous les colliders dans le rayon&#10;            int count = Physics.OverlapSphereNonAlloc(transform.position, electricDischargeRadius, DischargeBuffer);&#10;            &#10;            int enemiesHit = 0;&#10;&#10;            for (int i = 0; i &lt; count; i++)&#10;            {&#10;                var col = DischargeBuffer[i];&#10;                if (col == null) continue;&#10;&#10;                // Infliger des dégâts aux ennemis - chercher dans le parent aussi&#10;                var enemyHealth = col.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth == null)&#10;                {&#10;                    enemyHealth = col.GetComponentInParent&lt;EnemyHealth&gt;();&#10;                }&#10;                &#10;                // Ne pas se toucher soi-même&#10;                if (enemyHealth != null &amp;&amp; enemyHealth != this.health &amp;&amp; !enemyHealth.IsDead)&#10;                {&#10;                    enemyHealth.TakeDamage(electricDamage, &quot;Electric&quot;);&#10;                    enemiesHit++;&#10;                    &#10;                    // Optionnel: Créer un effet visuel entre cet ennemi et la cible&#10;                    if (electricEffectPrefab != null)&#10;                    {&#10;                        CreateElectricArc(enemyHealth.transform.position);&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Debug.Log($&quot;[ElectricEnnemis] Décharge électrique: {enemiesHit} ennemis touchés sur {count} colliders détectés&quot;);&#10;&#10;            // Créer l'effet principal au centre&#10;            if (electricEffectPrefab != null)&#10;            {&#10;                GameObject effect = Instantiate(electricEffectPrefab, transform.position, Quaternion.identity);&#10;                Destroy(effect, effectDuration);&#10;            }&#10;        }&#10;&#10;        private void CreateElectricArc(Vector3 targetPosition)&#10;        {&#10;            if (electricEffectPrefab == null) return;&#10;&#10;            Vector3 midPoint = (transform.position + targetPosition) / 2f;&#10;            Vector3 direction = targetPosition - transform.position;&#10;            &#10;            GameObject arc = Instantiate(electricEffectPrefab, midPoint, Quaternion.LookRotation(direction));&#10;            &#10;            // Ajuster l'échelle en fonction de la distance&#10;            float distance = direction.magnitude;&#10;            arc.transform.localScale = new Vector3(1f, 1f, distance);&#10;            &#10;            Destroy(arc, effectDuration);&#10;        }&#10;&#10;        public float StunDuration =&gt; stunDuration;&#10;        public bool OverrideAutoFireInterval =&gt; overrideAutoFireInterval;&#10;        public float StunAutoFireInterval =&gt; stunAutoFireInterval;&#10;        public float ElectricDischargeRadius =&gt; electricDischargeRadius;&#10;        public float ElectricDamage =&gt; electricDamage;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Proto3GD.FPS;&#10;&#10;namespace Ennemies.Effect&#10;{&#10;    [RequireComponent(typeof(EnemyHealth))]&#10;    public class ElectricEnnemis : MonoBehaviour&#10;    {&#10;        [Header(&quot;Effet appliqué au joueur si ce PNJ est touché par un dash&quot;)]&#10;        [SerializeField] private float stunDuration = 2.5f;&#10;&#10;        [Header(&quot;Auto-fire pendant le stun (override optionnel)&quot;)]&#10;        [Tooltip(&quot;Si activé, remplace l'intervalle d'auto-fire du joueur pendant ce stun.&quot;)]&#10;        [SerializeField] private bool overrideAutoFireInterval = false;&#10;        [SerializeField, Min(0.01f)] private float stunAutoFireInterval = 0.12f;&#10;&#10;        [Header(&quot;Dégâts électriques aux ennemis proches&quot;)]&#10;        [Tooltip(&quot;Rayon de la décharge électrique quand l'ennemi est touché par un tir.&quot;)]&#10;        [SerializeField] private float electricDischargeRadius = 5f;&#10;        [Tooltip(&quot;Dégâts infligés aux ennemis dans le rayon de décharge.&quot;)]&#10;        [SerializeField] private float electricDamage = 15f;&#10;        [Tooltip(&quot;Effet visuel de décharge (optionnel).&quot;)]&#10;        [SerializeField] private GameObject electricEffectPrefab;&#10;        [Tooltip(&quot;Durée de l'effet visuel en secondes.&quot;)]&#10;        [SerializeField] private float effectDuration = 0.5f;&#10;        [Tooltip(&quot;Temps minimum entre deux décharges (en secondes).&quot;)]&#10;        [SerializeField] private float dischargeCooldown = 0.2f;&#10;&#10;        private EnemyHealth health;&#10;        private static readonly Collider[] DischargeBuffer = new Collider[32];&#10;        private float lastDischargeTime = -999f;&#10;&#10;        private void Awake()&#10;        {&#10;            health = GetComponent&lt;EnemyHealth&gt;();&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.AddListener(OnDeath);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (health != null)&#10;            {&#10;                health.OnDeath.RemoveListener(OnDeath);&#10;            }&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            // Déclencher la décharge électrique à la mort&#10;            TriggerElectricDischarge();&#10;        }&#10;&#10;        // Méthode publique pour déclencher manuellement la décharge (ex: quand touché)&#10;        public void TriggerElectricDischarge()&#10;        {&#10;            if (electricDischargeRadius &lt;= 0f || electricDamage &lt;= 0f) return;&#10;            &#10;            // Vérifier le cooldown pour éviter les décharges trop rapides&#10;            if (Time.time - lastDischargeTime &lt; dischargeCooldown)&#10;            {&#10;                return;&#10;            }&#10;            &#10;            lastDischargeTime = Time.time;&#10;&#10;            // Trouver tous les colliders dans le rayon&#10;            int count = Physics.OverlapSphereNonAlloc(transform.position, electricDischargeRadius, DischargeBuffer);&#10;            &#10;            int enemiesHit = 0;&#10;&#10;            for (int i = 0; i &lt; count; i++)&#10;            {&#10;                var col = DischargeBuffer[i];&#10;                if (col == null) continue;&#10;&#10;                // Infliger des dégâts aux ennemis - chercher dans le parent aussi&#10;                var enemyHealth = col.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth == null)&#10;                {&#10;                    enemyHealth = col.GetComponentInParent&lt;EnemyHealth&gt;();&#10;                }&#10;                &#10;                // Ne pas se toucher soi-même&#10;                if (enemyHealth != null &amp;&amp; enemyHealth != this.health &amp;&amp; !enemyHealth.IsDead)&#10;                {&#10;                    enemyHealth.TakeDamage(electricDamage, &quot;Electric&quot;);&#10;                    enemiesHit++;&#10;                    &#10;                    // Optionnel: Créer un effet visuel entre cet ennemi et la cible&#10;                    if (electricEffectPrefab != null)&#10;                    {&#10;                        CreateElectricArc(enemyHealth.transform.position);&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Debug.Log($&quot;[ElectricEnnemis] Décharge électrique: {enemiesHit} ennemis touchés sur {count} colliders détectés&quot;);&#10;&#10;            // Créer l'effet principal au centre&#10;            if (electricEffectPrefab != null)&#10;            {&#10;                GameObject effect = Instantiate(electricEffectPrefab, transform.position, Quaternion.identity);&#10;                Destroy(effect, effectDuration);&#10;            }&#10;        }&#10;&#10;        private void CreateElectricArc(Vector3 targetPosition)&#10;        {&#10;            if (electricEffectPrefab == null) return;&#10;&#10;            Vector3 midPoint = (transform.position + targetPosition) / 2f;&#10;            Vector3 direction = targetPosition - transform.position;&#10;            &#10;            GameObject arc = Instantiate(electricEffectPrefab, midPoint, Quaternion.LookRotation(direction));&#10;            &#10;            // Ajuster l'échelle en fonction de la distance&#10;            float distance = direction.magnitude;&#10;            arc.transform.localScale = new Vector3(1f, 1f, distance);&#10;            &#10;            Destroy(arc, effectDuration);&#10;        }&#10;&#10;        public float StunDuration =&gt; stunDuration;&#10;        public bool OverrideAutoFireInterval =&gt; overrideAutoFireInterval;&#10;        public float StunAutoFireInterval =&gt; stunAutoFireInterval;&#10;        public float ElectricDischargeRadius =&gt; electricDischargeRadius;&#10;        public float ElectricDamage =&gt; electricDamage;&#10;&#10;        // Visualiser le rayon de décharge dans l'éditeur&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            Gizmos.color = new Color(0f, 1f, 1f, 0.3f); // Cyan transparent&#10;            Gizmos.DrawWireSphere(transform.position, electricDischargeRadius);&#10;            Gizmos.color = new Color(0f, 1f, 1f, 0.1f);&#10;            Gizmos.DrawSphere(transform.position, electricDischargeRadius);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/EnemyHealth.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/EnemyHealth.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Gère la santé de l'ennemi avec zones de dégâts et tracking des hits.&#10;&#10;    public class EnemyHealth : MonoBehaviour&#10;    {&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Hit Tracking&quot;)]&#10;        [SerializeField] private Dictionary&lt;string, int&gt; zoneHitCount = new Dictionary&lt;string, int&gt;();&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent OnDeath;&#10;        &#10;        private bool isDead;&#10;        private WaveManager waveManager;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;        }&#10;        &#10;        private void EnsureWaveManager()&#10;        {&#10;            if (waveManager == null)&#10;            {&#10;                waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;            }&#10;        }&#10;        &#10;        // Inflige des dégâts à l'ennemi et enregistre la zone touchée.&#10;        public void TakeDamage(float damage, string zoneName)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            currentHealth -= damage;&#10;            &#10;            // Enregistrer le hit dans la zone&#10;            if (!zoneHitCount.ContainsKey(zoneName))&#10;            {&#10;                zoneHitCount[zoneName] = 0;&#10;            }&#10;            zoneHitCount[zoneName]++;&#10;            &#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.RecordHit(zoneName);&#10;            }&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            if (isDead) return;&#10;            &#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            &#10;            // Notifier le wave manager qu'un ennemi est mort&#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.OnEnemyDeath(this);&#10;            }&#10;            &#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;        &#10;&#10;        // Applique des armures&#10;&#10;        public void ApplyArmorToZones(List&lt;string&gt; zoneNames)&#10;        {&#10;            var levels = new Dictionary&lt;string, int&gt;();&#10;            foreach (var z in zoneNames)&#10;            {&#10;                levels[z] = 1;&#10;            }&#10;            ApplyArmorLevels(levels);&#10;        }&#10;        &#10;&#10;        // Applique des niveaux d'armure par zone&#10;&#10;        public void ApplyArmorLevels(Dictionary&lt;string, int&gt; zoneLevels)&#10;        {&#10;            HitZone[] hitZones = GetComponentsInChildren&lt;HitZone&gt;();&#10;            foreach (HitZone zone in hitZones)&#10;            {&#10;                string key = NormalizeZoneKey(zone.ZoneName);&#10;                if (zoneLevels != null &amp;&amp; zoneLevels.TryGetValue(key, out int level))&#10;                {&#10;                    zone.SetArmorLevel(level);&#10;                }&#10;                else&#10;                {&#10;                    zone.RemoveArmor();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private static string NormalizeZoneKey(string zone)&#10;        {&#10;            return string.IsNullOrWhiteSpace(zone) ? string.Empty : zone.Trim().ToLowerInvariant();&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public Dictionary&lt;string, int&gt; ZoneHitCount =&gt; zoneHitCount;&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            TakeDamage(damage, &quot;Body&quot;);&#10;        }&#10;        &#10;&#10;        // Tue immédiatement cet ennemi sans enregistrer de hit&#10;&#10;        public void KillImmediate()&#10;        {&#10;            if (isDead) return;&#10;            currentHealth = 0f;&#10;            Die();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Gère la santé de l'ennemi avec zones de dégâts et tracking des hits.&#10;&#10;    public class EnemyHealth : MonoBehaviour&#10;    {&#10;        [Header(&quot;Health Settings&quot;)]&#10;        [SerializeField] private float maxHealth = 100f;&#10;        [SerializeField] private float currentHealth;&#10;        &#10;        [Header(&quot;Hit Tracking&quot;)]&#10;        [SerializeField] private Dictionary&lt;string, int&gt; zoneHitCount = new Dictionary&lt;string, int&gt;();&#10;        &#10;        [Header(&quot;Events&quot;)]&#10;        public UnityEvent OnDeath;&#10;        &#10;        private bool isDead;&#10;        private WaveManager waveManager;&#10;        &#10;        private void Awake()&#10;        {&#10;            currentHealth = maxHealth;&#10;            waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;        }&#10;        &#10;        private void EnsureWaveManager()&#10;        {&#10;            if (waveManager == null)&#10;            {&#10;                waveManager = FindFirstObjectByType&lt;WaveManager&gt;();&#10;            }&#10;        }&#10;        &#10;        // Inflige des dégâts à l'ennemi et enregistre la zone touchée.&#10;        public void TakeDamage(float damage, string zoneName)&#10;        {&#10;            if (isDead) return;&#10;            &#10;            currentHealth -= damage;&#10;            &#10;            // Enregistrer le hit dans la zone&#10;            if (!zoneHitCount.ContainsKey(zoneName))&#10;            {&#10;                zoneHitCount[zoneName] = 0;&#10;            }&#10;            zoneHitCount[zoneName]++;&#10;            &#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.RecordHit(zoneName);&#10;            }&#10;            &#10;            // Déclencher l'effet électrique si c'est un ennemi électrique&#10;            // mais seulement si les dégâts ne viennent pas déjà d'une décharge électrique&#10;            if (zoneName != &quot;Electric&quot;)&#10;            {&#10;                var electricEnemy = GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                if (electricEnemy != null)&#10;                {&#10;                    electricEnemy.TriggerElectricDischarge();&#10;                }&#10;            }&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                Die();&#10;            }&#10;        }&#10;        &#10;        private void Die()&#10;        {&#10;            if (isDead) return;&#10;            &#10;            isDead = true;&#10;            OnDeath?.Invoke();&#10;            &#10;            // Notifier le wave manager qu'un ennemi est mort&#10;            EnsureWaveManager();&#10;            if (waveManager != null)&#10;            {&#10;                waveManager.OnEnemyDeath(this);&#10;            }&#10;            &#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;        &#10;&#10;        // Applique des armures&#10;&#10;        public void ApplyArmorToZones(List&lt;string&gt; zoneNames)&#10;        {&#10;            var levels = new Dictionary&lt;string, int&gt;();&#10;            foreach (var z in zoneNames)&#10;            {&#10;                levels[z] = 1;&#10;            }&#10;            ApplyArmorLevels(levels);&#10;        }&#10;        &#10;&#10;        // Applique des niveaux d'armure par zone&#10;&#10;        public void ApplyArmorLevels(Dictionary&lt;string, int&gt; zoneLevels)&#10;        {&#10;            HitZone[] hitZones = GetComponentsInChildren&lt;HitZone&gt;();&#10;            foreach (HitZone zone in hitZones)&#10;            {&#10;                string key = NormalizeZoneKey(zone.ZoneName);&#10;                if (zoneLevels != null &amp;&amp; zoneLevels.TryGetValue(key, out int level))&#10;                {&#10;                    zone.SetArmorLevel(level);&#10;                }&#10;                else&#10;                {&#10;                    zone.RemoveArmor();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private static string NormalizeZoneKey(string zone)&#10;        {&#10;            return string.IsNullOrWhiteSpace(zone) ? string.Empty : zone.Trim().ToLowerInvariant();&#10;        }&#10;        &#10;        public float CurrentHealth =&gt; currentHealth;&#10;        public float MaxHealth =&gt; maxHealth;&#10;        public bool IsDead =&gt; isDead;&#10;        public Dictionary&lt;string, int&gt; ZoneHitCount =&gt; zoneHitCount;&#10;        &#10;        public void TakeDamage(float damage)&#10;        {&#10;            TakeDamage(damage, &quot;Body&quot;);&#10;        }&#10;        &#10;&#10;        // Tue immédiatement cet ennemi sans enregistrer de hit&#10;&#10;        public void KillImmediate()&#10;        {&#10;            if (isDead) return;&#10;            currentHealth = 0f;&#10;            Die();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/Player/Slide.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;&#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; Time.time &lt; 0.5f) // Fenêtre de 0.5s après le dash&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * currentSlideSpeed * Time.deltaTime;&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed * 0.6f);&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gère le système de slide du joueur avec la touche Ctrl&#10;    /// Fonctionne en synergie avec le dash et le système de vitesse&#10;    /// &lt;/summary&gt;&#10;    public class Slide : MonoBehaviour&#10;    {&#10;        [Header(&quot;Slide Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Vitesse de base du slide&quot;)]&#10;        private float slideSpeed = 12f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur de la vitesse actuelle du joueur pendant le slide&quot;)]&#10;        private float speedMultiplier = 1.3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Décélération progressive du slide&quot;)]&#10;        private float slideDeceleration = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse minimale pour maintenir le slide&quot;)]&#10;        private float minSlideSpeed = 3f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Durée maximale du slide en secondes&quot;)]&#10;        private float maxSlideDuration = 2f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Cooldown entre chaque slide en secondes&quot;)]&#10;        private float slideCooldown = 0.5f;&#10;        &#10;        [Header(&quot;Height Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Hauteur du CharacterController pendant le slide&quot;)]&#10;        private float slideHeight = 1f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de la hauteur&quot;)]&#10;        private float heightTransitionSpeed = 10f;&#10;        &#10;        [Header(&quot;Camera Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Inclinaison de la caméra pendant le slide (en degrés)&quot;)]&#10;        private float cameraTilt = 5f;&#10;        &#10;        [SerializeField, Tooltip(&quot;Vitesse de transition de l'inclinaison&quot;)]&#10;        private float tiltTransitionSpeed = 8f;&#10;        &#10;        [Header(&quot;Momentum Settings&quot;)]&#10;        [SerializeField, Tooltip(&quot;Conserver le momentum après le dash dans le slide&quot;)]&#10;        private bool inheritDashMomentum = true;&#10;        &#10;        [SerializeField, Tooltip(&quot;Multiplicateur du momentum du dash&quot;)]&#10;        private float dashMomentumMultiplier = 1.5f;&#10;        &#10;        // Références&#10;        private CharacterController controller;&#10;        private FPSMovement movement;&#10;        private FPSMouseLook mouseLook;&#10;        private Camera playerCamera;&#10;        private PillarDashSystem dashSystem;&#10;        &#10;        // État du slide&#10;        private bool isSliding;&#10;        private float slideTimer;&#10;        private float cooldownTimer;&#10;        private Vector3 slideDirection;&#10;        private float currentSlideSpeed;&#10;        &#10;        // État initial&#10;        private float originalHeight;&#10;        private Vector3 originalCenter;&#10;        private float targetHeight;&#10;        private float targetCenterY;&#10;        private float targetTilt;&#10;        &#10;        public bool IsSliding =&gt; isSliding;&#10;        &#10;        private void Awake()&#10;        {&#10;            controller = GetComponent&lt;CharacterController&gt;();&#10;            movement = GetComponent&lt;FPSMovement&gt;();&#10;            mouseLook = GetComponent&lt;FPSMouseLook&gt;();&#10;            dashSystem = GetComponent&lt;PillarDashSystem&gt;();&#10;            &#10;            if (controller != null)&#10;            {&#10;                originalHeight = controller.height;&#10;                originalCenter = controller.center;&#10;            }&#10;            &#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (mouseLook != null &amp;&amp; mouseLook.CameraTransform != null)&#10;            {&#10;                playerCamera = mouseLook.CameraTransform.GetComponent&lt;Camera&gt;();&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown&#10;            if (cooldownTimer &gt; 0f)&#10;            {&#10;                cooldownTimer -= Time.deltaTime;&#10;            }&#10;            &#10;            // Vérifier si le joueur est stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            if (isSliding)&#10;            {&#10;                HandleSlide();&#10;            }&#10;            else&#10;            {&#10;                // Démarrer le slide avec Ctrl gauche&#10;                bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;                bool canSlide = movement.IsGrounded &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; !isStunned;&#10;                &#10;                // Vérifier qu'on a une vitesse minimale ou qu'on bouge&#10;                bool hasSpeed = movement.CurrentSpeed &gt; minSlideSpeed || movement.IsMoving;&#10;                &#10;                if (slideInput &amp;&amp; canSlide &amp;&amp; hasSpeed)&#10;                {&#10;                    StartSlide();&#10;                }&#10;            }&#10;            &#10;            // Mise à jour de la hauteur et inclinaison&#10;            UpdateHeight();&#10;            UpdateCameraTilt();&#10;        }&#10;        &#10;        private void StartSlide()&#10;        {&#10;            isSliding = true;&#10;            slideTimer = 0f;&#10;            &#10;            // Déterminer la direction du slide&#10;            Vector2 moveInput = GetComponent&lt;FPSInputHandler&gt;().MoveInput;&#10;            &#10;            if (moveInput.sqrMagnitude &gt; 0.01f)&#10;            {&#10;                // Slide dans la direction du mouvement&#10;                slideDirection = (transform.right * moveInput.x + transform.forward * moveInput.y).normalized;&#10;            }&#10;            else&#10;            {&#10;                // Slide dans la direction où regarde le joueur&#10;                slideDirection = transform.forward;&#10;            }&#10;            &#10;            // Calculer la vitesse initiale du slide&#10;            currentSlideSpeed = slideSpeed;&#10;            &#10;            // Si on vient de dasher, hériter du momentum&#10;            if (inheritDashMomentum &amp;&amp; dashSystem != null &amp;&amp; dashSystem.isDashing)&#10;            {&#10;                currentSlideSpeed = Mathf.Max(currentSlideSpeed, movement.CurrentSpeed * dashMomentumMultiplier);&#10;            }&#10;            else&#10;            {&#10;                // Sinon, multiplier la vitesse actuelle&#10;                currentSlideSpeed = Mathf.Max(slideSpeed, movement.CurrentSpeed * speedMultiplier);&#10;            }&#10;            &#10;            // Ajuster la hauteur du contrôleur&#10;            targetHeight = slideHeight;&#10;            targetCenterY = slideHeight / 2f;&#10;            &#10;            // Inclinaison de la caméra&#10;            targetTilt = cameraTilt;&#10;        }&#10;        &#10;        private void HandleSlide()&#10;        {&#10;            slideTimer += Time.deltaTime;&#10;            &#10;            // Vérifier les conditions d'arrêt&#10;            bool slideInput = Input.GetKey(KeyCode.LeftControl);&#10;            bool shouldStop = false;&#10;            &#10;            // Arrêter si on lâche la touche&#10;            if (!slideInput)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on a dépassé la durée maximale&#10;            if (slideTimer &gt;= maxSlideDuration)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si la vitesse est trop faible&#10;            if (currentSlideSpeed &lt; minSlideSpeed)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            // Arrêter si on n'est plus au sol&#10;            if (!movement.IsGrounded)&#10;            {&#10;                shouldStop = true;&#10;            }&#10;            &#10;            if (shouldStop)&#10;            {&#10;                EndSlide();&#10;                return;&#10;            }&#10;            &#10;            // Appliquer la décélération&#10;            currentSlideSpeed = Mathf.Max(minSlideSpeed, currentSlideSpeed - slideDeceleration * Time.deltaTime);&#10;            &#10;            // Appliquer le mouvement du slide&#10;            Vector3 slideMovement = slideDirection * (currentSlideSpeed * Time.deltaTime);&#10;            controller.Move(slideMovement);&#10;            &#10;            // Appliquer le momentum au système de mouvement pour une transition smooth&#10;            movement.ApplyExternalMomentum(slideDirection * currentSlideSpeed);&#10;        }&#10;        &#10;        private void EndSlide()&#10;        {&#10;            isSliding = false;&#10;            cooldownTimer = slideCooldown;&#10;            &#10;            // Rétablir la hauteur normale&#10;            targetHeight = originalHeight;&#10;            targetCenterY = originalCenter.y;&#10;            &#10;            // Rétablir l'inclinaison de la caméra&#10;            targetTilt = 0f;&#10;            &#10;            // Conserver un peu de momentum pour une transition fluide&#10;            if (currentSlideSpeed &gt; movement.CurrentSpeed)&#10;            {&#10;                movement.ApplyExternalMomentum(slideDirection * (currentSlideSpeed * 0.6f));&#10;            }&#10;        }&#10;        &#10;        private void UpdateHeight()&#10;        {&#10;            if (controller == null) return;&#10;            &#10;            // Interpolation smooth de la hauteur&#10;            float newHeight = Mathf.Lerp(controller.height, targetHeight, Time.deltaTime * heightTransitionSpeed);&#10;            float newCenterY = Mathf.Lerp(controller.center.y, targetCenterY, Time.deltaTime * heightTransitionSpeed);&#10;            &#10;            controller.height = newHeight;&#10;            controller.center = new Vector3(originalCenter.x, newCenterY, originalCenter.z);&#10;        }&#10;        &#10;        private void UpdateCameraTilt()&#10;        {&#10;            if (playerCamera == null) return;&#10;            &#10;            // Interpolation smooth de l'inclinaison&#10;            float currentTilt = playerCamera.transform.localEulerAngles.z;&#10;            if (currentTilt &gt; 180f) currentTilt -= 360f;&#10;            &#10;            float newTilt = Mathf.Lerp(currentTilt, targetTilt, Time.deltaTime * tiltTransitionSpeed);&#10;            &#10;            Vector3 euler = playerCamera.transform.localEulerAngles;&#10;            euler.z = newTilt;&#10;            playerCamera.transform.localEulerAngles = euler;&#10;        }&#10;        &#10;        // Méthode publique pour vérifier si on peut slider (utilisable par d'autres systèmes)&#10;        public bool CanSlide()&#10;        {&#10;            return !isSliding &amp;&amp; cooldownTimer &lt;= 0f &amp;&amp; movement.IsGrounded;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DEBUG_ELECTRIC_ENEMY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DEBUG_ELECTRIC_ENEMY.md" />
              <option name="updatedContent" value="# Debug - Système de Décharge Électrique&#10;&#10;## Problème Identifié&#10;Les ennemis autour ne prennent pas de dégâts lors de la décharge électrique.&#10;&#10;## Solutions Implémentées&#10;&#10;### 1. Recherche du Composant EnemyHealth&#10;Le code cherche maintenant l'EnemyHealth de deux façons :&#10;- `GetComponent&lt;EnemyHealth&gt;()` - sur le collider directement&#10;- `GetComponentInParent&lt;EnemyHealth&gt;()` - sur le parent si pas trouvé sur le collider&#10;&#10;### 2. Vérification de l'Ennemi Source&#10;Le code vérifie que l'ennemi touché n'est pas l'ennemi source lui-même :&#10;```csharp&#10;if (enemyHealth != null &amp;&amp; enemyHealth != this.health &amp;&amp; !enemyHealth.IsDead)&#10;```&#10;&#10;### 3. Cooldown Anti-Boucle&#10;Un cooldown de 0.2s empêche les décharges trop rapprochées qui pourraient créer des boucles infinies.&#10;&#10;### 4. Protection Contre les Boucles Infinies&#10;Dans `EnemyHealth.cs`, la décharge ne se déclenche que si les dégâts ne viennent pas déjà d'une décharge électrique :&#10;```csharp&#10;if (zoneName != &quot;Electric&quot;)&#10;{&#10;    var electricEnemy = GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;    if (electricEnemy != null)&#10;    {&#10;        electricEnemy.TriggerElectricDischarge();&#10;    }&#10;}&#10;```&#10;&#10;## Comment Déboguer&#10;&#10;### 1. Vérifier les Logs Console&#10;Quand vous tirez sur un ennemi électrique, vous devriez voir dans la console :&#10;```&#10;[ElectricEnnemis] Décharge électrique: X ennemis touchés sur Y colliders détectés&#10;```&#10;&#10;Si vous voyez &quot;0 ennemis touchés sur 0 colliders&quot; : &#10;- Le rayon est peut-être trop petit&#10;- Aucun ennemi n'est à portée&#10;&#10;Si vous voyez &quot;0 ennemis touchés sur X colliders&quot; (X &gt; 0) :&#10;- Les colliders détectés ne sont pas des ennemis&#10;- Le composant EnemyHealth n'est pas trouvé&#10;&#10;### 2. Vérifier le Rayon dans l'Inspector&#10;- Sélectionnez l'ennemi électrique dans Unity&#10;- Regardez le composant &quot;Electric Ennemis&quot;&#10;- Augmentez `Electric Discharge Radius` (essayez 10 ou 15 pour tester)&#10;&#10;### 3. Vérifier les Colliders&#10;Dans Unity, sélectionnez un ennemi et vérifiez :&#10;- Est-ce qu'il a un Collider (BoxCollider, CapsuleCollider, etc.) ?&#10;- Est-ce que le composant EnemyHealth est sur le même GameObject que le collider ?&#10;- Ou est-ce que EnemyHealth est sur un parent ?&#10;&#10;### 4. Vérifier que les Ennemis sont Proches&#10;- Placez plusieurs ennemis très proches de l'ennemi électrique (&lt; 5 mètres)&#10;- Tirez sur l'ennemi électrique&#10;- Observez si les ennemis proches perdent de la vie&#10;&#10;### 5. Test Simple&#10;1. Créez une scène de test avec :&#10;   - 1 ennemi avec le composant ElectricEnnemis&#10;   - 3-4 ennemis normaux autour à 3-4 mètres&#10;2. Tirez sur l'ennemi électrique&#10;3. Observez la console et les barres de vie des ennemis&#10;&#10;## Paramètres Recommandés pour le Test&#10;&#10;```&#10;Electric Discharge Radius: 10 (pour être sûr d'attraper les ennemis)&#10;Electric Damage: 50 (pour voir clairement l'effet)&#10;Discharge Cooldown: 0.2&#10;```&#10;&#10;## Checklist de Vérification&#10;&#10;- [ ] Le composant ElectricEnnemis est bien attaché à l'ennemi&#10;- [ ] Le composant EnemyHealth est bien attaché (requis par ElectricEnnemis)&#10;- [ ] Le rayon de décharge est &gt; 0&#10;- [ ] Les dégâts électriques sont &gt; 0&#10;- [ ] Il y a d'autres ennemis dans le rayon quand vous tirez&#10;- [ ] Les autres ennemis ont le composant EnemyHealth&#10;- [ ] Les autres ennemis ont des Colliders&#10;- [ ] Vous voyez le log dans la console quand vous tirez&#10;&#10;## Si Ça Ne Fonctionne Toujours Pas&#10;&#10;Vérifiez les Layers :&#10;- Les ennemis doivent être sur un layer que Physics.OverlapSphereNonAlloc peut détecter&#10;- Par défaut, ça devrait fonctionner, mais si vous avez configuré des layers spéciaux, ça pourrait bloquer&#10;&#10;Ajoutez ce code temporaire dans TriggerElectricDischarge pour plus de détails :&#10;```csharp&#10;for (int i = 0; i &lt; count; i++)&#10;{&#10;    var col = DischargeBuffer[i];&#10;    if (col == null) continue;&#10;    &#10;    Debug.Log($&quot;Collider {i}: {col.name}&quot;);&#10;    &#10;    var enemyHealth = col.GetComponent&lt;EnemyHealth&gt;();&#10;    Debug.Log($&quot;  - EnemyHealth direct: {enemyHealth != null}&quot;);&#10;    &#10;    if (enemyHealth == null)&#10;    {&#10;        enemyHealth = col.GetComponentInParent&lt;EnemyHealth&gt;();&#10;        Debug.Log($&quot;  - EnemyHealth parent: {enemyHealth != null}&quot;);&#10;    }&#10;}&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ELECTRIC_ENEMY_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ELECTRIC_ENEMY_GUIDE.md" />
              <option name="updatedContent" value="# Guide de l'Ennemi Électrique&#10;&#10;## Description&#10;Le composant `ElectricEnnemis` permet à un ennemi d'infliger des dégâts électriques à tous les ennemis dans un rayon défini lorsqu'il est touché par un tir.&#10;&#10;## Fonctionnalités&#10;&#10;### 1. Décharge Électrique Automatique&#10;- **Déclenchement** : Chaque fois que l'ennemi est touché par un tir&#10;- **Zone d'effet** : Rayon configurable autour de l'ennemi&#10;- **Cibles** : Tous les ennemis dans le rayon (sauf lui-même)&#10;- **Dégâts** : Configurables dans l'Inspector&#10;&#10;### 2. Décharge à la Mort&#10;- L'ennemi déclenche également une décharge électrique quand il meurt&#10;- Même rayon et dégâts que la décharge normale&#10;&#10;### 3. Effets Visuels&#10;- Possibilité d'assigner un prefab d'effet visuel&#10;- L'effet est créé au centre de la décharge&#10;- Des arcs électriques peuvent être créés entre l'ennemi électrique et les cibles touchées&#10;&#10;## Configuration dans l'Inspector&#10;&#10;### Paramètres de Stun (Joueur)&#10;- **Stun Duration** : Durée du stun appliqué au joueur si touché par un dash&#10;- **Override Auto Fire Interval** : Active/désactive le remplacement de l'intervalle d'auto-fire&#10;- **Stun Auto Fire Interval** : Nouvel intervalle pendant le stun&#10;&#10;### Paramètres de Décharge Électrique&#10;- **Electric Discharge Radius** : Rayon de la décharge (défaut: 5m)&#10;- **Electric Damage** : Dégâts infligés aux ennemis (défaut: 15)&#10;- **Electric Effect Prefab** : Prefab optionnel pour l'effet visuel&#10;- **Effect Duration** : Durée de l'effet visuel (défaut: 0.5s)&#10;&#10;## Utilisation&#10;&#10;1. Ajoutez le composant `ElectricEnnemis` à votre prefab d'ennemi&#10;2. Configurez les paramètres dans l'Inspector&#10;3. (Optionnel) Assignez un prefab d'effet visuel électrique&#10;4. L'ennemi déclenchera automatiquement des décharges quand il est touché&#10;&#10;## Comportement&#10;&#10;```&#10;Joueur tire sur ennemi électrique&#10;    ↓&#10;EnemyHealth.TakeDamage() est appelé&#10;    ↓&#10;Détecte ElectricEnnemis component&#10;    ↓&#10;Déclenche TriggerElectricDischarge()&#10;    ↓&#10;Trouve tous les ennemis dans le rayon&#10;    ↓&#10;Inflige des dégâts électriques à chaque ennemi&#10;    ↓&#10;Crée les effets visuels (si configurés)&#10;```&#10;&#10;## Notes Importantes&#10;&#10;- Les dégâts électriques sont enregistrés comme venant de la zone &quot;Electric&quot;&#10;- L'ennemi électrique ne se touche pas lui-même&#10;- La décharge fonctionne avec tous les types de tirs (hitscan, projectiles, etc.)&#10;- Utilise un buffer statique pour optimiser les performances (max 32 cibles par décharge)&#10;&#10;## Exemple de Configuration Recommandée&#10;&#10;- **Ennemi faible électrique** :&#10;  - Radius: 3-4m&#10;  - Damage: 10-15&#10;  &#10;- **Ennemi moyen électrique** :&#10;  - Radius: 5-6m&#10;  - Damage: 20-25&#10;  &#10;- **Boss électrique** :&#10;  - Radius: 8-10m&#10;  - Damage: 30-40&#10;&#10;## Combinaisons Possibles&#10;&#10;L'ElectricEnnemis peut être combiné avec d'autres composants :&#10;- TacheEnnemies (explosion + décharge)&#10;- Autres effets custom&#10;- Différents types d'armures&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ELECTRIC_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ELECTRIC_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# ⚡ Résumé - Système de Décharge Électrique des Ennemis&#10;&#10;##  Modifications Apportées&#10;&#10;### 1. **ElectricEnnemis.cs** - Améliorations Majeures&#10;✅ Recherche améliorée d'EnemyHealth (composant direct + parent)&#10;✅ Système de cooldown (0.2s) pour éviter les boucles infinies&#10;✅ Logs de débogage détaillés dans la console&#10;✅ Gizmos pour visualiser le rayon dans Unity (sphère cyan)&#10;✅ Protection contre l'auto-dommage&#10;✅ Compteur d'ennemis touchés&#10;&#10;### 2. **EnemyHealth.cs** - Protection Anti-Boucle&#10;✅ Ne déclenche pas de décharge si les dégâts viennent déjà d'une décharge électrique&#10;✅ Évite les réactions en chaîne infinies entre ennemis électriques&#10;&#10;##  Comment Utiliser&#10;&#10;1. **Dans Unity** :&#10;   - Ajoutez le composant `ElectricEnnemis` à votre prefab d'ennemi&#10;   - Le composant `EnemyHealth` sera automatiquement requis&#10;&#10;2. **Paramètres à Configurer** :&#10;   - `Electric Discharge Radius` : 5 par défaut (zone d'effet)&#10;   - `Electric Damage` : 15 par défaut (dégâts infligés)&#10;   - `Discharge Cooldown` : 0.2s (temps entre deux décharges)&#10;&#10;3. **Effet Automatique** :&#10;   - Quand on tire sur l'ennemi → décharge électrique immédiate&#10;   - Quand l'ennemi meurt → décharge électrique finale&#10;&#10;##  Débogage&#10;&#10;### Dans la Console Unity&#10;Vous devriez voir ce message à chaque tir :&#10;```&#10;[ElectricEnnemis] Décharge électrique: X ennemis touchés sur Y colliders détectés&#10;```&#10;&#10;### Cas Possibles&#10;&#10;**&quot;0 ennemis touchés sur 0 colliders&quot;**&#10;→ Aucun collider détecté = Rayon trop petit ou pas d'ennemis proches&#10;→ **Solution** : Augmentez `Electric Discharge Radius` à 10-15 pour tester&#10;&#10;**&quot;0 ennemis touchés sur X colliders&quot;** (X &gt; 0)&#10;→ Des colliders sont détectés mais pas d'EnemyHealth trouvé&#10;→ **Solution** : Vérifiez que les ennemis ont bien le composant EnemyHealth&#10;&#10;**&quot;X ennemis touchés&quot;** (X &gt; 0)&#10;→ ✅ Ça fonctionne ! Les ennemis devraient perdre de la vie&#10;&#10;### Visualisation dans Unity&#10;1. Sélectionnez un ennemi avec ElectricEnnemis dans la hiérarchie&#10;2. Dans la Scene view, vous verrez une **sphère cyan** = zone de décharge&#10;3. Les ennemis dans cette sphère devraient être touchés&#10;&#10;##  Test Rapide&#10;&#10;1. Placez 3-4 ennemis en cercle&#10;2. Mettez un ennemi avec ElectricEnnemis au centre&#10;3. Augmentez temporairement le rayon à 10&#10;4. Tirez sur l'ennemi central&#10;5. Regardez la console et les barres de vie&#10;&#10;##  Checklist de Vérification&#10;&#10;Si ça ne fonctionne pas, vérifiez :&#10;&#10;- [ ] L'ennemi a le composant `ElectricEnnemis` attaché&#10;- [ ] L'ennemi a le composant `EnemyHealth` attaché&#10;- [ ] `Electric Discharge Radius` &gt; 0&#10;- [ ] `Electric Damage` &gt; 0&#10;- [ ] D'autres ennemis sont visibles dans la sphère cyan&#10;- [ ] Les autres ennemis ont `EnemyHealth`&#10;- [ ] Les autres ennemis ont des Colliders (Box/Capsule/Sphere)&#10;- [ ] Vous voyez le message de log dans la console&#10;&#10;## ⚙️ Paramètres Recommandés&#10;&#10;**Test Initial (pour voir clairement l'effet)** :&#10;```&#10;Electric Discharge Radius: 10&#10;Electric Damage: 50&#10;Discharge Cooldown: 0.2&#10;```&#10;&#10;**Production (équilibré)** :&#10;```&#10;Electric Discharge Radius: 5&#10;Electric Damage: 15-25&#10;Discharge Cooldown: 0.2&#10;```&#10;&#10;##  Si le Problème Persiste&#10;&#10;Vérifiez les **Physics Layers** :&#10;- Les ennemis doivent être sur un layer détectable&#10;- Par défaut, tout devrait fonctionner&#10;- Si vous utilisez des layers custom, vérifiez la Layer Collision Matrix&#10;&#10;##  Fichiers Modifiés&#10;- `Assets/Scripts/Ennemies/Effect/ElectricEnnemis.cs` ✅ Refait complètement&#10;- `Assets/Scripts/FPS/EnemyHealth.cs` ✅ Ajout du déclenchement automatique&#10;- `ELECTRIC_ENEMY_GUIDE.md` ✅ Guide utilisateur&#10;- `DEBUG_ELECTRIC_ENEMY.md` ✅ Guide de débogage détaillé&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_QUICKSTART.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_QUICKSTART.md" />
              <option name="updatedContent" value="# Slide System - Quick Start&#10;&#10;## Installation Rapide&#10;Le composant `Slide` est déjà configuré et prêt à l'emploi !&#10;&#10;## Contrôles&#10;- **Ctrl gauche** = Slider&#10;&#10;## Comment l'utiliser ?&#10;&#10;### Slide Basique&#10;1. Courez avec **WASD**&#10;2. Maintenez **Ctrl** pour slider&#10;3. Relâchez **Ctrl** pour vous relever&#10;&#10;### Combo Dash → Slide (Recommandé !)&#10;1. **Clic droit** pour dasher&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash = vitesse maximale !&#10;4. Vous pouvez traverser de très grandes distances&#10;&#10;### Astuces&#10;- Plus vous allez vite, plus le slide est long&#10;- Le slide décélère progressivement&#10;- Cooldown de 0.5s entre chaque slide&#10;- Maximum 2 secondes de slide&#10;- Ne fonctionne qu'au sol&#10;&#10;## Effets Visuels&#10;- Votre personnage s'abaisse&#10;- La caméra s'incline légèrement (5°)&#10;- Transitions fluides et smooth&#10;&#10;## Paramètres Clés (Inspector)&#10;- **Slide Speed** : 12 (vitesse de base)&#10;- **Speed Multiplier** : 1.3 (multiplie votre vitesse actuelle)&#10;- **Dash Momentum Multiplier** : 1.5 (après un dash)&#10;&#10;## C'est tout !&#10;Le système fonctionne automatiquement avec :&#10;- ✅ Le dash (synergie parfaite)&#10;- ✅ Le sprint&#10;- ✅ Le système de stun&#10;- ✅ Le saut (arrête le slide)&#10;&#10;Amusez-vous à enchaîner les combos de mouvement !&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_GUIDE.md" />
              <option name="updatedContent" value="# Guide du Système de Slide&#10;&#10;## Vue d'ensemble&#10;Le système de slide permet au joueur de glisser au sol avec la touche **Ctrl** pour un gameplay dynamique et fluide. Il est conçu pour fonctionner en parfaite synergie avec le système de dash et le mouvement.&#10;&#10;## Contrôles&#10;- **Ctrl gauche** : Maintenir pour slider&#10;- Le slide suit la direction de votre mouvement (WASD) ou la direction de la caméra si vous ne bougez pas&#10;&#10;## Fonctionnalités Principales&#10;&#10;### 1. Démarrage du Slide&#10;- Appuyez sur **Ctrl** pendant que vous êtes au sol&#10;- Nécessite une vitesse minimale (configurable)&#10;- Le slide hérite de votre vitesse actuelle et la multiplie&#10;&#10;### 2. Synergie avec le Dash&#10;- Si vous slidez juste après un dash, le momentum est conservé et amplifié&#10;- Le multiplicateur de dash momentum permet des combos spectaculaires&#10;- Parfait pour enchaîner dash → slide pour traverser de grandes distances&#10;&#10;### 3. Physique du Slide&#10;- **Décélération progressive** : Le slide ralentit naturellement&#10;- **Vitesse minimale** : Le slide s'arrête si vous devenez trop lent&#10;- **Durée maximale** : 2 secondes par défaut pour équilibrer le gameplay&#10;- **Cooldown** : 0.5s entre chaque slide&#10;&#10;### 4. Effets Visuels&#10;- **Hauteur réduite** : Le CharacterController s'abaisse pendant le slide&#10;- **Inclinaison de caméra** : 5° d'inclinaison pour un effet dynamique&#10;- **Transitions smooth** : Toutes les transitions sont interpolées&#10;&#10;## Paramètres Configurables (Inspector)&#10;&#10;### Slide Settings&#10;- **Slide Speed** (12) : Vitesse de base du slide&#10;- **Speed Multiplier** (1.3) : Multiplie votre vitesse actuelle&#10;- **Slide Deceleration** (5) : Vitesse de ralentissement&#10;- **Min Slide Speed** (3) : Vitesse minimale pour continuer&#10;- **Max Slide Duration** (2) : Durée maximale en secondes&#10;- **Slide Cooldown** (0.5) : Temps entre chaque slide&#10;&#10;### Height Settings&#10;- **Slide Height** (1) : Hauteur du controller pendant le slide&#10;- **Height Transition Speed** (10) : Vitesse de transition de hauteur&#10;&#10;### Camera Settings&#10;- **Camera Tilt** (5) : Inclinaison en degrés&#10;- **Tilt Transition Speed** (8) : Vitesse de transition de l'inclinaison&#10;&#10;### Momentum Settings&#10;- **Inherit Dash Momentum** (true) : Hériter du momentum du dash&#10;- **Dash Momentum Multiplier** (1.5) : Multiplicateur du momentum hérité&#10;&#10;## Utilisation dans Unity&#10;&#10;### Configuration du Joueur&#10;1. Ajoutez le composant `Slide` à votre GameObject joueur&#10;2. Assurez-vous que les composants suivants sont présents :&#10;   - `CharacterController`&#10;   - `FPSMovement`&#10;   - `FPSMouseLook`&#10;   - `FPSInputHandler`&#10;   - `PillarDashSystem` (optionnel, pour la synergie)&#10;&#10;### Intégration dans le Code&#10;```csharp&#10;// Vérifier si le joueur peut slider&#10;Slide slideComponent = GetComponent&lt;Slide&gt;();&#10;if (slideComponent.CanSlide())&#10;{&#10;    // Le joueur peut slider&#10;}&#10;&#10;// Vérifier si le joueur est en train de slider&#10;if (slideComponent.IsSliding)&#10;{&#10;    // Le joueur slide actuellement&#10;}&#10;```&#10;&#10;## Mécaniques Avancées&#10;&#10;### Combo Dash → Slide&#10;1. Dashez avec clic droit vers un groupe d'ennemis&#10;2. Juste avant la fin du dash, appuyez sur **Ctrl**&#10;3. Le slide hérite du momentum du dash × 1.5&#10;4. Vous pouvez traverser de grandes distances à haute vitesse&#10;&#10;### Gestion du Momentum&#10;- Le slide conserve 60% du momentum à la fin pour une transition fluide&#10;- Le système `ApplyExternalMomentum()` assure une transition smooth avec le système de mouvement&#10;- Pas de téléportation ou de changement brusque de vitesse&#10;&#10;### Conditions d'Arrêt&#10;Le slide s'arrête automatiquement si :&#10;- Vous relâchez la touche **Ctrl**&#10;- La durée maximale est atteinte&#10;- Votre vitesse descend sous le minimum&#10;- Vous quittez le sol (saut ou chute)&#10;- Vous êtes stunné&#10;&#10;## Optimisation et Performance&#10;&#10;### Interpolations Smooth&#10;- Utilisation de `Mathf.Lerp` pour toutes les transitions&#10;- Évite les changements brusques qui pourraient causer du motion sickness&#10;- Les vitesses de transition sont configurables&#10;&#10;### Gestion de l'État&#10;- Le système vérifie automatiquement le stun&#10;- Intégration avec `PlayerStunAutoFire`&#10;- Désactivation automatique du slide pendant le stun&#10;&#10;## Conseils de Gameplay&#10;&#10;### Pour les Level Designers&#10;- Créez des pentes pour des slides spectaculaires&#10;- Placez des ennemis pour encourager les combos dash-slide&#10;- Utilisez le slide pour créer des shortcuts optionnels&#10;&#10;### Pour les Joueurs&#10;- Combinez sprint + slide pour une vitesse maximale&#10;- Utilisez le slide pour esquiver les projectiles&#10;- Le slide est parfait pour se repositionner rapidement&#10;- Dash → Slide → Saut = combo de mobilité ultime&#10;&#10;## Dépannage&#10;&#10;### Le slide ne démarre pas&#10;- Vérifiez que vous êtes au sol (`IsGrounded`)&#10;- Vérifiez que le cooldown est terminé&#10;- Vérifiez que vous n'êtes pas stunné&#10;- Vérifiez que vous avez une vitesse minimale&#10;&#10;### Le slide s'arrête trop vite&#10;- Augmentez `Min Slide Speed`&#10;- Réduisez `Slide Deceleration`&#10;- Augmentez `Max Slide Duration`&#10;&#10;### Transitions saccadées&#10;- Augmentez `Height Transition Speed`&#10;- Augmentez `Tilt Transition Speed`&#10;- Vérifiez que le framerate est stable&#10;&#10;## API Publique&#10;&#10;```csharp&#10;public class Slide : MonoBehaviour&#10;{&#10;    // Propriétés&#10;    public bool IsSliding { get; }  // Le joueur slide-t-il ?&#10;    &#10;    // Méthodes&#10;    public bool CanSlide();  // Le joueur peut-il slider ?&#10;}&#10;```&#10;&#10;## Notes Techniques&#10;&#10;### Synergie avec les Systèmes Existants&#10;- **FPSMovement** : Utilise `ApplyExternalMomentum()` pour le momentum&#10;- **FPSInputHandler** : Lit `MoveInput` pour la direction&#10;- **PillarDashSystem** : Vérifie `isDashing` pour hériter du momentum&#10;- **PlayerStunAutoFire** : Désactive le slide pendant le stun&#10;&#10;### Gestion de la Hauteur&#10;- Modifie dynamiquement `CharacterController.height` et `center`&#10;- Conserve les valeurs originales pour la restauration&#10;- Évite les problèmes de collision grâce aux transitions smooth&#10;&#10;### Performance&#10;- Aucun allocation mémoire pendant le slide&#10;- Utilisation optimale de `Vector3` et `Mathf`&#10;- Pas de coroutines, tout dans `Update()`&#10;&#10;## Améliorations Futures Possibles&#10;- Particules de poussière pendant le slide&#10;- Son de glissement&#10;- Trail renderer pour l'effet de vitesse&#10;- Bonus de vitesse sur certaines surfaces (glace, etc.)&#10;- Dégâts aux ennemis pendant le slide (comme le dash)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SLIDE_SYSTEM_SUMMARY.md" />
              <option name="updatedContent" value="# Résumé du Système de Slide&#10;&#10;##  Vue d'ensemble&#10;Système de slide activé avec **Ctrl** qui s'intègre parfaitement avec le dash et le système de mouvement pour créer un gameplay fluide et dynamique.&#10;&#10;## ✨ Caractéristiques Principales&#10;&#10;###  Contrôles&#10;- **Ctrl gauche (maintenu)** : Activer/maintenir le slide&#10;- Fonctionne uniquement au sol&#10;- Direction = mouvement actuel ou direction de la caméra&#10;&#10;### ⚡ Synergie avec le Dash&#10;- Hérite automatiquement du momentum du dash&#10;- Multiplicateur de 1.5x sur la vitesse du dash&#10;- Permet des combos dash → slide spectaculaires&#10;- Transition parfaitement smooth&#10;&#10;###  Physique du Slide&#10;- **Vitesse de base** : 12 unités/s&#10;- **Multiplicateur de vitesse** : 1.3x de votre vitesse actuelle&#10;- **Décélération** : 5 unités/s² (progressive et naturelle)&#10;- **Vitesse minimale** : 3 unités/s (arrêt automatique en dessous)&#10;- **Durée max** : 2 secondes&#10;- **Cooldown** : 0.5 secondes&#10;&#10;###  Effets Visuels&#10;- **Hauteur réduite** : CharacterController passe à 1 unité&#10;- **Inclinaison caméra** : 5° pour effet de vitesse&#10;- **Transitions smooth** : Interpolation Lerp sur tous les paramètres&#10;- Pas de téléportation ou changement brusque&#10;&#10;##  Architecture Technique&#10;&#10;### Composants Requis&#10;```&#10;GameObject Joueur&#10;├── CharacterController (Unity)&#10;├── FPSMovement (vitesse et momentum)&#10;├── FPSMouseLook (caméra)&#10;├── FPSInputHandler (inputs)&#10;├── PillarDashSystem (optionnel, pour synergie)&#10;└── Slide (nouveau composant) ✨&#10;```&#10;&#10;### Méthodes Publiques&#10;```csharp&#10;public bool IsSliding { get; }  // État actuel&#10;public bool CanSlide();         // Vérification de disponibilité&#10;```&#10;&#10;### Intégration avec Systèmes Existants&#10;- ✅ **FPSMovement** : `ApplyExternalMomentum()` pour momentum smooth&#10;- ✅ **PillarDashSystem** : Détection de `isDashing` pour héritage&#10;- ✅ **PlayerStunAutoFire** : Désactivation automatique pendant stun&#10;- ✅ **FPSInputHandler** : Lecture de `MoveInput` pour direction&#10;&#10;##  Conditions de Fonctionnement&#10;&#10;### Démarrage du Slide&#10;1. Joueur au sol (`IsGrounded`)&#10;2. Cooldown terminé (0.5s)&#10;3. Pas de stun actif&#10;4. Vitesse minimale atteinte OU mouvement actif&#10;5. Touche Ctrl maintenue&#10;&#10;### Arrêt du Slide&#10;- Touche Ctrl relâchée&#10;- Durée maximale atteinte (2s)&#10;- Vitesse trop faible (&lt; 3)&#10;- Joueur en l'air&#10;- Stun appliqué&#10;&#10;##  Flux de Gameplay&#10;&#10;### Combo Recommandé&#10;```&#10;1. Sprint (Shift) → Vitesse augmente&#10;2. Dash (Clic droit) → Vitesse maximale + kill ennemis&#10;3. Slide (Ctrl) → Hérite momentum × 1.5&#10;4. Transition smooth vers mouvement normal&#10;```&#10;&#10;### Gestion du Momentum&#10;```&#10;Début slide : Max(slideSpeed, currentSpeed × multiplier)&#10;Pendant slide : Décélération progressive&#10;Fin slide : Conservation de 60% du momentum&#10;→ Transition fluide sans rupture de vitesse&#10;```&#10;&#10;##  Paramètres Configurables&#10;&#10;| Paramètre | Valeur par défaut | Description |&#10;|-----------|-------------------|-------------|&#10;| Slide Speed | 12 | Vitesse de base |&#10;| Speed Multiplier | 1.3 | Multiplie vitesse actuelle |&#10;| Slide Deceleration | 5 | Ralentissement progressif |&#10;| Min Slide Speed | 3 | Seuil d'arrêt |&#10;| Max Slide Duration | 2 | Durée maximale (s) |&#10;| Slide Cooldown | 0.5 | Temps entre slides (s) |&#10;| Slide Height | 1 | Hauteur du controller |&#10;| Camera Tilt | 5 | Inclinaison (degrés) |&#10;| Dash Momentum Multiplier | 1.5 | Bonus après dash |&#10;&#10;##  Performance&#10;&#10;### Optimisations&#10;- ❌ Pas d'allocation mémoire pendant l'exécution&#10;- ❌ Pas de coroutines&#10;- ✅ Tout dans `Update()` avec early returns&#10;- ✅ Ordre de multiplication optimisé&#10;- ✅ Utilisation de propriétés cached&#10;&#10;### Garbage Collection&#10;- 0 allocation par frame&#10;- Références cached dans `Awake()`&#10;- Pas de `GetComponent()` dans `Update()`&#10;&#10;##  Documentation&#10;&#10;### Fichiers Créés&#10;- `Slide.cs` : Composant principal (280 lignes)&#10;- `SLIDE_SYSTEM_GUIDE.md` : Guide complet&#10;- `SLIDE_QUICKSTART.md` : Démarrage rapide&#10;- `SLIDE_SYSTEM_SUMMARY.md` : Ce fichier&#10;&#10;### Modifications Apportées&#10;- `FPSInputHandler.cs` : Ajout de `SprintPressed`&#10;&#10;##  Cas d'Usage&#10;&#10;### Level Design&#10;- Pentes pour slides spectaculaires&#10;- Zones de combat avec dash-slide combos&#10;- Shortcuts nécessitant maîtrise du momentum&#10;&#10;### Gameplay&#10;- Mobilité tactique en combat&#10;- Esquive de projectiles&#10;- Traversée rapide de maps&#10;- Combos de mouvement créatifs&#10;&#10;## ⚠️ Notes Importantes&#10;&#10;### Limitations&#10;- Fonctionne uniquement au sol&#10;- Pas de slide en l'air (arrêt automatique)&#10;- Cooldown impose un rythme&#10;- Durée max évite les abus&#10;&#10;### Compatibilité&#10;- Compatible avec tous les systèmes FPS existants&#10;- Pas d'impact sur les autres mécaniques&#10;- Peut être désactivé sans casser le jeu&#10;&#10;##  Extensions Possibles&#10;&#10;### Améliorations Futures&#10;- Particules de poussière/friction&#10;- Son de glissement dynamique&#10;- Trail renderer pour effet de vitesse&#10;- Surfaces spéciales (glace = moins de friction)&#10;- Dégâts aux ennemis pendant le slide&#10;- Animation du personnage&#10;- Shake de caméra proportionnel à la vitesse&#10;&#10;### API Extensible&#10;Le système est conçu pour être facilement étendu :&#10;- Méthode `CanSlide()` pour conditions custom&#10;- Events possibles (OnSlideStart, OnSlideEnd)&#10;- Paramètres exposés dans l'inspector&#10;&#10;## ✅ Status&#10;- [x] Implémentation complète&#10;- [x] Intégration avec systèmes existants&#10;- [x] Documentation complète&#10;- [x] Tests de compilation OK&#10;- [x] Optimisations appliquées&#10;- [x] Guides utilisateur créés&#10;&#10;**Le système est prêt à l'emploi !** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>