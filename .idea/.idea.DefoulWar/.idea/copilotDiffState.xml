<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/FPS/PillarDashSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/FPS/PillarDashSystem.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Système de dash directionnel.&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage.&#10;    public class PillarDashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private Transform cameraTransform;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false;&#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private CharacterController characterController;&#10;        &#10;        private static System.Collections.Generic.HashSet&lt;GameObject&gt; enemiesKilledByDash = new System.Collections.Generic.HashSet&lt;GameObject&gt;();&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            characterController = playerController.Controller;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown (uniquement si autoRegenerate est activé)&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || characterController == null) return;&#10;&#10;            // Calculer le progrès du dash (0 à 1)&#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Si c'est un ennemi électrique -&gt; stun le joueur (auto-fire)&#10;                    var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                    if (electric != null)&#10;                    {&#10;                        var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (electric.OverrideAutoFireInterval)&#10;                            playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                        else&#10;                            playerStun.ApplyStun(electric.StunDuration);&#10;                    }&#10;&#10;                    // Marquer comme kill par dash si le coup sera létal&#10;                    bool willDie = enemyHealth.CurrentHealth &lt;= dashDamage;&#10;                    if (willDie)&#10;                    {&#10;                        enemiesKilledByDash.Add(enemyRoot);&#10;                        StartCoroutine(CleanupEnemyTracking(enemyRoot));&#10;                        &#10;                        // Désactiver immédiatement les collisions pour permettre le dash à travers&#10;                        DisableEnemyCollisions(enemyRoot);&#10;                    }&#10;&#10;                    // Appliquer dégâts&#10;                    enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            characterController.Move(dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;            &#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;&#10;        // Désactive toutes les collisions d'un ennemi pour permettre au dash de passer à travers.&#10;        private void DisableEnemyCollisions(GameObject enemy)&#10;        {&#10;&#10;            Collider[] colliders = enemy.GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;            &#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody rb = enemy.GetComponent&lt;Rigidbody&gt;();&#10;            if (rb != null)&#10;            {&#10;                rb.isKinematic = true;&#10;                rb.detectCollisions = false;&#10;            }&#10;            &#10;            Rigidbody[] childRbs = enemy.GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        private System.Collections.IEnumerator CleanupEnemyTracking(GameObject enemy)&#10;        {&#10;            yield return new WaitForSeconds(2f);&#10;            if (enemy == null)&#10;            {&#10;                // L'ennemi a bien été détruit, on peut le retirer du tracking&#10;                enemiesKilledByDash.Remove(enemy);&#10;            }&#10;        }&#10;        &#10;        // Vérifie si un ennemi a été tué par le dash&#10;        public static bool WasKilledByDash(GameObject enemy)&#10;        {&#10;            return enemiesKilledByDash.Contains(enemy);&#10;        }&#10;        &#10;        private void EndDash()&#10;        {&#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[PillarDashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;namespace Proto3GD.FPS&#10;{&#10;&#10;    // Système de dash directionnel.&#10;    // Permet au joueur de dasher dans la direction de la caméra et de tuer les ennemis sur son passage.&#10;    public class PillarDashSystem : MonoBehaviour&#10;    {&#10;        [Header(&quot;Dash Settings&quot;)]&#10;        [Tooltip(&quot;Vitesse du dash&quot;)]&#10;        [SerializeField] private float dashSpeed = 25f;&#10;        &#10;        [Tooltip(&quot;Durée du dash en secondes&quot;)]&#10;        [SerializeField] private float dashDuration = 0.4f;&#10;        &#10;        [Tooltip(&quot;Courbe de vitesse du dash (X = temps normalisé 0-1, Y = multiplicateur de vitesse)&quot;)]&#10;        [SerializeField] private AnimationCurve dashSpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.3f);&#10;        &#10;        [Header(&quot;Dash Charge Settings&quot;)]&#10;        [Tooltip(&quot;Activer la régénération automatique du dash (désactiver pour forcer le kill d'ennemis)&quot;)]&#10;        [SerializeField] private bool autoRegenerate = false;&#10;        &#10;        [Tooltip(&quot;Cooldown entre chaque dash en secondes (uniquement si autoRegenerate est activé)&quot;)]&#10;        [SerializeField] private float dashCooldown = 1.5f;&#10;        &#10;        [Tooltip(&quot;Nombre d'ennemis spéciaux à tuer pour remplir complètement la barre de dash&quot;)]&#10;        [SerializeField] private int enemiesRequiredForFullCharge = 3;&#10;        &#10;        [Tooltip(&quot;Charge de dash actuelle (0 à 1)&quot;)]&#10;        [SerializeField] private float currentDashCharge = 1f;&#10;        &#10;        [Tooltip(&quot;Rayon de détection des ennemis pendant le dash&quot;)]&#10;        [SerializeField] private float dashHitRadius = 1.0f;&#10;        &#10;        [Tooltip(&quot;Dégâts infligés aux ennemis touchés&quot;)]&#10;        [SerializeField] private float dashDamage = 9999f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour détecter les ennemis&quot;)]&#10;        [SerializeField] private LayerMask enemyMask = ~0;&#10;        &#10;        [Header(&quot;Collision Settings&quot;)]&#10;        [Tooltip(&quot;Angle maximum (en degrés) entre la direction du dash et la surface pour continuer le dash. Au-delà, le dash s'arrête.&quot;)]&#10;        [SerializeField] private float maxCollisionAngle = 45f;&#10;        &#10;        [Tooltip(&quot;LayerMask pour les obstacles qui peuvent arrêter le dash&quot;)]&#10;        [SerializeField] private LayerMask obstacleMask = ~0;&#10;        &#10;        [Tooltip(&quot;Distance de détection des obstacles devant le joueur&quot;)]&#10;        [SerializeField] private float obstacleCheckDistance = 0.5f;&#10;        &#10;        [Header(&quot;FOV Settings&quot;)]&#10;        [Tooltip(&quot;FOV pendant le dash&quot;)]&#10;        [SerializeField] private float dashFOV = 90f;&#10;        &#10;        [Tooltip(&quot;Vitesse de transition du FOV&quot;)]&#10;        [SerializeField] private float fovTransitionSpeed = 15f;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private FPSPlayerController playerController;&#10;        [SerializeField] private Transform cameraTransform;&#10;        &#10;        private Camera playerCamera;&#10;        private float defaultFOV;&#10;        private float targetFOV;&#10;        &#10;        public bool isDashing = false;&#10;        private float dashTimer = 0f;&#10;        private float cooldownTimer = 0f;&#10;        &#10;        private CharacterController characterController;&#10;        &#10;        private static System.Collections.Generic.HashSet&lt;GameObject&gt; enemiesKilledByDash = new System.Collections.Generic.HashSet&lt;GameObject&gt;();&#10;        &#10;        // Runtime&#10;        private Vector3 directionalDashDir;&#10;        private Vector3 lastDashPosition;&#10;        private readonly HashSet&lt;GameObject&gt; _hitThisDash = new HashSet&lt;GameObject&gt;();&#10;        private static readonly RaycastHit[] _hitBuffer = new RaycastHit[32];&#10;        &#10;        private void Start()&#10;        {&#10;            if (playerController == null)&#10;            {&#10;                playerController = GetComponent&lt;FPSPlayerController&gt;();&#10;                if (playerController == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform == null)&#10;            {&#10;                cameraTransform = playerController.CameraTransform;&#10;                if (cameraTransform == null)&#10;                {&#10;                    return;&#10;                }&#10;            }&#10;&#10;            if (cameraTransform != null)&#10;            {&#10;                playerCamera = cameraTransform.GetComponent&lt;Camera&gt;();&#10;                if (playerCamera != null)&#10;                {&#10;                    defaultFOV = playerCamera.fieldOfView;&#10;                    targetFOV = defaultFOV;&#10;                }&#10;            }&#10;&#10;            characterController = playerController.Controller;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            // Mise à jour du cooldown (uniquement si autoRegenerate est activé)&#10;            if (autoRegenerate &amp;&amp; cooldownTimer &lt; dashCooldown)&#10;            {&#10;                cooldownTimer += Time.deltaTime;&#10;                &#10;                // Régénération automatique de la charge&#10;                if (cooldownTimer &gt;= dashCooldown &amp;&amp; currentDashCharge &lt; 1f)&#10;                {&#10;                    currentDashCharge = 1f;&#10;                }&#10;            }&#10;            &#10;            // Empêcher le dash pendant un stun&#10;            var stunComp = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;            bool isStunned = stunComp != null &amp;&amp; stunComp.IsStunned;&#10;            &#10;            // Gestion du dash&#10;            if (isDashing)&#10;            {&#10;                HandleDash();&#10;            }&#10;            else&#10;            {&#10;                bool hasCharge = currentDashCharge &gt;= 1f;&#10;                bool cooldownReady = autoRegenerate ? (cooldownTimer &gt;= dashCooldown) : true;&#10;                &#10;                if (!isStunned &amp;&amp; Input.GetMouseButtonDown(1) &amp;&amp; hasCharge &amp;&amp; cooldownReady)&#10;                {&#10;                    StartDirectionalDash();&#10;                }&#10;            }&#10;            &#10;            // Gestion du FOV&#10;            UpdateFOV();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            if (!isDashing || characterController == null) return;&#10;&#10;            // Vérifier les obstacles devant le joueur&#10;            if (CheckObstacleCollision())&#10;            {&#10;                EndDash();&#10;                return;&#10;            }&#10;&#10;            // Calculer le progrès du dash (0 à 1)&#10;            float dashProgress = Mathf.Clamp01(dashTimer / dashDuration);&#10;            &#10;            // Évaluer la courbe pour obtenir le multiplicateur de vitesse&#10;            float speedMultiplier = dashSpeedCurve.Evaluate(dashProgress);&#10;            &#10;            // Mouvement en ligne droite selon la direction de dash avec la courbe appliquée&#10;            Vector3 dashMovement = directionalDashDir * (dashSpeed * speedMultiplier * Time.fixedDeltaTime);&#10;            &#10;            Vector3 currentPos = transform.position;&#10;            Vector3 nextPos = currentPos + dashMovement;&#10;            Vector3 seg = nextPos - lastDashPosition;&#10;            float segLen = seg.magnitude;&#10;            if (segLen &gt; 0.0001f)&#10;            {&#10;                int hits = Physics.SphereCastNonAlloc(&#10;                    lastDashPosition,&#10;                    dashHitRadius,&#10;                    seg.normalized,&#10;                    _hitBuffer,&#10;                    segLen,&#10;                    enemyMask,&#10;                    QueryTriggerInteraction.Ignore&#10;                );&#10;                for (int i = 0; i &lt; hits; i++)&#10;                {&#10;                    var h = _hitBuffer[i];&#10;                    if (h.collider == null) continue;&#10;                    var enemyHealth = h.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? h.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                    if (enemyHealth == null) continue;&#10;&#10;                    var enemyRoot = enemyHealth.transform.root.gameObject;&#10;                    if (_hitThisDash.Contains(enemyRoot)) continue;&#10;                    _hitThisDash.Add(enemyRoot);&#10;&#10;                    // Si c'est un ennemi électrique -&gt; stun le joueur (auto-fire)&#10;                    var electric = h.collider.GetComponentInParent&lt;Ennemies.Effect.ElectricEnnemis&gt;() ?? h.collider.GetComponent&lt;Ennemies.Effect.ElectricEnnemis&gt;();&#10;                    if (electric != null)&#10;                    {&#10;                        var playerStun = GetComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (playerStun == null) playerStun = gameObject.AddComponent&lt;PlayerStunAutoFire&gt;();&#10;                        if (electric.OverrideAutoFireInterval)&#10;                            playerStun.ApplyStun(electric.StunDuration, electric.StunAutoFireInterval);&#10;                        else&#10;                            playerStun.ApplyStun(electric.StunDuration);&#10;                    }&#10;&#10;                    // Marquer comme kill par dash si le coup sera létal&#10;                    bool willDie = enemyHealth.CurrentHealth &lt;= dashDamage;&#10;                    if (willDie)&#10;                    {&#10;                        enemiesKilledByDash.Add(enemyRoot);&#10;                        StartCoroutine(CleanupEnemyTracking(enemyRoot));&#10;                        &#10;                        // Désactiver immédiatement les collisions pour permettre le dash à travers&#10;                        DisableEnemyCollisions(enemyRoot);&#10;                    }&#10;&#10;                    // Appliquer dégâts&#10;                    enemyHealth.TakeDamage(dashDamage, &quot;Dash&quot;);&#10;                }&#10;            }&#10;&#10;            lastDashPosition = nextPos;&#10;            characterController.Move(dashMovement);&#10;            Debug.DrawRay(transform.position, directionalDashDir * 3f, Color.cyan, 0.05f);&#10;        }&#10;&#10;        private void StartDirectionalDash()&#10;        {&#10;            Vector3 fwd;&#10;            if (playerCamera != null)&#10;            {&#10;                Ray aimRay = playerCamera.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f));&#10;                fwd = aimRay.direction;&#10;            }&#10;            else if (cameraTransform != null)&#10;            {&#10;                fwd = cameraTransform.forward;&#10;            }&#10;            else&#10;            {&#10;                fwd = transform.forward;&#10;            }&#10;            &#10;            directionalDashDir = fwd.normalized;&#10;            &#10;            currentDashCharge = 0f;&#10;&#10;            // Init timers/état&#10;            isDashing = true;&#10;            dashTimer = 0f;&#10;            targetFOV = dashFOV;&#10;            lastDashPosition = transform.position;&#10;            _hitThisDash.Clear();&#10;        }&#10;        &#10;        private void HandleDash()&#10;        {&#10;            dashTimer += Time.deltaTime;&#10;            &#10;            if (dashTimer &gt;= dashDuration)&#10;            {&#10;                EndDash();&#10;            }&#10;        }&#10;        &#10;        // Vérifie si le dash doit être arrêté par une collision avec un obstacle à mauvais angle&#10;        private bool CheckObstacleCollision()&#10;        {&#10;            // Raycast dans la direction du dash pour détecter les obstacles&#10;            RaycastHit hit;&#10;            float checkDistance = obstacleCheckDistance;&#10;            &#10;            // SphereCast pour détecter les obstacles devant le joueur avec un rayon similaire au dashHitRadius&#10;            if (Physics.SphereCast(&#10;                transform.position,&#10;                dashHitRadius * 0.8f, // Légèrement plus petit pour éviter les faux positifs&#10;                directionalDashDir,&#10;                out hit,&#10;                checkDistance,&#10;                obstacleMask,&#10;                QueryTriggerInteraction.Ignore))&#10;            {&#10;                // Ignorer si c'est un ennemi (ils sont gérés séparément)&#10;                var enemyHealth = hit.collider.GetComponentInParent&lt;EnemyHealth&gt;() ?? hit.collider.GetComponent&lt;EnemyHealth&gt;();&#10;                if (enemyHealth != null)&#10;                {&#10;                    return false; // Ne pas arrêter le dash pour les ennemis&#10;                }&#10;                &#10;                // Calculer l'angle entre la direction du dash et la normale de la surface&#10;                float angle = Vector3.Angle(directionalDashDir, -hit.normal);&#10;                &#10;                // Debug visuel&#10;                Debug.DrawRay(hit.point, hit.normal * 2f, Color.red, 0.1f);&#10;                Debug.DrawRay(hit.point, directionalDashDir * 2f, Color.yellow, 0.1f);&#10;                &#10;                // Si l'angle est trop abrupt (surface trop perpendiculaire à la direction du dash)&#10;                if (angle &gt; maxCollisionAngle)&#10;                {&#10;                    Debug.Log($&quot;[PillarDashSystem] Dash arrêté par collision ! Angle: {angle:F1}° (max: {maxCollisionAngle}°)&quot;);&#10;                    return true; // Arrêter le dash&#10;                }&#10;            }&#10;            &#10;            return false; // Continuer le dash&#10;        }&#10;        &#10;&#10;        // Désactive toutes les collisions d'un ennemi pour permettre au dash de passer à travers.&#10;        private void DisableEnemyCollisions(GameObject enemy)&#10;        {&#10;&#10;            Collider[] colliders = enemy.GetComponentsInChildren&lt;Collider&gt;();&#10;            foreach (Collider col in colliders)&#10;            {&#10;                col.enabled = false;&#10;            }&#10;            &#10;            // Désactiver également le rigidbody pour éviter les interactions physiques&#10;            Rigidbody rb = enemy.GetComponent&lt;Rigidbody&gt;();&#10;            if (rb != null)&#10;            {&#10;                rb.isKinematic = true;&#10;                rb.detectCollisions = false;&#10;            }&#10;            &#10;            Rigidbody[] childRbs = enemy.GetComponentsInChildren&lt;Rigidbody&gt;();&#10;            foreach (Rigidbody childRb in childRbs)&#10;            {&#10;                childRb.isKinematic = true;&#10;                childRb.detectCollisions = false;&#10;            }&#10;        }&#10;        &#10;        private System.Collections.IEnumerator CleanupEnemyTracking(GameObject enemy)&#10;        {&#10;            yield return new WaitForSeconds(2f);&#10;            if (enemy == null)&#10;            {&#10;                // L'ennemi a bien été détruit, on peut le retirer du tracking&#10;                enemiesKilledByDash.Remove(enemy);&#10;            }&#10;        }&#10;        &#10;        // Vérifie si un ennemi a été tué par le dash&#10;        public static bool WasKilledByDash(GameObject enemy)&#10;        {&#10;            return enemiesKilledByDash.Contains(enemy);&#10;        }&#10;        &#10;        private void EndDash()&#10;        {&#10;            isDashing = false;&#10;            dashTimer = 0f;&#10;            cooldownTimer = 0f;&#10;            targetFOV = defaultFOV;&#10;        }&#10;        &#10;        private void UpdateFOV()&#10;        {&#10;            if (playerCamera != null)&#10;            {&#10;                playerCamera.fieldOfView = Mathf.Lerp(&#10;                    playerCamera.fieldOfView,&#10;                    targetFOV,&#10;                    Time.deltaTime * fovTransitionSpeed&#10;                );&#10;            }&#10;        }&#10;        &#10;        public bool CanDash =&gt; currentDashCharge &gt;= 1f &amp;&amp; !isDashing &amp;&amp; (autoRegenerate ? cooldownTimer &gt;= dashCooldown : true);&#10;        &#10;        public float DashCooldownProgress =&gt; Mathf.Clamp01(cooldownTimer / dashCooldown);&#10;        &#10;        public float CurrentDashCharge =&gt; currentDashCharge;&#10;        &#10;        // Appelé quand un ennemi spécial (DashEnergyEnemy) est tué&#10;        public void OnDashEnemyKilled(float energyAmount)&#10;        {&#10;            float oldCharge = currentDashCharge;&#10;            &#10;            // Calculer l'énergie par ennemi (1 / nombre d'ennemis requis)&#10;            float energyPerEnemy = 1f / Mathf.Max(1, enemiesRequiredForFullCharge);&#10;            &#10;            // Ajouter l'énergie (multipliée par le montant configuré sur l'ennemi)&#10;            currentDashCharge = Mathf.Clamp01(currentDashCharge + (energyPerEnemy * energyAmount));&#10;            &#10;            Debug.Log($&quot;[PillarDashSystem] Dash rechargé! {oldCharge:P0} → {currentDashCharge:P0} (+{energyPerEnemy * energyAmount:P0})&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>